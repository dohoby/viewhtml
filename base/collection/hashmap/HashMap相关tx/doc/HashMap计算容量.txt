int n = cap - 1; // cap = 10，n = 9
n |= n >>> 1

第一次位移 n = 13
00000000 00000000 00000000 00001001 // 9
00000000 00000000 00000000 00000100 // 4
00000000 00000000 00000000 00001101 // 13

由于n不等于0，则n的二进制表示中总有一位是1.这时候考虑最高位的1，通过无符号右移1位，则将最高位的1右移了1位，再做或操作。
使得 n 的二进制表示中，与最高位的1紧邻的右边一位也为1

第二次右移
n |= n >>> 2 // 第一次右移，n = 13
00000000 00000000 00000000 00001101 // 13
00000000 00000000 00000000 00000011 // 3
00000000 00000000 00000000 00001111 // 15

注意：这个n已经经过了 n |= n >>> 1的操作，假设此时 n 为 00000000 00000000 00000000 00001101，则无符号右移2位，会将最高位两个连续的1右移两位，然后再与原本的n进行或操作，这样n的二进制表示中，最高位会有4个连续的1。

第三次右移
n |= n >>> 4 // 第一、第二次右移，n = 15
00000000 00000000 00000000 00001111 // 15
00000000 00000000 00000000 00000000 // 0
00000000 00000000 00000000 00001111 // 15

这次把已有的高位中的连续的4个1，右移4位，再做或操作。这样n的二进制位表示的高位中，正常会有8个连续的1。
注意：容量最大也就是32位的正数，因此最后只有 n |= n >>> 16，最多就是32个1。但是，这时候32个1是负数，在执行tableSizeFor之前，会对initialCapacity进行判断。如果大于 1 << 30，则取最大值 MAXIMUM_CAPACITY。如果结果等于最大值，就会执行位移操作

这里执行多次位移运算和或运算的目的，是让低位全部都成1，在最后会有一个 n + 1 操作，使我们最终计算的结果是 2的n次幂