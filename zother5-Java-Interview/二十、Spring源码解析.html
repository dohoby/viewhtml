
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>二十、Spring源码解析 · java实用笔记</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-page-toc-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-theme-comscore/test.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Cache-Control" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="二十一、Tomcat源码解析.html" />
    
    
    <link rel="prev" href="二、设计模式.html" />
    


    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    
    
        
        <li>
            <a href="http://blog.liangqingxiang.top/" target="_blank" class="custom-link">Home</a>
        </li>
    
    

    
    <li class="divider"></li>
    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                        <b>1.1.</b>
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                        <b>1.2.</b>
                    
                    Base
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" >
            
                <span>
            
                    
                        <b>1.2.1.</b>
                    
                    Collection
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.1" >
            
                <span>
            
                    
                        <b>1.2.1.1.</b>
                    
                    Hashmap
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.1.1" data-path="../base/collection/hashmap/HashMap相关.html">
            
                <a href="../base/collection/hashmap/HashMap相关.html">
            
                    
                        <b>1.2.1.1.1.</b>
                    
                    HashMap相关
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.1.2" data-path="../base/collection/hashmap/jdk1.7hashmap源码分析.html">
            
                <a href="../base/collection/hashmap/jdk1.7hashmap源码分析.html">
            
                    
                        <b>1.2.1.1.2.</b>
                    
                    jdk1.7hashmap源码分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.1.3" data-path="../base/collection/hashmap/jdk1.8ConcurrentHashMap源码分析.html">
            
                <a href="../base/collection/hashmap/jdk1.8ConcurrentHashMap源码分析.html">
            
                    
                        <b>1.2.1.1.3.</b>
                    
                    jdk1.8ConcurrentHashMap源码分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.1.4" data-path="../base/collection/hashmap/jdk1.8HashMap源码分析.html">
            
                <a href="../base/collection/hashmap/jdk1.8HashMap源码分析.html">
            
                    
                        <b>1.2.1.1.4.</b>
                    
                    jdk1.8hashmap源码分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.1.5" data-path="../base/collection/hashmap/Jdk1.8源码解析-java.util.HashMap-treeifyBin.html">
            
                <a href="../base/collection/hashmap/Jdk1.8源码解析-java.util.HashMap-treeifyBin.html">
            
                    
                        <b>1.2.1.1.5.</b>
                    
                    Jdk1.8源码解析-java.util.HashMap#treeifyBin
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.1.2" >
            
                <span>
            
                    
                        <b>1.2.1.2.</b>
                    
                    hashmap源码
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.2.1" data-path="../base/collection/hashmap源码/jdk1.7HashMap源码.html">
            
                <a href="../base/collection/hashmap源码/jdk1.7HashMap源码.html">
            
                    
                        <b>1.2.1.2.1.</b>
                    
                    jdk1.7HashMap源码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.2.2" data-path="../base/collection/hashmap源码/jdk1.8ConcurrentHashMap源码.html">
            
                <a href="../base/collection/hashmap源码/jdk1.8ConcurrentHashMap源码.html">
            
                    
                        <b>1.2.1.2.2.</b>
                    
                    jdk1.8ConcurrentHashMap源码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.2.3" data-path="../base/collection/hashmap源码/jdk1.8HashMap源码.html">
            
                <a href="../base/collection/hashmap源码/jdk1.8HashMap源码.html">
            
                    
                        <b>1.2.1.2.3.</b>
                    
                    jdk1.8HashMap源码
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.2" >
            
                <span>
            
                    
                        <b>1.2.2.</b>
                    
                    String
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.2.1" data-path="../base/string/StringBuffer和StringBuilder.html">
            
                <a href="../base/string/StringBuffer和StringBuilder.html">
            
                    
                        <b>1.2.2.1.</b>
                    
                    集合StringBuffer和StringBuilder
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.2" data-path="../base/string/string源码.html">
            
                <a href="../base/string/string源码.html">
            
                    
                        <b>1.2.2.2.</b>
                    
                    string源码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.3" data-path="../base/string/string源码学习.html">
            
                <a href="../base/string/string源码学习.html">
            
                    
                        <b>1.2.2.3.</b>
                    
                    string源码学习
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.4" data-path="../base/string/字符串string学习.html">
            
                <a href="../base/string/字符串string学习.html">
            
                    
                        <b>1.2.2.4.</b>
                    
                    字符串string学习
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.5" data-path="../base/string/字符串string学习2-lg.html">
            
                <a href="../base/string/字符串string学习2-lg.html">
            
                    
                        <b>1.2.2.5.</b>
                    
                    字符串string学习2
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../base/基本类型装箱拆箱.html">
            
                <a href="../base/基本类型装箱拆箱.html">
            
                    
                        <b>1.2.3.</b>
                    
                    集合基本类型装箱拆箱
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                        <b>1.3.</b>
                    
                    Design Patterns
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                        <b>1.3.1.</b>
                    
                    Spring
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1.1" data-path="../designPatterns/spring/spring享元模式.html">
            
                <a href="../designPatterns/spring/spring享元模式.html">
            
                    
                        <b>1.3.1.1.</b>
                    
                    spring享元模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.2" data-path="../designPatterns/spring/spring代理模式.html">
            
                <a href="../designPatterns/spring/spring代理模式.html">
            
                    
                        <b>1.3.1.2.</b>
                    
                    spring代理模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.3" data-path="../designPatterns/spring/spring策略模式.html">
            
                <a href="../designPatterns/spring/spring策略模式.html">
            
                    
                        <b>1.3.1.3.</b>
                    
                    spring策略模式
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                        <b>1.4.</b>
                    
                    Jvm
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../jvm/jvm内存模型.html">
            
                <a href="../jvm/jvm内存模型.html">
            
                    
                        <b>1.4.1.</b>
                    
                    jvm内存模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../jvm/jvm参数.html">
            
                <a href="../jvm/jvm参数.html">
            
                    
                        <b>1.4.2.</b>
                    
                    jvm参数
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" >
            
                <span>
            
                    
                        <b>1.5.</b>
                    
                    Mybatis
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" >
            
                <span>
            
                    
                        <b>1.5.1.</b>
                    
                    mybatis分页插件
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1.1" data-path="../mybatis/mybatis分页插件/mybatis插件引入.html">
            
                <a href="../mybatis/mybatis分页插件/mybatis插件引入.html">
            
                    
                        <b>1.5.1.1.</b>
                    
                    mybatis插件引入
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.1.2" data-path="../mybatis/mybatis分页插件/Page.html">
            
                <a href="../mybatis/mybatis分页插件/Page.html">
            
                    
                        <b>1.5.1.2.</b>
                    
                    Page
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.1.3" data-path="../mybatis/mybatis分页插件/PagePlugin.html">
            
                <a href="../mybatis/mybatis分页插件/PagePlugin.html">
            
                    
                        <b>1.5.1.3.</b>
                    
                    Page Plugin
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.1.4" data-path="../mybatis/mybatis分页插件/ReflectHelper.html">
            
                <a href="../mybatis/mybatis分页插件/ReflectHelper.html">
            
                    
                        <b>1.5.1.4.</b>
                    
                    Reflect Helper
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5.2" >
            
                <span>
            
                    
                        <b>1.5.2.</b>
                    
                    mybatis分页插件2
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.2.1" data-path="../mybatis/mybatis分页插件2/mybatis插件引入.html">
            
                <a href="../mybatis/mybatis分页插件2/mybatis插件引入.html">
            
                    
                        <b>1.5.2.1.</b>
                    
                    mybatis插件引入
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2.2" data-path="../mybatis/mybatis分页插件2/PageInterceptor.html">
            
                <a href="../mybatis/mybatis分页插件2/PageInterceptor.html">
            
                    
                        <b>1.5.2.2.</b>
                    
                    Page Interceptor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2.3" data-path="../mybatis/mybatis分页插件2/Pagination.html">
            
                <a href="../mybatis/mybatis分页插件2/Pagination.html">
            
                    
                        <b>1.5.2.3.</b>
                    
                    Pagination
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../mybatis/mybatis-view1.html">
            
                <a href="../mybatis/mybatis-view1.html">
            
                    
                        <b>1.5.3.</b>
                    
                    Mybatis View 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../mybatis/mybatis学习.html">
            
                <a href="../mybatis/mybatis学习.html">
            
                    
                        <b>1.5.4.</b>
                    
                    mybatis学习
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../mybatis/mybatis源码.html">
            
                <a href="../mybatis/mybatis源码.html">
            
                    
                        <b>1.5.5.</b>
                    
                    mybatis源码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6" data-path="../mybatis/mybatis源码学习总结1.html">
            
                <a href="../mybatis/mybatis源码学习总结1.html">
            
                    
                        <b>1.5.6.</b>
                    
                    mybatis源码学习总结1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7" data-path="../mybatis/mybatis源码学习总结2.html">
            
                <a href="../mybatis/mybatis源码学习总结2.html">
            
                    
                        <b>1.5.7.</b>
                    
                    mybatis源码学习总结2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.8" data-path="../mybatis/mybatis用法.html">
            
                <a href="../mybatis/mybatis用法.html">
            
                    
                        <b>1.5.8.</b>
                    
                    mybatis用法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.9" data-path="../mybatis/常见mybatis用法.html">
            
                <a href="../mybatis/常见mybatis用法.html">
            
                    
                        <b>1.5.9.</b>
                    
                    常见mybatis用法
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" >
            
                <span>
            
                    
                        <b>1.6.</b>
                    
                    Mybatis Spring
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../mybatis-spring/Mybatis-Spring源码分析.html">
            
                <a href="../mybatis-spring/Mybatis-Spring源码分析.html">
            
                    
                        <b>1.6.1.</b>
                    
                    Mybatis-Spring源码分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" >
            
                <span>
            
                    
                        <b>1.7.</b>
                    
                    Redis
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../redis/缓存.html">
            
                <a href="../redis/缓存.html">
            
                    
                        <b>1.7.1.</b>
                    
                    缓存
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" >
            
                <span>
            
                    
                        <b>1.8.</b>
                    
                    Spring
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" >
            
                <span>
            
                    
                        <b>1.8.1.</b>
                    
                    Aop
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1.1" data-path="../spring/aop/aop动态代理学习.html">
            
                <a href="../spring/aop/aop动态代理学习.html">
            
                    
                        <b>1.8.1.1.</b>
                    
                    aop动态代理学习
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.1.2" data-path="../spring/aop/aop学习.html">
            
                <a href="../spring/aop/aop学习.html">
            
                    
                        <b>1.8.1.2.</b>
                    
                    mybatis学习
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.1.3" data-path="../spring/aop/JdkDanymicAopProxy源码.html">
            
                <a href="../spring/aop/JdkDanymicAopProxy源码.html">
            
                    
                        <b>1.8.1.3.</b>
                    
                    JdkDanymicAopProxy源码
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.2" >
            
                <span>
            
                    
                        <b>1.8.2.</b>
                    
                    Ioc
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.2.1" data-path="../spring/ioc/bean实例化过程.html">
            
                <a href="../spring/ioc/bean实例化过程.html">
            
                    
                        <b>1.8.2.1.</b>
                    
                    bean实例化过程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.2" data-path="../spring/ioc/spring-ioc原理.html">
            
                <a href="../spring/ioc/spring-ioc原理.html">
            
                    
                        <b>1.8.2.2.</b>
                    
                    spring-ioc原理
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.3" >
            
                <span>
            
                    
                        <b>1.8.3.</b>
                    
                    事务
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.3.1" data-path="../spring/事务/spring事务管理.html">
            
                <a href="../spring/事务/spring事务管理.html">
            
                    
                        <b>1.8.3.1.</b>
                    
                    spring事务管理
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" >
            
                <span>
            
                    
                        <b>1.9.</b>
                    
                    Springboot
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" >
            
                <span>
            
                    
                        <b>1.9.1.</b>
                    
                    springboot配置
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1.1" data-path="../springboot/springboot配置/springboot配置文件加载分析.html">
            
                <a href="../springboot/springboot配置/springboot配置文件加载分析.html">
            
                    
                        <b>1.9.1.1.</b>
                    
                    springboot配置文件加载分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.2" data-path="../springboot/springboot配置/修改springboot默认加载application-properties文件.html">
            
                <a href="../springboot/springboot配置/修改springboot默认加载application-properties文件.html">
            
                    
                        <b>1.9.1.2.</b>
                    
                    修改springboot默认加载application.properties文件
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.2" >
            
                <span>
            
                    
                        <b>1.9.2.</b>
                    
                    监听器
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.2.1" data-path="../springboot/监听器/springboot监听器.html">
            
                <a href="../springboot/监听器/springboot监听器.html">
            
                    
                        <b>1.9.2.1.</b>
                    
                    springboot监听器
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../springboot/SpringApplication源码分析.html">
            
                <a href="../springboot/SpringApplication源码分析.html">
            
                    
                        <b>1.9.3.</b>
                    
                    SpringApplication源码分析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                        <b>1.10.</b>
                    
                    Zother 1 Java Face Notes
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../zother1-JavaFaceNotes/ 异常&反射.html">
            
                <a href="../zother1-JavaFaceNotes/ 异常&反射.html">
            
                    
                        <b>1.10.1.</b>
                    
                     异常&反射
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../zother1-JavaFaceNotes/Dubbo.html">
            
                <a href="../zother1-JavaFaceNotes/Dubbo.html">
            
                    
                        <b>1.10.2.</b>
                    
                    Dubbo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../zother1-JavaFaceNotes/IO&NIO.html">
            
                <a href="../zother1-JavaFaceNotes/IO&NIO.html">
            
                    
                        <b>1.10.3.</b>
                    
                    IO NIO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../zother1-JavaFaceNotes/Java基础.html">
            
                <a href="../zother1-JavaFaceNotes/Java基础.html">
            
                    
                        <b>1.10.4.</b>
                    
                    Java基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="../zother1-JavaFaceNotes/java集合.html">
            
                <a href="../zother1-JavaFaceNotes/java集合.html">
            
                    
                        <b>1.10.5.</b>
                    
                    java集合
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="../zother1-JavaFaceNotes/JVM.html">
            
                <a href="../zother1-JavaFaceNotes/JVM.html">
            
                    
                        <b>1.10.6.</b>
                    
                    JVM
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="../zother1-JavaFaceNotes/Kafka.html">
            
                <a href="../zother1-JavaFaceNotes/Kafka.html">
            
                    
                        <b>1.10.7.</b>
                    
                    Kafka
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="../zother1-JavaFaceNotes/Linux.html">
            
                <a href="../zother1-JavaFaceNotes/Linux.html">
            
                    
                        <b>1.10.8.</b>
                    
                    Linux
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.9" data-path="../zother1-JavaFaceNotes/Mybatis.html">
            
                <a href="../zother1-JavaFaceNotes/Mybatis.html">
            
                    
                        <b>1.10.9.</b>
                    
                    Mybatis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10" data-path="../zother1-JavaFaceNotes/MySql.html">
            
                <a href="../zother1-JavaFaceNotes/MySql.html">
            
                    
                        <b>1.10.10.</b>
                    
                    My Sql
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11" data-path="../zother1-JavaFaceNotes/Nginx.html">
            
                <a href="../zother1-JavaFaceNotes/Nginx.html">
            
                    
                        <b>1.10.11.</b>
                    
                    Nginx
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.12" data-path="../zother1-JavaFaceNotes/Redis.html">
            
                <a href="../zother1-JavaFaceNotes/Redis.html">
            
                    
                        <b>1.10.12.</b>
                    
                    Redis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.13" data-path="../zother1-JavaFaceNotes/Spring.html">
            
                <a href="../zother1-JavaFaceNotes/Spring.html">
            
                    
                        <b>1.10.13.</b>
                    
                    Spring
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.14" data-path="../zother1-JavaFaceNotes/SpringBoot.html">
            
                <a href="../zother1-JavaFaceNotes/SpringBoot.html">
            
                    
                        <b>1.10.14.</b>
                    
                    Spring Boot
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.15" data-path="../zother1-JavaFaceNotes/SpringCloud.html">
            
                <a href="../zother1-JavaFaceNotes/SpringCloud.html">
            
                    
                        <b>1.10.15.</b>
                    
                    Spring Cloud
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.16" data-path="../zother1-JavaFaceNotes/多线程.html">
            
                <a href="../zother1-JavaFaceNotes/多线程.html">
            
                    
                        <b>1.10.16.</b>
                    
                    多线程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.17" data-path="../zother1-JavaFaceNotes/简历.html">
            
                <a href="../zother1-JavaFaceNotes/简历.html">
            
                    
                        <b>1.10.17.</b>
                    
                    简历
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="./">
            
                <a href="./">
            
                    
                        <b>1.11.</b>
                    
                    Zother 5 Java Interview
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="Java基础学习.html">
            
                <a href="Java基础学习.html">
            
                    
                        <b>1.11.1.</b>
                    
                    Java基础学习
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="Java集合面试题及答案.html">
            
                <a href="Java集合面试题及答案.html">
            
                    
                        <b>1.11.2.</b>
                    
                    Java集合面试题及答案
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="一、Java基础.html">
            
                <a href="一、Java基础.html">
            
                    
                        <b>1.11.3.</b>
                    
                    一、Java基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.4" data-path="七、JavaWeb.html">
            
                <a href="七、JavaWeb.html">
            
                    
                        <b>1.11.4.</b>
                    
                    七、JavaWeb
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.5" data-path="三、Java 集合.html">
            
                <a href="三、Java 集合.html">
            
                    
                        <b>1.11.5.</b>
                    
                    三、Java 集合
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.6" data-path="九、操作系统.html">
            
                <a href="九、操作系统.html">
            
                    
                        <b>1.11.6.</b>
                    
                    九、操作系统
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.7" data-path="二、设计模式.html">
            
                <a href="二、设计模式.html">
            
                    
                        <b>1.11.7.</b>
                    
                    二、设计模式
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.11.8" data-path="二十、Spring源码解析.html">
            
                <a href="二十、Spring源码解析.html">
            
                    
                        <b>1.11.8.</b>
                    
                    二十、Spring源码解析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.9" data-path="二十一、Tomcat源码解析.html">
            
                <a href="二十一、Tomcat源码解析.html">
            
                    
                        <b>1.11.9.</b>
                    
                    二十一、Tomcat源码解析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.10" data-path="五、JVM.html">
            
                <a href="五、JVM.html">
            
                    
                        <b>1.11.10.</b>
                    
                    五、JVM
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.11" data-path="八、Mysql.html">
            
                <a href="八、Mysql.html">
            
                    
                        <b>1.11.11.</b>
                    
                    八、Mysql
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" >
            
                <span>
            
                    
                        <b>1.12.</b>
                    
                    Zother 7 Java Interview
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" >
            
                <span>
            
                    
                        <b>1.12.1.</b>
                    
                    Data Structures Algorithms
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1.1" data-path="../zother7-JavaInterview/dataStructures-algorithms/算法面试真题汇总.html">
            
                <a href="../zother7-JavaInterview/dataStructures-algorithms/算法面试真题汇总.html">
            
                    
                        <b>1.12.1.1.</b>
                    
                    算法面试真题汇总
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.1.2" data-path="../zother7-JavaInterview/dataStructures-algorithms/算法题目难点题目总结.html">
            
                <a href="../zother7-JavaInterview/dataStructures-algorithms/算法题目难点题目总结.html">
            
                    
                        <b>1.12.1.2.</b>
                    
                    算法题目难点题目总结
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.1.3" data-path="../zother7-JavaInterview/dataStructures-algorithms/递归套路总结.html">
            
                <a href="../zother7-JavaInterview/dataStructures-algorithms/递归套路总结.html">
            
                    
                        <b>1.12.1.3.</b>
                    
                    递归套路总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12.2" >
            
                <span>
            
                    
                        <b>1.12.2.</b>
                    
                    Interview
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.2.1" data-path="../zother7-JavaInterview/interview/已投公司情况.html">
            
                <a href="../zother7-JavaInterview/interview/已投公司情况.html">
            
                    
                        <b>1.12.2.1.</b>
                    
                    已投公司情况
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2.2" data-path="../zother7-JavaInterview/interview/自我介绍和项目介绍.html">
            
                <a href="../zother7-JavaInterview/interview/自我介绍和项目介绍.html">
            
                    
                        <b>1.12.2.2.</b>
                    
                    自我介绍和项目介绍
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12.3" >
            
                <span>
            
                    
                        <b>1.12.3.</b>
                    
                    Interview Experience
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.3.1" data-path="../zother7-JavaInterview/interview-experience/各大公司面经.html">
            
                <a href="../zother7-JavaInterview/interview-experience/各大公司面经.html">
            
                    
                        <b>1.12.3.1.</b>
                    
                    各大公司面经
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3.2" data-path="../zother7-JavaInterview/interview-experience/面试常见知识.html">
            
                <a href="../zother7-JavaInterview/interview-experience/面试常见知识.html">
            
                    
                        <b>1.12.3.2.</b>
                    
                    面试常见知识
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3.3" data-path="../zother7-JavaInterview/interview-experience/面试常见问题分类汇总.html">
            
                <a href="../zother7-JavaInterview/interview-experience/面试常见问题分类汇总.html">
            
                    
                        <b>1.12.3.3.</b>
                    
                    面试常见问题分类汇总
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12.4" >
            
                <span>
            
                    
                        <b>1.12.4.</b>
                    
                    Microservice
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.4.1" data-path="../zother7-JavaInterview/microservice/微服务相关资料.html">
            
                <a href="../zother7-JavaInterview/microservice/微服务相关资料.html">
            
                    
                        <b>1.12.4.1.</b>
                    
                    微服务相关资料
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12.5" >
            
                <span>
            
                    
                        <b>1.12.5.</b>
                    
                    Network
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.5.1" data-path="../zother7-JavaInterview/network/http面试问题全解析.html">
            
                <a href="../zother7-JavaInterview/network/http面试问题全解析.html">
            
                    
                        <b>1.12.5.1.</b>
                    
                    http面试问题全解析
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12.6" >
            
                <span>
            
                    
                        <b>1.12.6.</b>
                    
                    Operating System
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.6.1" data-path="../zother7-JavaInterview/operating-system/后端程序员必备的Linux基础知识.html">
            
                <a href="../zother7-JavaInterview/operating-system/后端程序员必备的Linux基础知识.html">
            
                    
                        <b>1.12.6.1.</b>
                    
                    后端程序员必备的Linux基础知识
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.6.2" data-path="../zother7-JavaInterview/operating-system/操作系统、计算机网络相关知识.html">
            
                <a href="../zother7-JavaInterview/operating-system/操作系统、计算机网络相关知识.html">
            
                    
                        <b>1.12.6.2.</b>
                    
                    操作系统、计算机网络相关知识
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12.7" >
            
                <span>
            
                    
                        <b>1.12.7.</b>
                    
                    Project
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.7.1" data-path="../zother7-JavaInterview/project/消息中间件面试题.html">
            
                <a href="../zother7-JavaInterview/project/消息中间件面试题.html">
            
                    
                        <b>1.12.7.1.</b>
                    
                    消息中间件面试题
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.7.2" data-path="../zother7-JavaInterview/project/秒杀项目总结.html">
            
                <a href="../zother7-JavaInterview/project/秒杀项目总结.html">
            
                    
                        <b>1.12.7.2.</b>
                    
                    秒杀项目总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="../学习路线.html">
            
                <a href="../学习路线.html">
            
                    
                        <b>1.13.</b>
                    
                    学习路线
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >二十、Spring源码解析</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <ul>
<li>Spring Source</li>
<li>&#x4ED6;&#x4EBA;&#x603B;&#x7ED3;<ul>
<li>Spring1)ioc &#x5BB9;&#x5668;&#x2014;&#x2014;BeanFactory &#x662F;&#x6700;&#x539F;&#x59CB;&#x7684; ioc &#x5BB9;&#x5668;&#xFF0C;&#x6709;&#x4EE5;&#x4E0B;&#x65B9;&#x6CD5; 1.getBean2.&#x5224;&#x65AD;&#x662F;&#x5426;&#x6709; Bean&#xFF0C;containsBean3.&#x5224;&#x65AD;&#x662F;&#x5426;&#x5355;&#x4F8B; isSingleton&#x3002;BeanFactory &#x53EA;&#x662F;&#x5BF9; ioc &#x5BB9;&#x5668;&#x6700;&#x57FA;&#x672C;&#x884C;&#x4E3A;&#x4F5C;&#x4E86;&#x5B9A;&#x4E49;&#xFF0C;&#x800C;&#x4E0D;&#x5173;&#x5FC3; Bean &#x662F;&#x600E;&#x6837;&#x5B9A;&#x4E49;&#x548C;&#x52A0;&#x8F7D;&#x7684;&#x3002;&#x5982;&#x679C;&#x6211;&#x4EEC;&#x60F3;&#x8981;&#x77E5;&#x9053;&#x4E00;&#x4E2A;&#x5DE5;&#x5382;&#x5177;&#x4F53;&#x4EA7;&#x751F;&#x5BF9;&#x8C61;&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x5219;&#x8981;&#x770B;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x7684;&#x5B9E;&#x73B0;&#x7C7B;&#x3002;&#x5728; spring &#x4E2D;&#x5B9E;&#x73B0;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x6709;&#x5F88;&#x591A;&#x7C7B;&#xFF0C;&#x5176;&#x4E2D;&#x4E00;&#x4E2A; &#x662F;xmlBeanFactory&#x3002;</li>
</ul>
</li>
<li>xmlBeanFactory &#x7684;&#x529F;&#x80FD;&#x662F;&#x5EFA;&#x7ACB;&#x5728; DefaultListablexmlBeanFactory &#x8FD9;&#x4E2A;&#x57FA;&#x672C;&#x5BB9;&#x5668;&#x7684;&#x57FA;&#x7840;&#x4E0A;&#x7684;&#xFF0C;&#x5E76;&#x5728;&#x8FD9;&#x4E2A;&#x57FA;&#x672C;&#x5BB9;&#x5668;&#x7684;&#x57FA;&#x7840;&#x4E0A;&#x5B9E;&#x884C;&#x4E86;&#x5176;&#x4ED6;&#x8BF8;&#x5982; xml &#x8BFB;&#x53D6;&#x7684;&#x9644;&#x52A0;&#x529F;&#x80FD;&#x3002; xmlBeanFactory&#xFF08;Resource resource)&#x6784;&#x9020;&#x51FD;&#x6570;&#xFF0C;resource &#x662F; spring &#x4E2D;&#x5BF9;&#x4E0E;&#x5916;&#x90E8;&#x8D44;&#x6E90;&#x7684;&#x62BD;&#x8C61;&#xFF0C;&#x6700;&#x5E38;&#x89C1;&#x7684;&#x662F;&#x6587;&#x4EF6;&#x7684;&#x62BD;&#x8C61;&#xFF0C;&#x7279;&#x522B;&#x662F; xml &#x6587;&#x4EF6;&#xFF0C;&#x800C;&#x4E14; resource &#x91CC;&#x9762;&#x901A;&#x5E38;&#x662F;&#x4FDD;&#x5B58;&#x4E86; spring &#x4F7F;&#x7528;&#x8005;&#x7684; Bean &#x5B9A;&#x4E49;&#xFF0C;eg.applicationContext.xml &#x5728;&#x88AB;&#x52A0;&#x8F7D;&#x65F6;&#xFF0C;&#x5C31;&#x4F1A;&#x88AB;&#x62BD;&#x8C61;&#x4E3A; resource &#x5904;&#x7406;&#x3002;</li>
<li>[&#x6211;&#x81EA;&#x5DF1;&#x7406;&#x89E3;, resource &#x5C31;&#x662F;&#x5B9A;&#x4E49; Bean &#x7684; xml &#x6587;&#x4EF6;]&#x3002; <ul>
<li>loc &#x5BB9;&#x5668;&#x5EFA;&#x7ACB;&#x8FC7;&#x7A0B;&#xFF1A;1)&#x521B;&#x5EFA; ioc &#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x7684;&#x62BD;&#x8C61;&#x8D44;&#x6E90;&#xFF0C;&#x8FD9;&#x4E2A;&#x62BD;&#x8C61;&#x8D44;&#x6E90;&#x5305;&#x542B;&#x4E86; BeanDefinition &#x7684;&#x5B9A;&#x4E49;&#x4FE1;&#x606F;&#x3002;2)&#x521B;&#x5EFA;&#x4E00;&#x4E2A; BeanFactory&#xFF0C;&#x8FD9;&#x91CC;&#x4F7F;&#x7528;&#x7684;&#x662F; DefaultListablexmlBeanFactory&#x3002;3)&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x8F7D;&#x5165; BeanDefinition &#x7684;&#x8BFB;&#x53D6;&#x5668;&#xFF0C;&#x8FD9;&#x91CC;&#x4F7F;&#x7528; xmlBeanDefinitionReader &#x6765;&#x8F7D;&#x5165; xml &#x6587;&#x4EF6;&#x5F62;&#x5F0F;&#x7684; BeanDefinition&#x3002;4)&#x7136;&#x540E;&#x5C06;&#x4E0A;&#x9762;&#x5B9A;&#x4E49;&#x597D;&#x7684; resource &#x901A;&#x8FC7;&#x4E00;&#x4E2A;&#x56DE;&#x8C03;&#x914D;&#x7F6E;&#x7ED9; BeanFactory&#x3002;</li>
<li>5)&#x4ECE;&#x8D44;&#x6E90;&#x91CC;&#x8BFB;&#x5165;&#x914D;&#x7F6E;&#x4FE1;&#x606F;&#xFF0C;&#x5177;&#x4F53;&#x89E3;&#x6790;&#x8FC7;&#x7A0B;&#x7531; xmlBeanDefinitionReader &#x5B8C;&#x6210;&#x3002;6)ioc &#x5BB9;&#x5668;&#x5EFA;&#x7ACB;&#x8D77;&#x6765;&#x3002;</li>
</ul>
</li>
<li>BeanDefinition &#x7C7B;&#x4F3C;&#x4E8E; resource &#x63A5;&#x53E3;&#x7684;&#x529F;&#x80FD;&#xFF0C;&#x8D77;&#x5230;&#x7684;&#x4F5C;&#x7528;&#x5C31;&#x662F;&#x5BF9;&#x6240;&#x6709;&#x7684; Bean &#x8FDB;&#x884C;&#x4E00;&#x5C42;&#x62BD;&#x8C61;&#x7684;&#x7EDF;&#x4E00;&#xFF0C;&#x628A;&#x5F62;&#x5F0F;&#x5404;&#x6837;&#x7684;&#x5BF9;&#x8C61;&#x7EDF;&#x4E00;&#x5C01;&#x88C5;&#x4E3A;&#x4E00;&#x4E2A;&#x4FBF;&#x4E8E; spring &#x5185;&#x90E8;&#x8FDB;&#x884C;&#x534F;&#x8C03;&#x7BA1;&#x7406;&#x548C;&#x8C03;&#x5EA6;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;BeanDefinition &#x5C4F;&#x853D;&#x4E86;&#x4E0D;&#x540C;&#x5BF9;&#x8C61;&#x5BF9;&#x4E8E; spring &#x6846;&#x67B6;&#x7684;&#x5DEE;&#x5F02;&#x3002; </li>
<li>Resource &#x91CC;&#x6709; inputStream&#x3002; </li>
<li>&#x89E3;&#x6790; xml&#xFF0C;&#x83B7;&#x5F97; document &#x5BF9;&#x8C61;&#xFF0C;&#x63A5;&#x4E0B;&#x6765;&#x53EA;&#x8981;&#x518D;&#x5BF9; document &#x7ED3;&#x6784;&#x8FDB;&#x884C;&#x5206;&#x6790;&#x4FBF;&#x53EF;&#x77E5;&#x9053; Bean &#x5728; xml &#x4E2D;&#x662F;&#x600E;&#x4E48;&#x5B9A;&#x4E49;&#x7684;&#xFF0C;&#x4E5F;&#x5C31;&#x53EF;&#x4EE5;&#x5C06;&#x5176;&#x8F6C;&#x5316;&#x4E3A; BeanDefinition &#x5BF9;&#x8C61;&#x3002;&#x6211;&#x4EEC;&#x914D;&#x7F6E;&#x7684; Bean &#x7684;&#x4FE1;&#x606F;&#x7ECF;&#x8FC7;&#x89E3;&#x6790;&#xFF0C;&#x5728; spring &#x5185;&#x90E8;&#x5DF2;&#x7ECF;&#x8F6C;&#x6362;&#x4E3A; BeanDefinition &#x8FD9;&#x79CD;&#x7EDF;&#x4E00;&#x7684;&#x7ED3;&#x6784;&#xFF0C;&#x4F46;&#x8FD9;&#x4E9B;&#x6570;&#x636E;&#x8FD8;&#x4E0D;&#x80FD;&#x4F9B; ioc &#x5BB9;&#x5668;&#x76F4;&#x63A5;&#x4F7F;&#x7528;&#xFF0C;&#x9700;&#x8981;&#x5728; ioc &#x5BB9;&#x5668;&#x4E2D;&#x5BF9;&#x8FD9;&#x4E9B; BeanDefinition &#x6570;&#x636E;&#x8FDB;&#x884C;&#x6CE8;&#x518C;&#xFF0C;&#x6CE8;&#x518C;&#x5B8C;&#x6210;&#x7684; BeanDefinition&#xFF0C;&#x90FD;&#x4F1A;&#x4EE5; BeanName &#x4E3A; Key&#xFF0C;BeanDefinition &#x4E3A; value&#xFF0C;&#x4EA4;&#x7531; map &#x7BA1;&#x7406;&#x3002;&#x6CE8;&#x518C;&#x5B8C;&#x4E4B;&#x540E;&#xFF0C;&#x4E00;&#x4E2A; ioc &#x5BB9;&#x5668;&#x5C31;&#x53EF;&#x4EE5;&#x7528;&#x4E86;&#x3002; </li>
<li>&#x81EA;&#x5DF1;&#x7406;&#x89E3;&#x7684;&#xFF0C;xml &#x6587;&#x4EF6;&#x62BD;&#x8C61;&#x4E3A; resource &#x5BF9;&#x8C61;&#xFF0C;Bean &#x62BD;&#x8C61;&#x4E3A; BeanDefinition &#x5BF9;&#x8C61;&#x3002; <ul>
<li>2)    &#x4F9D;&#x8D56;&#x6CE8;&#x5165;&#x2014;&#x2014;&#x4F9D;&#x8D56;&#x6CE8;&#x5165;&#x53D1;&#x751F;&#x5728; getBean &#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;getBean &#x53C8;&#x8C03;&#x7528; dogetBean &#x65B9;&#x6CD5;&#x3002; getBean &#x662F;&#x4F9D;&#x8D56;&#x6CE8;&#x5165;&#x7684;&#x8D77;&#x70B9;&#xFF0C;&#x4E4B;&#x540E;&#x8C03;&#x7528; createBean &#x65B9;&#x6CD5;&#xFF0C;&#x521B;&#x5EFA;&#x8FC7;&#x7A0B;&#x53C8;&#x59D4;&#x6258;&#x7ED9;&#x4E86; docreateBean &#x65B9;&#x6CD5;&#x3002;&#x5728; docreateBean &#x4E2D;&#x6709;&#x4E24;&#x4E2A;&#x65B9;&#x6CD5;&#xFF1A;1)createBeanInstance&#xFF0C;&#x751F;&#x6210; Bean &#x5305;&#x542B;&#x7684; java &#x5BF9;&#x8C61; 2)populateBean &#x5B8C;&#x6210;&#x6CE8;&#x5165;&#x3002;&#x5728;&#x521B;&#x5EFA; Bean &#x7684;&#x5B9E;&#x4F8B;&#x4E2D;&#xFF0C;getInstantiationstrategy &#x65B9;&#x6CD5;&#x633A;&#x91CD;&#x8981;&#xFF0C;&#x8BE5;&#x65B9;&#x6CD5;&#x4F5C;&#x7528;&#x662F;&#x83B7;&#x5F97;&#x5B9E;&#x4F8B;&#x5316;&#x7B56;&#x7565;&#x5BF9;&#x8C61;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x6307;&#x901A;&#x8FC7;&#x54EA;&#x79CD;&#x65B9;&#x6848;&#x8FDB;&#x884C;&#x5B9E;&#x4F8B;&#x5316;&#x7684;&#x8FC7;&#x7A0B;&#x3002;spring &#x5F53;&#x4E2D;&#x63D0;&#x4F9B;&#x4E24;&#x79CD;&#x65B9;&#x6848;&#x8FDB;&#x884C;&#x5B9E;&#x4F8B;&#x5316;&#xFF1A;BeanUtils &#x548C; cglib&#x3002;BeanUtils &#x5B9E;&#x73B0;&#x673A;&#x5236;&#x662F; java &#x53CD;&#x5C04;&#xFF0C;cglib &#x662F;&#x4E00;&#x4E2A;&#x7B2C;&#x4E09;&#x65B9;&#x7C7B;&#x5E93;&#xFF0C;&#x91C7;&#x7528;&#x7684;&#x662F;&#x4E00;&#x79CD;&#x5B57;&#x8282;&#x7801;&#x52A0;&#x5F3A;&#x65B9;&#x5F0F;&#x3002;Spring &#x4E2D;&#x9ED8;&#x8BA4;&#x5B9E;&#x4F8B;&#x5316;&#x7B56;&#x7565;&#x4E3A; cglib&#x3002;populateBean &#x8FDB;&#x884C;&#x4F9D;&#x8D56;&#x6CE8;&#x5165;&#xFF0C;&#x83B7;&#x5F97; BeanDefinition &#x4E2D;&#x8BBE;&#x7F6E;&#x7684; property &#x4FE1;&#x606F;&#xFF0C;&#x7B80;&#x5355;&#x7406;&#x89E3;&#x4F9D;&#x8D56;&#x6CE8;&#x5165;&#x7684;&#x8FC7;&#x7A0B;&#x5C31;&#x662F;&#x5BF9;&#x8FD9;&#x4E9B; property &#x8FDB;&#x884C;&#x8D4B;&#x503C;&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x5728;&#x914D;&#x7F6E; Bean &#x7684;&#x5C5E;&#x6027;&#x65F6;&#xFF0C;&#x5C5E;&#x6027;&#x53EF;&#x80FD;&#x6709;&#x591A;&#x79CD;&#x7C7B;&#x578B;&#xFF0C;&#x6211;&#x4EEC;&#x5728;&#x8FDB;&#x884C;&#x6CE8;&#x5165;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x4E0D;&#x540C;&#x7C7B;&#x578B;&#x7684;&#x5C5E;&#x6027;&#x6211;&#x4EEC;&#x4E0D;&#x80FD;&#x4E00;&#x6982;&#x800C;&#x8BBA;&#x5730;&#x8FDB;&#x884C;&#x5904;&#x7406;&#x3002;&#x96C6;&#x5408;&#x7C7B;&#x578B;&#x5C5E;&#x6027;&#x548C;&#x975E;&#x96C6;&#x5408;&#x7C7B;&#x578B;&#x5C5E;&#x6027;&#x5DEE;&#x522B;&#x5F88;&#x5927;&#xFF0C;&#x5BF9;&#x4E0D;&#x540C;&#x7684;&#x7C7B;&#x578B;&#x5E94;&#x8BE5;&#x6709;&#x4E0D;&#x540C;&#x7684;&#x5904;&#x7406;&#x8FC7;&#x7A0B;&#x3002;&#x6240;&#x4EE5;&#x8981;&#x5148;&#x5224;&#x65AD; value &#x7C7B;&#x578B;&#xFF0C;&#x518D;&#x8C03;&#x7528;&#x5177;&#x4F53;&#x65B9;&#x6CD5;&#x3002; </li>
<li>3)    aop&#x2014;&#x2014;&#x5C06;&#x90A3;&#x4E9B;&#x4E0E;&#x4E1A;&#x52A1;&#x65E0;&#x5173;&#xFF0C;&#x5374;&#x4E3A;&#x4E1A;&#x52A1;&#x6A21;&#x5757;&#x6240;&#x516C;&#x5171;&#x8C03;&#x7528;&#x7684;&#x903B;&#x8F91;&#x6216;&#x8D23;&#x4EFB;&#x5C01;&#x88C5;&#x8D77;&#x6765;&#xFF0C;&#x79F0;&#x5176;&#x4E3A; aspect&#xFF0C;&#x4FBF;&#x4E8E;&#x51CF;&#x5C11;&#x7CFB;&#x7EDF;&#x7684;&#x91CD;&#x590D;&#x4EE3;&#x7801;&#x3002;&#x4F7F;&#x7528;&#x6A21;&#x5757;&#x6280;&#x672F;&#xFF0C;aop &#x628A;&#x8F6F;&#x4EF6;&#x7CFB;&#x7EDF;&#x5206;&#x4E3A;&#x4E24;&#x4E2A;&#x90E8;&#x5206;&#xFF1A;&#x6838;&#x5FC3;&#x5173;&#x6CE8;&#x70B9;&#x548C;&#x6A2A;&#x5207;&#x5173;&#x6CE8;&#x70B9;&#x3002;&#x4E1A;&#x52A1;&#x5904;&#x7406;&#x7684;&#x4E3B;&#x8981;&#x6D41;&#x7A0B;&#x662F;&#x6838;&#x5FC3;&#x5173;&#x6CE8;&#x70B9;&#xFF0C;&#x4E0E;&#x4E4B;&#x5173;&#x7CFB;&#x4E0D;&#x5927;&#x7684;&#x90E8;&#x5206;&#x662F;&#x6A2A;&#x5207;&#x5173;&#x6CE8;&#x70B9;&#x3002;&#x5B9E;&#x73B0; aop &#x7684;&#x4E24;&#x5927;&#x6280;&#x672F;&#xFF1A;1)&#x91C7;&#x7528;&#x52A8;&#x6001;&#x4EE3;&#x7406;&#xFF0C;&#x5229;&#x7528;&#x622A;&#x53D6;&#x6D88;&#x606F;&#x7684;&#x65B9;&#x5F0F;&#xFF0C;&#x5BF9;&#x8BE5;&#x6D88;&#x606F;&#x8FDB;&#x884C;&#x88C5;&#x9970;&#xFF0C;&#x4EE5;&#x83B7;&#x53D6;&#x539F;&#x6709;&#x5BF9;&#x8C61;&#x884C;&#x4E3A;&#x7684;&#x6267;&#x884C;&#x3002;2)&#x91C7;&#x7528;&#x9759;&#x6001;&#x7EC7;&#x5165;&#xFF0C;&#x5F15;&#x5165;&#x7279;&#x5B9A;&#x7684;&#x8BED;&#x6CD5;&#x521B;&#x5EFA;&#x5207;&#x9762;&#xFF0C;&#x4ECE;&#x800C;&#x53EF;&#x4EE5;&#x4F7F;&#x7F16;&#x8BD1;&#x5668;&#x53EF;&#x5728;&#x7F16;&#x8BD1;&#x671F;&#x95F4;&#x7EC7;&#x5165;&#x6709;&#x5173;&#x5207;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x3002; </li>
</ul>
</li>
<li>spring &#x63D0;&#x4F9B;&#x4E24;&#x79CD;&#x65B9;&#x5F0F;&#x751F;&#x6210;&#x4EE3;&#x7406;&#x5BF9;&#x8C61;&#xFF0C;jdkProxy &#x548C; cglib&#x3002;&#x9ED8;&#x8BA4;&#x7684;&#x7B56;&#x7565;&#x662F;&#xFF0C;&#x82E5;&#x76EE;&#x6807;&#x7C7B;&#x662F;&#x63A5;&#x53E3;&#x5219;&#x7528; jdk &#x52A8;&#x6001;&#x4EE3;&#x7406;&#x6280;&#x672F;&#xFF0C;&#x5426;&#x5219;&#x4F7F;&#x7528; cglib &#x751F;&#x6210;&#x4EE3;&#x7406;&#x3002;&#x5728; jdk &#x52A8;&#x6001;&#x4EE3;&#x7406;&#x4E2D;&#x4F7F;&#x7528; Proxy.newProxyInstance()&#x751F;&#x6210;&#x4EE3;&#x7406;&#x5BF9;&#x8C61;&#xFF08; JdkDynamicAopProxy &#x7C7B;&#x7684; getProxy &#x65B9;&#x6CD5;)&#xFF0C; JdkDynamicAopProxy &#x4E5F;&#x5B9E;&#x73B0;&#x4E86; invocationhandler &#x63A5;&#x53E3;&#xFF0C;&#x6709; invoke &#x65B9;&#x6CD5;&#xFF0C;&#x5C31;&#x662F;&#x5728;&#x8BE5;&#x65B9;&#x6CD5;&#x4E2D;&#x5B9E;&#x73B0;&#x4E86;&#x5207;&#x7247;&#x7EC7;&#x5165;&#x3002;&#x4E3B;&#x6D41;&#x7A0B;&#x53EF;&#x4EE5;&#x7B80;&#x8FF0;&#x4E3A;&#xFF1A;&#x83B7;&#x53D6;&#x53EF;&#x5E94;&#x7528;&#x5230;&#x6B64;&#x65B9;&#x6CD5;&#x4E0A;&#x7684;&#x901A;&#x77E5;&#x94FE;&#xFF08;Interceptor chain)&#xFF0C;&#x82E5;&#x6709;&#xFF0C;&#x5219;&#x5E94;&#x7528;&#x901A;&#x77E5;&#xFF0C;&#x5E76;&#x6267;&#x884C; joinpoint&#xFF0C;&#x82E5;&#x6CA1;&#x6709;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x53CD;&#x5C04;&#x6267;&#x884C; joinpoint&#x3002; </li>
<li>Introduction &#x662F;&#x6307;&#x7ED9;&#x4E00;&#x4E2A;&#x5DF2;&#x6709;&#x7C7B;&#x6DFB;&#x52A0;&#x65B9;&#x6CD5;&#x6216;&#x5B57;&#x6BB5;&#x5C5E;&#x6027;&#xFF0C;Introduction &#x8FD8;&#x53EF;&#x4EE5;&#x5728;&#x4E0D;&#x6539;&#x53D8;&#x73B0;&#x6709;&#x7C7B;&#x4EE3;&#x7801;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x8BA9;&#x73B0;&#x6709; java &#x7C7B;&#x5B9E;&#x73B0;&#x65B0;&#x7684;&#x63A5;&#x53E3;&#xFF0C;&#x6216;&#x4E3A;&#x5176;&#x6307;&#x5B9A;&#x4E00;&#x4E2A;&#x7236;&#x7C7B;&#x5B9E;&#x73B0;&#x591A;&#x7EE7;&#x627F;&#xFF0C;&#x76F8;&#x5BF9;&#x4E8E; advice &#x53EF;&#x4EE5;&#x52A8;&#x6001;&#x6539;&#x53D8;&#x7A0B;&#x5E8F;&#x7684;&#x529F;&#x80FD;&#x6216;&#x6D41;&#x7A0B;&#x6765;&#x8BF4;&#xFF0C;Introduction &#x7528;&#x6765;&#x6539;&#x53D8;&#x7C7B;&#x7684;&#x9759;&#x6001;&#x7ED3;&#x6784;&#x3002; </li>
<li>&#x62E6;&#x622A;&#x5668;&#xFF0C;&#x662F;&#x5BF9;&#x8FDE;&#x63A5;&#x70B9;&#x8FDB;&#x884C;&#x62E6;&#x622A;&#xFF0C;&#x4ECE;&#x800C;&#x5728;&#x8FDE;&#x63A5;&#x70B9;&#x524D;&#x540E;&#x52A0;&#x5165;&#x81EA;&#x5B9A;&#x4E49;&#x7684;&#x5207;&#x9762;&#x6A21;&#x5757;&#x529F;&#x80FD;&#x3002;&#x4F5C;&#x7528;&#x4E8E;&#x540C;&#x4E00;&#x4E2A;&#x8FDE;&#x63A5;&#x70B9;&#x7684;&#x591A;&#x4E2A;&#x62E6;&#x622A;&#x5668;&#x7EC4;&#x6210;&#x4E00;&#x4E2A;&#x62E6;&#x622A;&#x5668;&#x94FE;&#xFF0C;&#x62E6;&#x622A;&#x5668;&#x94FE;&#x4E0A;&#x7684;&#x6BCF;&#x4E00;&#x4E2A;&#x62E6;&#x622A;&#x5668;&#xFF0C;&#x901A;&#x5E38;&#x4F1A;&#x8C03;&#x7528;&#x4E0B;&#x4E00;&#x4E2A;&#x62E6;&#x622A;&#x5668;&#x3002; </li>
<li>&#x8FDE;&#x63A5;&#x70B9;&#xFF0C;&#x7A0B;&#x5E8F;&#x6267;&#x884C;&#x8FC7;&#x7A0B;&#x4E2D;&#x7684;&#x884C;&#x4E3A;&#xFF0C;&#x6BD4;&#x5982;&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x6216;&#x7279;&#x5B9A;&#x5F02;&#x5E38;&#x88AB;&#x629B;&#x51FA;&#x3002; </li>
<li>&#x5207;&#x5165;&#x70B9;&#xFF0C;&#x6307;&#x5B9A;&#x4E00;&#x4E2A; advice &#x5C06;&#x88AB;&#x5F15;&#x53D1;&#x7684;&#x4E00;&#x7CFB;&#x5217;&#x7684;&#x8FDE;&#x63A5;&#x70B9;&#x7684;&#x96C6;&#x5408;&#x3002;aop &#x6846;&#x67B6;&#x5FC5;&#x987B;&#x5141;&#x8BB8;&#x5F00;&#x53D1;&#x8005;&#x6307;&#x5B9A;&#x5207;&#x5165;&#x70B9;&#x3002; </li>
<li>&#x901A;&#x77E5;&#xFF08;advice)&#xFF1A;&#x5728;&#x7279;&#x5B9A;&#x7684;&#x8FDE;&#x63A5;&#x70B9;&#xFF0C;aop &#x6846;&#x67B6;&#x6267;&#x884C;&#x7684;&#x52A8;&#x4F5C;&#x3002;Spring &#x4EE5;&#x62E6;&#x622A;&#x5668;&#x4F5C;&#x901A;&#x77E5;&#x6A21;&#x578B;&#xFF0C;&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x56F4;&#x7ED5;&#x8FDE;&#x63A5;&#x70B9;&#x7684;&#x62E6;&#x622A;&#x5668;&#x94FE;&#x3002; </li>
<li>&#x62E6;&#x622A;&#x5668;&#xFF08;advisor)&#xFF0C;&#x81EA;&#x5DF1;&#x7406;&#x89E3;&#xFF0C;&#x5728; invoke &#x524D;&#x540E;&#x52A0;&#x5165;&#x7684;&#x65B9;&#x6CD5;&#x5C31;&#x662F;&#x901A;&#x77E5;&#x3002;&#x4F7F;&#x7528; spring &#x7684; PointCutadvisor&#xFF0C;&#x53EA;&#x62E6;&#x622A;&#x7279;&#x5B9A;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x4E00;&#x4E2A; advisor &#x5B9A;&#x4E49;&#x8BA2;&#x4E00;&#x4E2A; PointCut &#x548C;&#x4E00;&#x4E2A; advice&#xFF0C;&#x6EE1;&#x8DB3; PointCut&#xFF08;&#x6307;&#x5B9A;&#x54EA;&#x4E9B;&#x65B9;&#x9762;&#x9700;&#x8981;&#x62E6;&#x622A;)&#xFF0C;&#x5219;&#x6267;&#x884C;&#x76F8;&#x5E94;&#x7684; advice&#xFF08;&#x5B9A;&#x4E49;&#x4E86;&#x589E;&#x5F3A;&#x7684;&#x529F;&#x80FD;)&#x3002;</li>
<li>PointCutadvisor &#x6709; &#x4E24; &#x4E2A; &#x5E38; &#x7528; &#x5B9E; &#x73B0; &#x7C7B; &#xFF1A; NameMatchMethodPointCutadvisor &#x548C; regexMethodPointCutadvisor&#x3002;&#x524D;&#x8005;&#x9700;&#x8981;&#x6CE8;&#x5165; mappedname &#x548C; advice &#x5C5E;&#x6027;&#xFF0C;&#x540E;&#x8005;&#x9700;&#x8981;&#x6CE8;&#x5165; pattern &#x548C; advice &#x5C5E;&#x6027;&#x3002;mappedname &#x6307;&#x660E;&#x8981;&#x62E6;&#x622A;&#x7684;&#x65B9;&#x6CD5;&#x540D;&#xFF0C;pattern &#x6309;&#x7167;&#x6B63;&#x5219;&#x8868;&#x8FBE;&#x5F0F;&#x7684;&#x65B9;&#x6CD5;&#x6307;&#x660E;&#x4E86;&#x8981;&#x62E6;&#x622A;&#x7684;&#x65B9;&#x6CD5;&#x540D;&#xFF0C;advice &#x5B9A;&#x4E49;&#x4E00;&#x4E2A;&#x589E;&#x5F3A;&#xFF0C;&#x5373;&#x8981;&#x52A0;&#x5165;&#x7684;&#x64CD;&#x4F5C;&#xFF08;&#x9700;&#x8981;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0; MethodBeforeAdvice&#x3001;MethodafterAdvice&#x3001;throwAdvice&#x3001;Methodinterceptor &#x63A5;&#x53E3;&#x4E4B;&#x4E00;)&#xFF0C;&#x7136;&#x540E;&#x5728; ProxyBeanFactory &#x7684;&#x62E6;&#x622A;&#x5668;&#x4E2D;&#x6CE8;&#x5165;&#x8FD9;&#x4E2A; PointCutadvisor&#x3002;&#x6CE8;&#xFF1A;&#x4E00;&#x4E2A; ProxyFactoryBean &#x53EA;&#x80FD;&#x6307;&#x5B9A;&#x4E00;&#x4E2A;&#x4EE3;&#x7406;&#x76EE;&#x6807;&#x3002; </li>
<li>&#x5728; spring &#x4E2D;&#x914D;&#x7F6E; aop &#x5F88;&#x9EBB;&#x70E6;&#xFF0C;&#x9996;&#x5148;&#x9700;&#x8981;&#x7F16;&#x5199; xxxadvice &#x7C7B;&#xFF08;&#x9700;&#x8981;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0; MethodBeforeAdvice&#x3001;MethodafterAdvice&#x3001;throwAdvice&#x3001;Methodinterceptor &#x63A5;&#x53E3;&#x4E4B;&#x4E00;)&#xFF0C;&#x7136;&#x540E;&#x5728; xml &#x914D;&#x7F6E; advisor&#x3002;&#x8FD8;&#x8981;&#x5728; advisor &#x4E2D;&#x6CE8;&#x5165; advice&#xFF0C;&#x7136;&#x540E;&#x5C06; advisor &#x52A0;&#x5165; ProxyFactoryBean &#x4E2D;&#x3002;&#x800C;&#x5728; spring2.x &#x4EE5;&#x540E;&#x5F15;&#x5165;&#x4E86; aspect &#x6CE8;&#x89E3;&#xFF0C;&#x53EA;&#x9700;&#x8981;&#x5B9A;&#x4E49;&#x4E00;&#x4E2A; aspect &#x7C7B;&#xFF0C;&#x5728; aspect &#x4E2D;&#x58F0;&#x660E; advice &#x7C7B;&#xFF08;&#x53EF;&#x540C;&#x65F6;&#x58F0;&#x660E;&#x591A;&#x4E2A;)&#xFF0C;&#x7136;&#x540E;&#x5728; xml &#x914D;&#x7F6E;&#x8FD9;&#x4E2A; aspect &#x7C7B;&#xFF0C;&#x6700;&#x540E;&#x6DFB;&#x52A0;&#x4E00;&#x884C;<aop: aspect="" j-auto="" proxy="">&#x5C31;&#x53EF;&#x4EE5;&#x641E;&#x5B9A;&#x3002;     </aop:></li>
<li>&#x901A;&#x77E5;&#x7C7B;&#x578B;     &#x63A5;&#x53E3;                           &#x63CF;&#x8FF0; </li>
<li>&#x524D;&#x7F6E;&#x901A;&#x77E5;     MethodBeforeAdvice       &#x5728;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x524D;&#x8C03;&#x7528; </li>
<li>&#x540E;&#x7F6E;&#x901A;&#x77E5;     MethodafterAdvice      &#x5728;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x540E;&#x8C03;&#x7528; </li>
<li>&#x5F02;&#x5E38;&#x901A;&#x77E5;     throwAdvice              &#x5728;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x65F6;&#x8C03;&#x7528; </li>
<li>&#x73AF;&#x7ED5;&#x901A;&#x77E5;     Methodinterceptor    &#x62E6;&#x622A;&#x5BF9;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x8C03;&#x7528; </li>
<li><p>&#x8FD8;&#x6709;&#x4E00;&#x7C7B;&#x662F;&#x5F15;&#x5165;&#x901A;&#x77E5;&#xFF0C;&#x7528;&#x6765;&#x5B9A;&#x4E49;&#x5207;&#x5165;&#x70B9;&#x7684;&#x3002; </p>
</li>
<li></li>
<li><p>Spring IOC</p>
</li>
<li>IOC=ConfigReader+ReflectionUtil</li>
<li>&#x5BB9;&#x5668;&#x7EE7;&#x627F;&#x4F53;&#x7CFB;</li>
</ul>
<ul>
<li><p>1&#x3001;&#x4ECE;&#x63A5;&#x53E3;BeanFactory&#x5230;HierarchicalBeanFactory&#xFF0C;&#x518D;&#x5230;ConfigurableBeanFactory,&#x8FD9;&#x662F;&#x4E00;&#x6761;&#x4E3B;&#x8981;&#x7684;BeanFactory&#x8BBE;&#x8BA1;&#x8DEF;&#x5F84;&#x3002;&#x5728;&#x8FD9;&#x6761;&#x63A5;&#x53E3;&#x8BBE;&#x8BA1;&#x8DEF;&#x5F84;&#x4E2D;&#xFF0C;BeanFactory&#xFF0C;&#x662F;&#x4E00;&#x6761;&#x4E3B;&#x8981;&#x7684;BeanFactory&#x8BBE;&#x8BA1;&#x8DEF;&#x5F84;&#x3002;&#x5728;&#x8FD9;&#x6761;&#x63A5;&#x53E3;&#x8BBE;&#x8BA1;&#x8DEF;&#x5F84;&#x4E2D;&#xFF0C;BeanFactory&#x63A5;&#x53E3;&#x5B9A;&#x4E49;&#x4E86;&#x57FA;&#x672C;&#x7684;Ioc&#x5BB9;&#x5668;&#x7684;&#x89C4;&#x8303;&#x3002;&#x5728;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x5B9A;&#x4E49;&#x4E2D;&#xFF0C;&#x5305;&#x62EC;&#x4E86;getBean()&#x8FD9;&#x6837;&#x7684;Ioc&#x5BB9;&#x5668;&#x7684;&#x57FA;&#x672C;&#x65B9;&#x6CD5;&#xFF08;&#x901A;&#x8FC7;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x4ECE;&#x5BB9;&#x5668;&#x4E2D;&#x53D6;&#x5F97;Bean)&#x3002;&#x800C;HierarchicalBeanFactory&#x63A5;&#x53E3;&#x5728;&#x7EE7;&#x627F;&#x4E86;BeanFactory&#x7684;&#x57FA;&#x672C;&#x63A5;&#x53E3;&#x540E;&#xFF0C;&#x589E;&#x52A0;&#x4E86;getParentBeanFactory()&#x7684;&#x63A5;&#x53E3;&#x529F;&#x80FD;&#xFF0C;&#x4F7F;BeanFactory&#x5177;&#x5907;&#x4E86;&#x53CC;&#x4EB2;Ioc&#x5BB9;&#x5668;&#x7684;&#x7BA1;&#x7406;&#x529F;&#x80FD;&#x3002;&#x5728;&#x63A5;&#x4E0B;&#x6765;&#x7684;ConfigurableBeanFactory&#x63A5;&#x53E3;&#x4E2D;&#xFF0C;&#x4E3B;&#x8981;&#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E9B;&#x5BF9;BeanFactory&#x7684;&#x914D;&#x7F6E;&#x529F;&#x80FD;&#xFF0C;&#x6BD4;&#x5982;&#x901A;&#x8FC7;setParentBeanFactory()&#x8BBE;&#x7F6E;&#x53CC;&#x4EB2;Ioc&#x5BB9;&#x5668;&#xFF0C;&#x901A;&#x8FC7;addBeanPostProcessor()&#x914D;&#x7F6E;Bean&#x540E;&#x7F6E;&#x5904;&#x7406;&#x5668;&#xFF0C;&#x7B49;&#x7B49;&#x3002;&#x901A;&#x8FC7;&#x8FD9;&#x4E9B;&#x63A5;&#x53E3;&#x8BBE;&#x8BA1;&#x7684;&#x53E0;&#x52A0;&#xFF0C;&#x5B9A;&#x4E49;&#x4E86;BeanFactory&#x5C31;&#x662F;&#x6700;&#x7B80;&#x5355;&#x7684;Ioc&#x5BB9;&#x5668;&#x7684;&#x57FA;&#x672C;&#x529F;&#x80FD;&#x3002;</p>
</li>
<li><p>2&#x3001;&#x7B2C;&#x4E8C;&#x6761;&#x63A5;&#x53E3;&#x8BBE;&#x8BA1;&#x4E3B;&#x7EBF;&#x662F;&#xFF0C;&#x4EE5;ApplicationContext&#x4F5C;&#x4E3A;&#x6838;&#x5FC3;&#x7684;&#x63A5;&#x53E3;&#x8BBE;&#x8BA1;&#xFF0C;&#x8FD9;&#x91CC;&#x6D89;&#x53CA;&#x7684;&#x4E3B;&#x8981;&#x63A5;&#x53E3;&#x8BBE;&#x8BA1;&#x6709;&#xFF0C;&#x4ECE;BeanFactory&#x5230;ListableBeanFactory&#xFF0C;&#x518D;&#x5230;ApplicationContext&#xFF0C;&#x518D;&#x5230;&#x6211;&#x4EEC;&#x5E38;&#x7528;&#x7684;WebApplicationContext&#x6216;&#x8005;ConfigurableApplicationContext&#x63A5;&#x53E3;&#x3002;&#x6211;&#x4EEC;&#x5E38;&#x7528;&#x7684;&#x5E94;&#x7528;&#x57FA;&#x672C;&#x90FD;&#x662F;org.framework.context &#x5305;&#x91CC;&#x7684;WebApplicationContext&#x6216;&#x8005;ConfigurableApplicationContext&#x5B9E;&#x73B0;&#x3002;&#x5728;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x4F53;&#x7CFB;&#x4E2D;&#xFF0C;ListableBeanFactory&#x548C;HierarchicalBeanFactory&#x4E24;&#x4E2A;&#x63A5;&#x53E3;&#xFF0C;&#x8FDE;&#x63A5;BeanFactory&#x63A5;&#x53E3;&#x5B9A;&#x4E49;&#x548C;ApplicationContext&#x5E94;&#x7528;&#x7684;&#x63A5;&#x53E3;&#x5B9A;&#x4E49;&#x3002;&#x5728;ListableBeanFactory&#x63A5;&#x53E3;&#x4E2D;&#xFF0C;&#x7EC6;&#x5316;&#x4E86;&#x8BB8;&#x591A;BeanFactory&#x7684;&#x63A5;&#x53E3;&#x529F;&#x80FD;&#xFF0C;&#x6BD4;&#x5982;&#x5B9A;&#x4E49;&#x4E86;getBeanDefinitionNames()&#x63A5;&#x53E3;&#x65B9;&#x6CD5;&#xFF1B;&#x5BF9;&#x4E8E;ApplicationContext&#x63A5;&#x53E3;&#xFF0C;&#x5B83;&#x901A;&#x8FC7;&#x7EE7;&#x627F;MessageSource&#x3001;ResourceLoader&#x3001;ApplicationEventPublisher&#x63A5;&#x53E3;&#xFF0C;&#x5728;BeanFactory&#x7B80;&#x5355;Ioc&#x5BB9;&#x5668;&#x7684;&#x57FA;&#x7840;&#x4E0A;&#x6DFB;&#x52A0;&#x4E86;&#x8BB8;&#x591A;&#x5BF9;&#x9AD8;&#x7EA7;&#x5BB9;&#x5668;&#x7684;&#x7279;&#x6027;&#x652F;&#x6301;&#x3002;</p>
</li>
<li><p>3&#x3001;.&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x7CFB;&#x7EDF;&#x662F;&#x4EE5;BeanFactory&#x548C;ApplicationContext&#x4E3A;&#x6838;&#x5FC3;&#x8BBE;&#x8BA1;&#x7684;&#xFF0C;&#x800C;BeanFactory&#x662F;Ioc&#x5BB9;&#x5668;&#x4E2D;&#x6700;&#x57FA;&#x672C;&#x7684;&#x63A5;&#x53E3;&#xFF0C;&#x5728;ApplicationContext&#x7684;&#x8BBE;&#x8BA1;&#x4E2D;&#xFF0C;&#x4E00;&#x65B9;&#x9762;&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x5B83;&#x7EE7;&#x627F;&#x4E86;BeanFactory&#x63A5;&#x53E3;&#x4F53;&#x7CFB;&#x4E2D;&#x7684;ListableBeanFactory&#x3001;AutowireCapableBeanFactory&#x3001;HierarchicalBeanFactory&#x7B49;BeanFactory&#x7684;&#x63A5;&#x53E3;&#xFF0C;&#x5177;&#x5907;&#x4E86;BeanFactory Ioc&#x5BB9;&#x5668;&#x7684;&#x57FA;&#x672C;&#x529F;&#x80FD;&#xFF1B;&#x53E6;&#x4E00;&#x65B9;&#x9762;&#xFF0C;&#x901A;&#x8FC7;&#x7EE7;&#x627F;MessageSource&#x3001;ResourceLoader&#x3001;ApplicationEventPublisher&#x8FD9;&#x4E9B;&#x63A5;&#x53E3;&#xFF0C;BeanFactory&#x4E3A;ApplicationContext&#x8D4B;&#x4E88;&#x4E86;&#x66F4;&#x9AD8;&#x7EA7;&#x7684;Ioc&#x5BB9;&#x5668;&#x7279;&#x6027;&#x3002;&#x5BF9;&#x4E8E;ApplicationContext&#x800C;&#x8A00;&#xFF0C;&#x4E3A;&#x4E86;&#x5728;Web&#x73AF;&#x5883;&#x4E2D;&#x4F7F;&#x7528;&#x5B83;&#xFF0C;&#x8FD8;&#x8BBE;&#x8BA1;&#x4E86;WebApplicationContext&#x63A5;&#x53E3;&#xFF0C;&#x800C;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x901A;&#x8FC7;&#x7EE7;&#x627F;ThemeSource&#x63A5;&#x53E3;&#x6765;&#x6269;&#x5145;&#x529F;&#x80FD;&#x3002;</p>
</li>
<li><p>BeanFactory&#xFF08;&#x5BB9;&#x5668;&#x63A5;&#x53E3;)</p>
</li>
</ul>
<pre><code>public interface BeanFactory {
</code></pre><ul>
<li>//&#x8FD9;&#x91CC;&#x662F;&#x5BF9;FactoryBean&#x7684;&#x8F6C;&#x4E49;&#x5B9A;&#x4E49;&#xFF0C;&#x56E0;&#x4E3A;&#x5982;&#x679C;&#x4F7F;&#x7528;bean&#x7684;&#x540D;&#x5B57;&#x68C0;&#x7D22;FactoryBean&#x5F97;&#x5230;&#x7684;&#x5BF9;&#x8C61;&#x662F;&#x5DE5;&#x5382;&#x751F;&#x6210;&#x7684;&#x5BF9;&#x8C61;</li>
<li>String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</li>
<li>//&#x8FD9;&#x91CC;&#x6839;&#x636E;bean&#x7684;&#x540D;&#x5B57;&#xFF0C;&#x5728;IOC&#x5BB9;&#x5668;&#x4E2D;&#x5F97;&#x5230;bean&#x5B9E;&#x4F8B;&#xFF0C;&#x8FD9;&#x4E2A;IOC&#x5BB9;&#x5668;&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x5927;&#x7684;&#x62BD;&#x8C61;&#x5DE5;&#x5382;&#x3002; </li>
<li>Object getBean(String name) throws BeansException;</li>
<li>//&#x8FD9;&#x91CC;&#x6839;&#x636E;bean&#x7684;&#x540D;&#x5B57;&#x548C;Class&#x7C7B;&#x578B;&#x6765;&#x5F97;&#x5230;bean&#x5B9E;&#x4F8B;&#xFF0C;&#x548C;&#x4E0A;&#x9762;&#x7684;&#x65B9;&#x6CD5;&#x4E0D;&#x540C;&#x5728;&#x4E8E;&#x5B83;&#x4F1A;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#xFF1A;&#x5982;&#x679C;&#x6839;&#x636E;&#x540D;&#x5B57;&#x53D6;&#x5F97;&#x7684;bean&#x5B9E;&#x4F8B;&#x7684;Class&#x7C7B;&#x578B;&#x548C;&#x9700;&#x8981;&#x7684;&#x4E0D;&#x540C;&#x7684;&#x8BDD;&#x3002;</li>
<li><t> T getBean(String name, Class<t> requiredType);</t></t></li>
<li><t> T getBean(Class<t> requiredType) throws BeansException;</t></t></li>
<li>Object getBean(String name, Object... args) throws BeansException;</li>
<li>//&#x8FD9;&#x91CC;&#x63D0;&#x4F9B;&#x5BF9;bean&#x7684;&#x68C0;&#x7D22;&#xFF0C;&#x770B;&#x770B;&#x662F;&#x5426;&#x5728;IOC&#x5BB9;&#x5668;&#x6709;&#x8FD9;&#x4E2A;&#x540D;&#x5B57;&#x7684;bean</li>
<li>boolean containsBean(String name);</li>
<li>//&#x8FD9;&#x91CC;&#x6839;&#x636E;bean&#x540D;&#x5B57;&#x5F97;&#x5230;bean&#x5B9E;&#x4F8B;&#xFF0C;&#x5E76;&#x540C;&#x65F6;&#x5224;&#x65AD;&#x8FD9;&#x4E2A;bean&#x662F;&#x4E0D;&#x662F;&#x5355;&#x4EF6; </li>
<li>boolean isSingleton(String name) throws NoSuchBeanDefinitionException;</li>
<li>//&#x8FD9;&#x91CC;&#x6839;&#x636E;bean&#x540D;&#x5B57;&#x5F97;&#x5230;bean&#x5B9E;&#x4F8B;&#xFF0C;&#x5E76;&#x540C;&#x65F6;&#x5224;&#x65AD;&#x8FD9;&#x4E2A;bean&#x662F;&#x4E0D;&#x662F;&#x539F;&#x578B; </li>
<li>boolean isPrototype(String name) throws NoSuchBeanDefinitionException;</li>
<li>//&#x8FD9;&#x91CC;&#x5BF9;&#x5F97;&#x5230;bean&#x5B9E;&#x4F8B;&#x7684;Class&#x7C7B;&#x578B;  </li>
<li>Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;</li>
<li>//&#x8FD9;&#x91CC;&#x5F97;&#x5230;bean&#x7684;&#x522B;&#x540D;&#xFF0C;&#x5982;&#x679C;&#x6839;&#x636E;&#x522B;&#x540D;&#x68C0;&#x7D22;&#xFF0C;&#x90A3;&#x4E48;&#x5176;&#x539F;&#x540D;&#x4E5F;&#x4F1A;&#x88AB;&#x68C0;&#x7D22;&#x51FA;&#x6765;  </li>
<li>String[] getAliases(String name);</li>
<li>}</li>
<li>XmlBeanFactory&#xFF08;&#x57FA;&#x7840;&#x5BB9;&#x5668;&#x5B9E;&#x73B0;)</li>
</ul>
<pre><code>public class XmlBeanFactory extends DefaultListableBeanFactory {
   private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);


   /**
    * Create a new XmlBeanFactory with the given resource,
    * which must be parsable using DOM.
    * @param resource XML resource to load bean definitions from
    * @throws BeansException in case of loading or parsing errors
    */
   public XmlBeanFactory(Resource resource) throws BeansException {
      this(resource, null);
   }

   /**
    * Create a new XmlBeanFactory with the given input stream,
    * which must be parsable using DOM.
    * @param resource XML resource to load bean definitions from
    * @param parentBeanFactory parent bean factory
    * @throws BeansException in case of loading or parsing errors
    */
   public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
      super(parentBeanFactory);
      this.reader.loadBeanDefinitions(resource);
   }

}
</code></pre><ul>
<li><p>&#x4F5C;&#x4E3A;&#x7B80;&#x5355;ioc&#x5BB9;&#x5668;&#x7CFB;&#x5217;&#x6700;&#x5E95;&#x5C42;&#x7684;&#x5B9E;&#x73B0;XmlBeanFactory&#x662F;&#x5EFA;&#x7ACB;&#x5728;DefaultListableBeanFactory&#x5BB9;&#x5668;&#x7684;&#x57FA;&#x7840;&#x4E4B;&#x4E0A;&#x7684;&#xFF0C;&#x5E76;&#x5728;&#x8FD9;&#x4E2A;&#x57FA;&#x672C;&#x5BB9;&#x5668;&#x7684;&#x57FA;&#x7840;&#x4E0A;&#x5B9E;&#x73B0;&#x4E86;&#x5176;&#x4ED6;&#x8BF8;&#x5982;xml&#x8BFB;&#x53D6;&#x7684;&#x9644;&#x52A0;&#x529F;&#x80FD;&#x3002;</p>
</li>
<li><p>Resource&#x63A5;&#x53E3;&#x4F53;&#x7CFB;</p>
</li>
<li><p>&#x4EC5;&#x4EC5;&#x4F7F;&#x7528; java &#x6807;&#x51C6; java.net.URL &#x548C;&#x9488;&#x5BF9;&#x4E0D;&#x540C; URL &#x524D;&#x7F00;&#x7684;&#x6807;&#x51C6;&#x5904;&#x7406;&#x5668;&#x5E76;&#x4E0D;&#x80FD;&#x6EE1;&#x8DB3;&#x6211;&#x4EEC;&#x5BF9;&#x5404;&#x79CD;&#x5E95;&#x5C42;&#x8D44;&#x6E90;&#x7684;&#x8BBF;&#x95EE;&#xFF0C;&#x6BD4;&#x5982;&#xFF1A;&#x6211;&#x4EEC;&#x5C31;&#x4E0D;&#x80FD;&#x901A;&#x8FC7; URL &#x7684;&#x6807;&#x51C6;&#x5B9E;&#x73B0;&#x6765;&#x8BBF;&#x95EE;&#x76F8;&#x5BF9;&#x7C7B;&#x8DEF;&#x5F84;&#x6216;&#x8005;&#x76F8;&#x5BF9; ServletContext &#x7684;&#x5404;&#x79CD;&#x8D44;&#x6E90;&#x3002;&#x867D;&#x7136;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x9488;&#x5BF9;&#x7279;&#x5B9A;&#x7684; url &#x524D;&#x7F00;&#x6765;&#x6CE8;&#x518C;&#x4E00;&#x4E2A;&#x65B0;&#x7684; URLStreamHandler&#xFF08;&#x548C;&#x73B0;&#x6709;&#x7684;&#x9488;&#x5BF9;&#x5404;&#x79CD;&#x7279;&#x5B9A;&#x524D;&#x7F00;&#x7684;&#x5904;&#x7406;&#x5668;&#x7C7B;&#x4F3C;&#xFF0C;&#x6BD4;&#x5982; http&#xFF1A;)&#xFF0C;&#x7136;&#x800C;&#x8FD9;&#x5F80;&#x5F80;&#x4F1A;&#x662F;&#x4E00;&#x4EF6;&#x6BD4;&#x8F83;&#x9EBB;&#x70E6;&#x7684;&#x4E8B;&#x60C5;(&#x8981;&#x6C42;&#x4E86;&#x89E3; url &#x7684;&#x5B9E;&#x73B0;&#x673A;&#x5236;&#x7B49;)&#xFF0C;&#x800C;&#x4E14; url &#x63A5;&#x53E3;&#x4E5F;&#x7F3A;&#x5C11;&#x4E86;&#x90E8;&#x5206;&#x57FA;&#x672C;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x5982;&#x68C0;&#x67E5;&#x5F53;&#x524D;&#x8D44;&#x6E90;&#x662F;&#x5426;&#x5B58;&#x5728;&#x7684;&#x65B9;&#x6CD5;&#x3002;</p>
</li>
<li><p>&#x76F8;&#x5BF9;&#x6807;&#x51C6; url &#x8BBF;&#x95EE;&#x673A;&#x5236;&#xFF0C;Spring &#x7684; Resource &#x63A5;&#x53E3;&#x5BF9;&#x62BD;&#x8C61;&#x5E95;&#x5C42;&#x8D44;&#x6E90;&#x7684;&#x8BBF;&#x95EE;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x5957;&#x66F4;&#x597D;&#x7684;&#x673A;&#x5236;&#x3002;</p>
</li>
<li><p>Resource &#x662F; Spring &#x4E2D;&#x5BF9;&#x5916;&#x90E8;&#x8D44;&#x6E90;&#x7684;&#x62BD;&#x8C61;&#xFF0C;&#x6700;&#x5E38;&#x89C1;&#x7684;&#x662F;&#x6587;&#x4EF6;&#x7684;&#x62BD;&#x8C61;&#xFF0C;&#x7279;&#x522B;&#x662F; xml &#x6587;&#x4EF6;&#xFF0C;&#x800C;&#x4E14; Resource &#x91CC;&#x9762;&#x901A;&#x5E38;&#x662F;&#x4FDD;&#x5B58;&#x4E86; Spring &#x4F7F;&#x7528;&#x8005;&#x7684; Bean &#x5B9A;&#x4E49;&#x3002;</p>
</li>
<li><p>&#x5176;&#x5B9E;&#x73B0;&#x7C7B;&#x6709;&#xFF1A;ByteArrayResouece,BeanDefinitionResource,InputStreamResource, ClassPathResource&#x7B49;</p>
</li>
<li><p>ResourceLoader&#x63A5;&#x53E3;&#x7528;&#x4E8E;&#x8FD4;&#x56DE;Resource&#x5BF9;&#x8C61;&#xFF1B;&#x5176;&#x5B9E;&#x73B0;&#x53EF;&#x4EE5;&#x770B;&#x4F5C;&#x662F;&#x4E00;&#x4E2A;&#x751F;&#x4EA7;Resource&#x7684;&#x5DE5;&#x5382;&#x7C7B;&#x3002;Spring&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x4E2A;&#x9002;&#x7528;&#x4E8E;&#x6240;&#x6709;&#x73AF;&#x5883;&#x7684;DefaultResourceLoader&#x5B9E;&#x73B0;&#xFF0C;&#x53EF;&#x4EE5;&#x8FD4;&#x56DE;ClassPathResource&#x3001;UrlResource&#x3002;</p>
</li>
<li><p>ResourceLoader&#x5728;&#x8FDB;&#x884C;&#x52A0;&#x8F7D;&#x8D44;&#x6E90;&#x65F6;&#x9700;&#x8981;&#x4F7F;&#x7528;&#x524D;&#x7F00;&#x6765;&#x6307;&#x5B9A;&#x9700;&#x8981;&#x52A0;&#x8F7D;&#xFF1A;&#x201C;classpath:path&#x201D;&#x8868;&#x793A;&#x8FD4;&#x56DE;ClasspathResource&#xFF0C;&#x201C;<a href="http://path&#x201D;&#x548C;&#x201C;file:path&#x201D;&#x8868;&#x793A;&#x8FD4;&#x56DE;UrlResource&#x8D44;&#x6E90;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x52A0;&#x524D;&#x7F00;&#x5219;&#x9700;&#x8981;&#x6839;&#x636E;&#x5F53;&#x524D;&#x4E0A;&#x4E0B;&#x6587;&#x6765;&#x51B3;&#x5B9A;&#xFF0C;DefaultResourceLoader&#x9ED8;&#x8BA4;&#x5B9E;&#x73B0;&#x53EF;&#x4EE5;&#x52A0;&#x8F7D;classpath&#x8D44;&#x6E90;&#x3002;" target="_blank">http://path&#x201D;&#x548C;&#x201C;file:path&#x201D;&#x8868;&#x793A;&#x8FD4;&#x56DE;UrlResource&#x8D44;&#x6E90;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x52A0;&#x524D;&#x7F00;&#x5219;&#x9700;&#x8981;&#x6839;&#x636E;&#x5F53;&#x524D;&#x4E0A;&#x4E0B;&#x6587;&#x6765;&#x51B3;&#x5B9A;&#xFF0C;DefaultResourceLoader&#x9ED8;&#x8BA4;&#x5B9E;&#x73B0;&#x53EF;&#x4EE5;&#x52A0;&#x8F7D;classpath&#x8D44;&#x6E90;&#x3002;</a></p>
</li>
<li><p>&#x5BF9;&#x4E8E;&#x76EE;&#x524D;&#x6240;&#x6709;ApplicationContext&#x90FD;&#x5B9E;&#x73B0;&#x4E86;ResourceLoader&#xFF0C;&#x56E0;&#x6B64;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x5176;&#x6765;&#x52A0;&#x8F7D;&#x8D44;&#x6E90;&#x3002;</p>
</li>
<li>ClassPathXmlApplicationContext&#xFF1A;&#x4E0D;&#x6307;&#x5B9A;&#x524D;&#x7F00;&#x5C06;&#x8FD4;&#x56DE;&#x9ED8;&#x8BA4;&#x7684;ClassPathResource&#x8D44;&#x6E90;&#xFF0C;&#x5426;&#x5219;&#x5C06;&#x6839;&#x636E;&#x524D;&#x7F00;&#x6765;&#x52A0;&#x8F7D;&#x8D44;&#x6E90;&#xFF1B;</li>
<li>WebApplicationContext&#xFF1A;&#x4E0D;&#x6307;&#x5B9A;&#x524D;&#x7F00;&#x5C06;&#x8FD4;&#x56DE;ServletContextResource&#xFF0C;&#x5426;&#x5219;&#x5C06;&#x6839;&#x636E;&#x524D;&#x7F00;&#x6765;&#x52A0;&#x8F7D;&#x8D44;&#x6E90;&#xFF1B;</li>
<li></li>
<li><p>ApplicationContext&#x63A5;&#x53E3;&#xFF08;&#x9AD8;&#x7EA7;&#x5BB9;&#x5668;&#x63A5;&#x53E3;)</p>
</li>
<li>ApplicationContext&#x662F;spring&#x4E2D;&#x8F83;&#x9AD8;&#x7EA7;&#x7684;&#x5BB9;&#x5668;&#x3002;&#x548C;BeanFactory&#x7C7B;&#x4F3C;&#xFF0C;&#x5B83;&#x53EF;&#x4EE5;&#x52A0;&#x8F7D;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#x5B9A;&#x4E49;&#x7684;bean&#xFF0C;&#x5C06;&#x6240;&#x6709;&#x7684;bean&#x96C6;&#x4E2D;&#x5728;&#x4E00;&#x8D77;&#xFF0C;&#x5F53;&#x6709;&#x8BF7;&#x6C42;&#x7684;&#x65F6;&#x5019;&#x5206;&#x914D;bean&#x3002; &#x53E6;&#x5916;&#xFF0C;&#x5B83;&#x589E;&#x52A0;&#x4E86;&#x4F01;&#x4E1A;&#x6240;&#x9700;&#x8981;&#x7684;&#x529F;&#x80FD;&#xFF0C;&#x6BD4;&#x5982;&#xFF0C;&#x4ECE;&#x5C5E;&#x6027;&#x6587;&#x4EF6;&#x4E2D;&#x89E3;&#x6790;&#x6587;&#x672C;&#x4FE1;&#x606F;&#x548C;&#x5C06;&#x4E8B;&#x4EF6;&#x4F20;&#x9012;&#x7ED9;&#x6240;&#x6307;&#x5B9A;&#x7684;&#x76D1;&#x542C;&#x5668;&#x3002;&#x8FD9;&#x4E2A;&#x5BB9;&#x5668;&#x5728;org.springframework.context.ApplicationContext&#x63A5;&#x53E3;&#x4E2D;&#x5B9A;&#x4E49;&#x3002;ApplicationContext&#x5305;&#x542B;BeanFactory&#x6240;&#x6709;&#x7684;&#x529F;&#x80FD;&#xFF0C;&#x4E00;&#x822C;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x76F8;&#x5BF9;&#x4E8E;BeanFactory&#xFF0C;ApplicationContext&#x4F1A;&#x88AB;&#x63A8;&#x8350;&#x4F7F;&#x7528;&#x3002;</li>
<li>&#x7279;&#x70B9;</li>
<li>1.&#x652F;&#x6301;&#x4E0D;&#x540C;&#x7684;&#x4FE1;&#x606F;&#x6E90;&#x3002;&#x7EE7;&#x627F;&#x4E86;MessageSource&#x63A5;&#x53E3;&#xFF0C;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x4E3A;ApplicationContext&#x63D0;&#x4F9B;&#x4E86;&#x5F88;&#x591A;&#x4FE1;&#x606F;&#x6E90;&#x7684;&#x6269;&#x5C55;&#x529F;&#x80FD;&#xFF0C;&#x6BD4;&#x5982;&#xFF1A;&#x56FD;&#x9645;&#x5316;&#x7684;&#x5B9E;&#x73B0;&#x4E3A;&#x591A;&#x8BED;&#x8A00;&#x7248;&#x672C;&#x7684;&#x5E94;&#x7528;&#x63D0;&#x4F9B;&#x670D;&#x52A1;&#x3002;</li>
<li>2.&#x8BBF;&#x95EE;&#x8D44;&#x6E90;&#x3002;&#x8FD9;&#x4E00;&#x7279;&#x6027;&#x4E3B;&#x8981;&#x4F53;&#x73B0;&#x5728;ResourcePatternResolver&#x63A5;&#x53E3;&#x4E0A;&#xFF0C;&#x5BF9;Resource&#x548C;ResourceLoader&#x7684;&#x652F;&#x6301;&#xFF0C;&#x8FD9;&#x6837;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x4ECE;&#x4E0D;&#x540C;&#x5730;&#x65B9;&#x5F97;&#x5230;Bean&#x5B9A;&#x4E49;&#x8D44;&#x6E90;&#x3002;&#x8FD9;&#x79CD;&#x62BD;&#x8C61;&#x4F7F;&#x7528;&#x6237;&#x7A0B;&#x5E8F;&#x53EF;&#x4EE5;&#x7075;&#x6D3B;&#x5730;&#x5B9A;&#x4E49;Bean&#x5B9A;&#x4E49;&#x4FE1;&#x606F;&#xFF0C;&#x5C24;&#x5176;&#x662F;&#x4ECE;&#x4E0D;&#x540C;&#x7684;IO&#x9014;&#x5F84;&#x5F97;&#x5230;Bean&#x5B9A;&#x4E49;&#x4FE1;&#x606F;&#x3002;&#x8FD9;&#x5728;&#x63A5;&#x53E3;&#x4E0A;&#x770B;&#x4E0D;&#x51FA;&#x6765;&#xFF0C;&#x4E0D;&#x8FC7;&#x4E00;&#x822C;&#x6765;&#x8BF4;&#xFF0C;&#x5177;&#x4F53;ApplicationContext&#x90FD;&#x662F;&#x7EE7;&#x627F;&#x4E86;DefaultResourceLoader&#x7684;&#x5B50;&#x7C7B;&#x3002;&#x56E0;&#x4E3A;DefaultResourceLoader&#x662F;AbstractApplicationContext&#x7684;&#x57FA;&#x7C7B;&#x3002; </li>
<li>3.&#x652F;&#x6301;&#x5E94;&#x7528;&#x4E8B;&#x4EF6;&#x3002;&#x7EE7;&#x627F;&#x4E86;&#x63A5;&#x53E3;ApplicationEventPublisher&#xFF0C;&#x4E3A;&#x5E94;&#x7528;&#x73AF;&#x5883;&#x5F15;&#x5165;&#x4E86;&#x4E8B;&#x4EF6;&#x673A;&#x5236;&#xFF0C;&#x8FD9;&#x4E9B;&#x4E8B;&#x4EF6;&#x548C;Bean&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x7684;&#x7ED3;&#x5408;&#x4E3A;Bean&#x7684;&#x7BA1;&#x7406;&#x63D0;&#x4F9B;&#x4E86;&#x4FBF;&#x5229;&#x3002;</li>
<li>4.&#x9644;&#x4EF6;&#x670D;&#x52A1;&#x3002;EnvironmentCapable&#x91CC;&#x7684;&#x670D;&#x52A1;&#x8BA9;&#x57FA;&#x672C;&#x7684;Ioc&#x529F;&#x80FD;&#x66F4;&#x52A0;&#x4E30;&#x5BCC;&#x3002;</li>
<li>5.ListableBeanFactory&#x548C;HierarchicalBeanFactory&#x662F;&#x7EE7;&#x627F;&#x7684;&#x4E3B;&#x8981;&#x5BB9;&#x5668;&#x3002;</li>
<li>&#x5B9E;&#x73B0;</li>
<li>&#x6700;&#x5E38;&#x88AB;&#x4F7F;&#x7528;&#x7684;ApplicationContext&#x63A5;&#x53E3;&#x5B9E;&#x73B0;&#x7C7B;&#xFF1A;</li>
<li>1&#xFF0C;FileSystemXmlApplicationContext&#xFF1A;&#x8BE5;&#x5BB9;&#x5668;&#x4ECE;XML&#x6587;&#x4EF6;&#x4E2D;&#x52A0;&#x8F7D;&#x5DF2;&#x88AB;&#x5B9A;&#x4E49;&#x7684;bean&#x3002;&#x5728;&#x8FD9;&#x91CC;&#xFF0C;&#x4F60;&#x9700;&#x8981;&#x63D0;&#x4F9B;&#x7ED9;&#x6784;&#x9020;&#x5668;XML&#x6587;&#x4EF6;&#x7684;&#x5B8C;&#x6574;&#x8DEF;&#x5F84;&#x3002;</li>
<li>2&#xFF0C;ClassPathXmlApplicationContext&#xFF1A;&#x8BE5;&#x5BB9;&#x5668;&#x4ECE;XML&#x6587;&#x4EF6;&#x4E2D;&#x52A0;&#x8F7D;&#x5DF2;&#x88AB;&#x5B9A;&#x4E49;&#x7684;bean&#x3002;&#x5728;&#x8FD9;&#x91CC;&#xFF0C;&#x4F60;&#x4E0D;&#x9700;&#x8981;&#x63D0;&#x4F9B;XML&#x6587;&#x4EF6;&#x7684;&#x5B8C;&#x6574;&#x8DEF;&#x5F84;&#xFF0C;&#x53EA;&#x9700;&#x6B63;&#x786E;&#x914D;&#x7F6E;CLASSPATH&#x73AF;&#x5883;&#x53D8;&#x91CF;&#x5373;&#x53EF;&#xFF0C;&#x56E0;&#x4E3A;&#xFF0C;&#x5BB9;&#x5668;&#x4F1A;&#x4ECE;CLASSPATH&#x4E2D;&#x641C;&#x7D22;bean&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x3002;</li>
<li>3&#xFF0C;WebXmlApplicationContext&#xFF1A;&#x8BE5;&#x5BB9;&#x5668;&#x4F1A;&#x5728;&#x4E00;&#x4E2A; web &#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x7684;&#x8303;&#x56F4;&#x5185;&#x52A0;&#x8F7D;&#x5728;XML&#x6587;&#x4EF6;&#x4E2D;</li>
<li>ClassPathXmlApplicationContext&#xFF08;&#x9AD8;&#x7EA7;&#x5BB9;&#x5668;&#x5B9E;&#x73B0;)</li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<pre><code>public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)
      throws BeansException {

   super(parent);
   setConfigLocations(configLocations);
   if (refresh) {
      refresh();
   }
}
</code></pre><ul>
<li><p>Bean&#x7684;&#x6CE8;&#x518C;</p>
</li>
<li><p>AbstractApplicationContext#refresh&#xFF08;bean&#x6CE8;&#x518C;)</p>
</li>
<li><p>refresh&#x662F;AbstractApplicationContext&#x4E2D;&#x65B9;&#x6CD5;&#x3002;</p>
</li>
<li><p>&#x903B;&#x8F91;&#xFF1A;</p>
<ul>
<li>1)&#x521D;&#x59CB;&#x5316;&#x524D;&#x7684;&#x51C6;&#x5907;&#x5DE5;&#x4F5C;&#xFF0C;&#x6BD4;&#x5982;&#x5BF9;&#x7CFB;&#x7EDF;&#x5C5E;&#x6027;&#x6216;&#x8005;&#x73AF;&#x5883;&#x53D8;&#x91CF;&#x8FDB;&#x884C;&#x51C6;&#x5907;&#x53CA;&#x9A8C;&#x8BC1;</li>
<li>2)&#x521D;&#x59CB;&#x5316;BeanFactory&#xFF0C;&#x5E76;&#x8FDB;&#x884C;XML&#x6587;&#x4EF6;&#x8BFB;&#x53D6;&#xFF08;component-scan-&gt;&#x5305;&#x62EC;class&#x6587;&#x4EF6;)</li>
<li>3)&#x5BF9;BeanFactory&#x8FDB;&#x884C;&#x5404;&#x79CD;&#x529F;&#x80FD;&#x586B;&#x5145;&#xFF0C;&#x6BD4;&#x5982;@Qualifier&#x548C;@Autowired</li>
<li>4)&#x5B50;&#x7C7B;&#x8986;&#x76D6;&#x65B9;&#x6CD5;&#x505A;&#x989D;&#x5916;&#x7684;&#x5904;&#x7406;</li>
<li>5)&#x6FC0;&#x6D3B;&#x5404;&#x79CD;BeanFactory&#x5904;&#x7406;&#x5668;</li>
<li>6)&#x6CE8;&#x518C;&#x62E6;&#x622A;bean&#x521B;&#x5EFA;&#x7684;bean&#x5904;&#x7406;&#x5668;&#xFF0C;&#x8FD9;&#x91CC;&#x53EA;&#x662F;&#x6CE8;&#x518C;&#xFF0C;&#x771F;&#x6B63;&#x7684;&#x8C03;&#x7528;&#x662F;&#x5728;getBean&#x7684;&#x65F6;&#x5019;</li>
<li>7)&#x4E3A;&#x4E0A;&#x4E0B;&#x6587;&#x521D;&#x59CB;&#x5316;Message&#x6E90;&#xFF0C;&#x5373;&#x4E3A;&#x4E0D;&#x540C;&#x8BED;&#x8A00;&#x7684;&#x6D88;&#x606F;&#x4F53;&#x8FDB;&#x884C;&#x56FD;&#x9645;&#x5316;&#x5904;&#x7406;</li>
<li>8)&#x521D;&#x59CB;&#x5316;&#x5E94;&#x7528;&#x6D88;&#x606F;&#x5E7F;&#x64AD;&#x5668;&#xFF0C;&#x5E76;&#x653E;&#x5165;applicationEventMulticaster bean&#x4E2D;</li>
<li>9)&#x7559;&#x7ED9;&#x5B50;&#x7C7B;&#x6765;&#x521D;&#x59CB;&#x5316;&#x5176;&#x4ED6;&#x7684;bean</li>
</ul>
</li>
<li>10)&#x5728;&#x6240;&#x6709;&#x6CE8;&#x518C;&#x7684;bean&#x4E2D;&#x67E5;&#x627E;listener bean&#xFF0C;&#x6CE8;&#x518C;&#x5230;&#x6D88;&#x606F;&#x5E7F;&#x64AD;&#x5668;&#x4E2D;<ul>
<li>11)&#x521D;&#x59CB;&#x5316;&#x5269;&#x4E0B;&#x7684;&#x4EE3;&#x7406;&#x5B9E;&#x4F8B;&#xFF08;&#x975E;lazy-init)</li>
<li>12)&#x5B8C;&#x6210;&#x5237;&#x65B0;&#x8FC7;&#x7A0B;&#xFF0C;&#x901A;&#x77E5;&#x751F;&#x547D;&#x5468;&#x671F;&#x5904;&#x7406;&#x5668;lifecycleProcessor&#x5237;&#x65B0;&#x8FC7;&#x7A0B;&#xFF0C;&#x540C;&#x65F6;&#x53D1;&#x51FA;ContextRefreshEvent&#x901A;&#x77E5;&#x522B;&#x4EBA;&#x3002;</li>
</ul>
</li>
</ul>
<pre><code>public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // &#x51C6;&#x5907; &#x5237;&#x65B0;&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x73AF;&#x5883;
      prepareRefresh();

      // &#x521D;&#x59CB;&#x5316;BeanFactory&#xFF0C;&#x5E76;&#x8FDB;&#x884C;XML&#x6587;&#x4EF6;&#x7684;&#x8BFB;&#x53D6;
</code></pre><ul>
<li><p>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</p>
<p>// &#x5BF9;BeanFactory&#x8FDB;&#x884C;&#x5404;&#x79CD;&#x529F;&#x80FD;&#x586B;&#x5145;</p>
</li>
<li><p>prepareBeanFactory(beanFactory);</p>
<p>try {
 // &#x5B50;&#x7C7B;&#x8986;&#x76D6;&#x65B9;&#x6CD5;&#x505A;&#x989D;&#x5916;&#x7684;&#x5904;&#x7406;
 postProcessBeanFactory(beanFactory);</p>
<p> // &#x6FC0;&#x6D3B;&#x5404;&#x79CD;BeanFactory&#x5904;&#x7406;&#x5668;
 invokeBeanFactoryPostProcessors(beanFactory);</p>
<p> // &#x6CE8;&#x518C;&#x62E6;&#x622A;Bean&#x521B;&#x5EFA;&#x7684;Bean&#x5904;&#x7406;&#x5668;&#xFF0C;&#x8FD9;&#x91CC;&#x53EA;&#x662F;&#x6CE8;&#x518C;&#xFF0C;&#x771F;&#x6B63;&#x7684;&#x8C03;&#x7528;&#x662F;&#x5728;getBean&#x7684;&#x65F6;&#x5019;
 registerBeanPostProcessors(beanFactory);</p>
<p> // &#x4E3A;&#x4E0A;&#x4E0B;&#x6587;&#x521D;&#x59CB;&#x5316;Message&#x6E90;&#xFF0C;&#x5373;&#x4E0D;&#x540C;&#x8BED;&#x8A00;&#x7684;&#x6D88;&#x606F;&#x4F53;&#xFF0C;&#x56FD;&#x9645;&#x5316;&#x5904;&#x7406;
 initMessageSource();</p>
<p> // &#x521D;&#x59CB;&#x5316;&#x5E94;&#x7528;&#x6D88;&#x606F;&#x5E7F;&#x64AD;&#x5668;&#xFF0C;&#x5E76;&#x653E;&#x5165;applicationEventMulticaster bean&#x4E2D;
 initApplicationEventMulticaster();</p>
<p> // &#x7559;&#x7ED9;&#x5B50;&#x7C7B;&#x6765;&#x521D;&#x59CB;&#x5316;&#x5176;&#x4ED6;bean
 onRefresh();</p>
<p> // &#x5728;&#x6240;&#x6709;&#x6CE8;&#x518C;&#x7684;bean&#x4E2D;&#x67E5;&#x627E;Listener bean&#xFF0C;&#x6CE8;&#x518C;&#x5230;&#x6D88;&#x606F;&#x5E7F;&#x64AD;&#x5668;&#x4E2D;
 registerListeners();</p>
<p> // &#x521D;&#x59CB;&#x5316;&#x5269;&#x4E0B;&#x7684;&#x5355;&#x4F8B;&#x5B9E;&#x4F8B;&#xFF08;&#x9664;&#x4E86;lazy-init)
 finishBeanFactoryInitialization(beanFactory);</p>
<p> // &#x5B8C;&#x6210;&#x5237;&#x65B0;&#x8FC7;&#x7A0B;&#xFF0C;&#x901A;&#x77E5;&#x751F;&#x547D;&#x5468;&#x671F;&#x5904;&#x7406;&#x5668;lifecycleProcessor&#x5237;&#x65B0;&#x8FC7;&#x7A0B;&#xFF0C;&#x540C;&#x65F6;&#x53D1;&#x51FA;ContextRefreshEvent&#x901A;&#x77E5;&#x522B;&#x4EBA;
 finishRefresh();
}</p>
<p>catch (BeansException ex) {
 if (logger.isWarnEnabled()) {</p>
<pre><code>logger.warn(&quot;Exception encountered during context initialization - &quot; +
      &quot;cancelling refresh attempt: &quot; + ex);
</code></pre><p> }</p>
<p> // Destroy already created singletons to avoid dangling resources.
 destroyBeans();</p>
<p> // Reset &apos;active&apos; flag.
 cancelRefresh(ex);</p>
<p> // Propagate exception to caller.
 throw ex;
}</p>
<p>finally {
 // Reset common introspection caches in Spring&apos;s core, since we
 // might not ever need metadata for singleton beans anymore...
 resetCommonCaches();
}
}
}</p>
<ul>
<li>1) obtainFreshBeanFactory&#xFF08;&#x521B;&#x5EFA;beanFactory&#xFF0C;&#x89E3;&#x6790;XML)</li>
</ul>
</li>
<li>&#x770B;obtainFreshBeanFactory&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#xFF1A;</li>
<li>protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
 refreshBeanFactory();
 ConfigurableListableBeanFactory beanFactory = getBeanFactory();
 if (logger.isDebugEnabled()) {<pre><code>logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
</code></pre> }
 return beanFactory;
}<ul>
<li>1.1) refreshBeanFactory</li>
</ul>
</li>
<li>&#x770B;refreshBeanFactory&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#xFF0C;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x662F;&#x62BD;&#x8C61;&#x65B9;&#x6CD5;&#xFF0C;&#x6709;&#x4E00;&#x79CD;&#x662F;&#x5728;AbstractRefreshableApplicationContext&#x8FD9;&#x4E2A;&#x7C7B;&#x4E2D;&#x5B9E;&#x73B0;&#x7684;&#xFF1A;</li>
<li>@Override
protected final void refreshBeanFactory() throws BeansException {
 if (hasBeanFactory()) {<pre><code>destroyBeans();
closeBeanFactory();
</code></pre> }
 try {<pre><code>DefaultListableBeanFactory beanFactory = createBeanFactory();
beanFactory.setSerializationId(getId());
customizeBeanFactory(beanFactory);
</code></pre></li>
<li>//&#x8BE5;&#x65B9;&#x6CD5;&#x6700;&#x7EC8;&#x8C03;&#x7528;XmlBeanDefinitionReader&#x7C7B;&#x4E2D;loadBeanDefinitions(EncodedResource)
loadBeanDefinitions(beanFactory);
synchronized (this.beanFactoryMonitor) {
   this.beanFactory = beanFactory;
}
}
catch (IOException ex) {
throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);
}
}<ul>
<li>1.1.1) loadBeanDefinitions(beanFactory)&#xFF08;&#x521B;&#x5EFA;reader)</li>
</ul>
</li>
<li>&#x770B;loadBeanDefinitions(beanFactory)&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#xFF1A;</li>
<li><p>@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
 // Create a new XmlBeanDefinitionReader for the given BeanFactory.
 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</p>
<p> // Configure the bean definition reader with this context&apos;s
 // resource loading environment.
 beanDefinitionReader.setEnvironment(this.getEnvironment());
 beanDefinitionReader.setResourceLoader(this);
 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</p>
<p> // Allow a subclass to provide custom initialization of the reader,
 // then proceed with actually loading the bean definitions.
 initBeanDefinitionReader(beanDefinitionReader);
 loadBeanDefinitions(beanDefinitionReader);
}</p>
<ul>
<li>1.1.1.1) loadBeanDefinitions(beanDefinitionReader)&#xFF08;&#x8C03;&#x7528;reader&#x7684;load)</li>
</ul>
</li>
<li>&#x770B;loadBeanDefinitions(beanDefinitionReader)&#x7684;&#x53E6;&#x4E00;&#x4E2A;&#x91CD;&#x8F7D;&#xFF1A;</li>
<li>protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
 Resource[] configResources = getConfigResources();
 if (configResources != null) {<pre><code>reader.loadBeanDefinitions(configResources);
</code></pre> }
 String[] configLocations = getConfigLocations();
 if (configLocations != null) {<pre><code>reader.loadBeanDefinitions(configLocations);
</code></pre> }
}<ul>
<li>1.1.1.1.1) XmlBeanDefinitionReader.loadBeanDefinitions&#xFF08;&#x89E3;&#x6790;&#x6807;&#x7B7E;)</li>
</ul>
</li>
<li>&#x770B;reader.loadBeanDefinitions&#x65B9;&#x6CD5;&#xFF1A;</li>
</ul>
<pre><code>@Override
public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {
   Assert.notNull(locations, &quot;Location array must not be null&quot;);
   int counter = 0;
   for (String location : locations) {
      counter += loadBeanDefinitions(location);
   }
   return counter;
}
</code></pre><ul>
<li>loadBeanDefinitions(location,null)</li>
<li>&#x5B83;&#x6700;&#x7EC8;&#x8C03;&#x7528;&#x4E86;loadBeanDefinitions(location,null)&#x65B9;&#x6CD5;</li>
</ul>
<pre><code>public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {
   ResourceLoader resourceLoader = getResourceLoader();
   if (resourceLoader == null) {
      throw new BeanDefinitionStoreException(
            &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);
   }

   if (resourceLoader instanceof ResourcePatternResolver) {
      // Resource pattern matching available.
      try {
         Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
         int loadCount = loadBeanDefinitions(resources);
         if (actualResources != null) {
            for (Resource resource : resources) {
               actualResources.add(resource);
            }
         }
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);
         }
         return loadCount;
      }
      catch (IOException ex) {
         throw new BeanDefinitionStoreException(
               &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);
      }
   }
   else {
      // Can only load single resources by absolute URL.
      Resource resource = resourceLoader.getResource(location);
      int loadCount = loadBeanDefinitions(resource);
      if (actualResources != null) {
         actualResources.add(resource);
      }
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);
      }
      return loadCount;
   }
}
</code></pre><pre><code>public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {
   Assert.notNull(resources, &quot;Resource array must not be null&quot;);
   int counter = 0;
   for (Resource resource : resources) {
      counter += loadBeanDefinitions(resource);
   }
   return counter;
}
</code></pre><pre><code>public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
   return loadBeanDefinitions(new EncodedResource(resource));
}
</code></pre><pre><code>public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
   Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
   if (logger.isInfoEnabled()) {
      logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());
   }

   Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
   if (currentResources == null) {
      currentResources = new HashSet&lt;EncodedResource&gt;(4);
      this.resourcesCurrentlyBeingLoaded.set(currentResources);
   }
   if (!currentResources.add(encodedResource)) {
      throw new BeanDefinitionStoreException(
            &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
   }
   try {
      InputStream inputStream = encodedResource.getResource().getInputStream();
      try {
         InputSource inputSource = new InputSource(inputStream);
         if (encodedResource.getEncoding() != null) {
            inputSource.setEncoding(encodedResource.getEncoding());
         }
         return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
      }
      finally {
         inputStream.close();
      }
   }
   catch (IOException ex) {
      throw new BeanDefinitionStoreException(
            &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
   }
   finally {
      currentResources.remove(encodedResource);
      if (currentResources.isEmpty()) {
         this.resourcesCurrentlyBeingLoaded.remove();
      }
   }
}
</code></pre><ul>
<li>doLoadBeanDefinitions</li>
<li>&#x7EE7;&#x7EED;&#x5411;&#x4E0B;&#x627E;&#xFF0C;&#x6700;&#x7EC8;&#x8C03;&#x7528;&#x4E86;reader&#x7684;doLoadBeanDefinitions&#x65B9;&#x6CD5;&#xFF1A;</li>
<li>protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)<pre><code>throws BeanDefinitionStoreException {
</code></pre> try {<pre><code>Document doc = doLoadDocument(inputSource, resource);
return registerBeanDefinitions(doc, resource);
</code></pre> }
 catch (BeanDefinitionStoreException ex) {<pre><code>throw ex;
</code></pre> }</li>
<li>...</li>
<li>}</li>
<li>doLoadDocument&#x65B9;&#x6CD5;&#x4E2D;&#x7528;&#x5230;&#x4E86;documentLoader&#x5BF9;&#x8C61;&#x52A0;&#x8F7D;document&#xFF0C;&#x5B83;&#x6700;&#x540E;&#x53C8;&#x4F1A;&#x7528;&#x5230;domParser&#x89E3;&#x6790;xml&#x6587;&#x4EF6;&#x3002;</li>
<li>&#x6700;&#x7EC8;&#x662F;&#x4F7F;&#x7528;jaxp&#x7684;dom&#x65B9;&#x5F0F;&#x8BFB;&#x53D6;&#x7684;XML&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x3002;&#xFF08;JAXP&#x662F;&#x4E00;&#x79CD;&#x6807;&#x51C6;&#xFF0C;SUN&#x516C;&#x53F8;&#x5BF9;&#x5176;&#x63D0;&#x4F9B;&#x4E86;&#x5B9E;&#x73B0;)</li>
<li>registerBeanDefinitions</li>
<li>&#x5C06;XML&#x5BF9;&#x5E94;&#x7684;Document&#x5BF9;&#x8C61;&#x8F6C;&#x4E3A;BeanDefinitions&#xFF1A;</li>
</ul>
<pre><code>public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
   int countBefore = getRegistry().getBeanDefinitionCount();
   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
   return getRegistry().getBeanDefinitionCount() - countBefore;
}
</code></pre><ul>
<li>documentReader#registerBeanDefinitions</li>
<li>&#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x62BD;&#x8C61;&#x65B9;&#x6CD5;&#xFF0C;&#x5728;DefaultBeanDefinitionDocumentReader&#x7C7B;&#x4E2D;&#x5F97;&#x5230;&#x5B9E;&#x73B0;&#xFF1A;</li>
</ul>
<pre><code>public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
   this.readerContext = readerContext;
   logger.debug(&quot;Loading bean definitions&quot;);
   Element root = doc.getDocumentElement();
   doRegisterBeanDefinitions(root);
}
</code></pre><ul>
<li>doRegisterBeanDefinitions</li>
<li>&#x5B9E;&#x9645;&#x89E3;&#x6790;&#x6587;&#x6863;&#x7684;&#x662F;doRegisterBeanDefinitions&#x65B9;&#x6CD5;&#xFF1A;</li>
<li><p>protected void doRegisterBeanDefinitions(Element root) {
 // Any nested <beans> elements will cause recursion in this method. In
 // order to propagate and preserve <beans> default-* attributes correctly,
 // keep track of the current (parent) delegate, which may be null. Create
 // the new (child) delegate with a reference to the parent for fallback purposes,
 // then ultimately reset this.delegate back to its original (parent) reference.
 // this behavior emulates a stack of delegates without actually necessitating one.
 BeanDefinitionParserDelegate parent = this.delegate;
 this.delegate = createDelegate(getReaderContext(), root, parent);</beans></beans></p>
<p> if (this.delegate.isDefaultNamespace(root)) {</p>
<pre><code>String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
if (StringUtils.hasText(profileSpec)) {
   String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
         profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
   if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
      if (logger.isInfoEnabled()) {
         logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
               &quot;] not matching: &quot; + getReaderContext().getResource());
      }
      return;
   }
}
</code></pre><p> }</p>
<p> preProcessXml(root);
 parseBeanDefinitions(root, this.delegate);
 postProcessXml(root);</p>
<p> this.delegate = parent;
}</p>
</li>
<li>parseBeanDefinitions&#xFF08;&#x89E3;&#x6790;&#x6807;&#x7B7E;)</li>
<li>&#x5B9E;&#x9645;&#x89E3;&#x6790;&#x65B9;&#x6CD5;parseBeanDefinitions&#xFF1A;</li>
<li>protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
 if (delegate.isDefaultNamespace(root)) {<pre><code>NodeList nl = root.getChildNodes();
for (int i = 0; i &lt; nl.getLength(); i++) {
   Node node = nl.item(i);
   if (node instanceof Element) {
      Element ele = (Element) node;
      if (delegate.isDefaultNamespace(ele)) {
         parseDefaultElement(ele, delegate);
      }
      else {
         delegate.parseCustomElement(ele);
      }
   }
}
</code></pre> }
 else {<pre><code>delegate.parseCustomElement(root);
</code></pre> }
}</li>
<li>&#x5206;&#x5F00;&#x89E3;&#x6790;&#x9ED8;&#x8BA4;&#x6807;&#x7B7E;&#x548C;&#x81EA;&#x5B9A;&#x4E49;&#x6807;&#x7B7E;&#x3002;</li>
<li>parseDefaultElement&#xFF08;&#x89E3;&#x6790;&#x9ED8;&#x8BA4;&#x6807;&#x7B7E;)</li>
<li>&#x5C31;import&#x3001;alias&#x3001;bean&#x548C;beans&#x56DB;&#x79CD;&#x9ED8;&#x8BA4;&#x6807;&#x7B7E;&#x8FDB;&#x884C;&#x89E3;&#x6790;</li>
</ul>
<pre><code>private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
      importBeanDefinitionResource(ele);
   }
   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
      processAliasRegistration(ele);
   }
   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
      processBeanDefinition(ele, delegate);
   }
   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
      // recurse
      doRegisterBeanDefinitions(ele);
   }
}
</code></pre><ul>
<li>parseCustomElement&#xFF08;&#x89E3;&#x6790;&#x81EA;&#x5B9A;&#x4E49;&#x6807;&#x7B7E;)</li>
<li>&#x8C03;&#x7528;&#x7684;&#x662F;parseCustomElement(ele,null)    </li>
</ul>
<pre><code>public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {
   String namespaceUri = getNamespaceURI(ele);
   NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
   if (handler == null) {
      error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);
      return null;
   }
   return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));
}
</code></pre><ul>
<li>NamespaceHandlerSupport#parse</li>
</ul>
<pre><code>public BeanDefinition parse(Element element, ParserContext parserContext) {
   return findParserForElement(element, parserContext).parse(element, parserContext);
}
</code></pre><ul>
<li>a) findParserForElement</li>
</ul>
<pre><code>private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {
   String localName = parserContext.getDelegate().getLocalName(element);
   BeanDefinitionParser parser = this.parsers.get(localName);
   if (parser == null) {
      parserContext.getReaderContext().fatal(
            &quot;Cannot locate BeanDefinitionParser for element [&quot; + localName + &quot;]&quot;, element);
   }
   return parser;
}
</code></pre><ul>
<li>parser&#x662F;ComponentScanBeanDefinitionParser&#x7C7B;&#x578B;&#x3002;</li>
<li>b) ComponentScanBeanDefinitionParser#parse</li>
</ul>
<pre><code>public BeanDefinition parse(Element element, ParserContext parserContext) {
   String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);
   basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
   String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,
         ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);

   // Actually scan for bean definitions and register them.
   ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);
   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);
   registerComponents(parserContext.getReaderContext(), beanDefinitions, element);

   return null;
}
</code></pre><pre><code>- 1) ClassPathBeanDefinitionScanner.doScan&#xFF08;&#x89E3;&#x6790;&#x6CE8;&#x89E3;&#x5B9A;&#x4E49;&#x7684;bean)
</code></pre><ul>
<li>&#x6839;&#x636E;&#x81EA;&#x5B9A;&#x4E49;&#x6807;&#x7B7E;component-scan&#x6765;&#x626B;&#x63CF;&#x5305;&#xFF0C;&#x6279;&#x91CF;&#x6CE8;&#x518C;bean&#x3002;</li>
<li><p>protected Set<beandefinitionholder> doScan(String... basePackages) {
 Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
 Set<beandefinitionholder> beanDefinitions = new LinkedHashSet<beandefinitionholder>();
 for (String basePackage : basePackages) {</beandefinitionholder></beandefinitionholder></beandefinitionholder></p>
<pre><code>Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
for (BeanDefinition candidate : candidates) {
   ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
   candidate.setScope(scopeMetadata.getScopeName());
   String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
   if (candidate instanceof AbstractBeanDefinition) {
      postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
   }
   if (candidate instanceof AnnotatedBeanDefinition) {
      AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
   }
   if (checkCandidate(beanName, candidate)) {
      BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
      definitionHolder =
            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
      beanDefinitions.add(definitionHolder);
      registerBeanDefinition(definitionHolder, this.registry);
   }
}
</code></pre><p> }
 return beanDefinitions;
}</p>
<ul>
<li>1.1) findCandidateComponents</li>
</ul>
</li>
</ul>
<pre><code>public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) {
   Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;();
   try {
      String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
            resolveBasePackage(basePackage) + &apos;/&apos; + this.resourcePattern;
</code></pre><ul>
<li>// &#x8FD9;&#x91CC;&#x662F;&#x672A;&#x52A0;&#x7B5B;&#x9009;&#x7684;&#x62FF;&#x5230;&#x4E86;&#x6240;&#x6709;class&#x6587;&#x4EF6;<pre><code>Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
boolean traceEnabled = logger.isTraceEnabled();
boolean debugEnabled = logger.isDebugEnabled();
for (Resource resource : resources) {
   if (traceEnabled) {
      logger.trace(&quot;Scanning &quot; + resource);
   }
   if (resource.isReadable()) {
      try {
</code></pre></li>
<li>// &#x8FD9;&#x91CC;&#x4F1A;&#x628A;class&#x6587;&#x4EF6;&#x8BFB;&#x8FDB;&#x6765;<pre><code>         MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
</code></pre></li>
<li>// &#x5224;&#x65AD;class&#x6587;&#x4EF6;&#x662F;&#x5426;&#x662F;&#x6CE8;&#x518C;&#x5728;Spring&#x4E2D;&#x7684;bean&#x7C7B;&#x578B;<pre><code>         if (isCandidateComponent(metadataReader)) {
            ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
            sbd.setResource(resource);
            sbd.setSource(resource);
            if (isCandidateComponent(sbd)) {
               if (debugEnabled) {
                  logger.debug(&quot;Identified candidate component class: &quot; + resource);
               }
               candidates.add(sbd);
            }
            else {
               if (debugEnabled) {
                  logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
               }
            }
         }
         else {
            if (traceEnabled) {
               logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
            }
         }
      }
      catch (Throwable ex) {
         throw new BeanDefinitionStoreException(
               &quot;Failed to read candidate component class: &quot; + resource, ex);
      }
   }
   else {
      if (traceEnabled) {
         logger.trace(&quot;Ignored because not readable: &quot; + resource);
      }
   }
}
</code></pre> }
 catch (IOException ex) {<pre><code>throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex);
</code></pre> }
 return candidates;
}</li>
<li><ul>
<li>1.1.1) PathMatchingResourcePatternResolver.getResources</li>
</ul>
</li>
</ul>
<pre><code>public Resource[] getResources(String locationPattern) throws IOException {
   Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;);
   if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
      // a class path resource (multiple resources for same name possible)
      if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
         // a class path resource pattern
         return findPathMatchingResources(locationPattern);
      }
      else {
         // all class path resources with the given name
         return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
      }
   }
   else {
      // Only look for a pattern after a prefix here
      // (to not get fooled by a pattern symbol in a strange prefix).
      int prefixEnd = locationPattern.indexOf(&quot;:&quot;) + 1;
      if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {
         // a file pattern
         return findPathMatchingResources(locationPattern);
      }
      else {
         // a single resource with the given name
         return new Resource[] {getResourceLoader().getResource(locationPattern)};
      }
   }
}
</code></pre><ul>
<li><ul>
<li>1.1.1.1) findPathMatchingResources</li>
</ul>
</li>
<li>protected Resource[] findPathMatchingResources(String locationPattern) throws IOException {
 String rootDirPath = determineRootDir(locationPattern);
 String subPattern = locationPattern.substring(rootDirPath.length());<ul>
<li>// &#x6839;&#x8DEF;&#x5F84;&#xFF0C;component-scan&#x4E2D;&#x914D;&#x7F6E;&#x7684;&#x5305;&#x540D;
Resource[] rootDirResources = getResources(rootDirPath);
Set<resource> result = new LinkedHashSet<resource>(16);
for (Resource rootDirResource : rootDirResources) {
rootDirResource = resolveRootDirResource(rootDirResource);
URL rootDirURL = rootDirResource.getURL();
if (equinoxResolveMethod != null) {
   if (rootDirURL.getProtocol().startsWith(&quot;bundle&quot;)) {<pre><code>  rootDirURL = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirURL);
  rootDirResource = new UrlResource(rootDirURL);
</code></pre>   }
}
if (rootDirURL.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {
   result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirURL, subPattern, getPathMatcher()));
}
else if (ResourceUtils.isJarURL(rootDirURL) || isJarResource(rootDirResource)) {
   result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirURL, subPattern));
}
else {
   result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));
}
}
if (logger.isDebugEnabled()) {
logger.debug(&quot;Resolved location pattern [&quot; + locationPattern + &quot;] to resources &quot; + result);
}
return result.toArray(new Resource[result.size()]);
}</resource></resource></li>
</ul>
</li>
<li><ul>
<li>1.1.1.1.1) doFindPathMatchingFileResources</li>
</ul>
</li>
<li><p>protected Set<resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)</resource></p>
<pre><code>throws IOException {
</code></pre><p> File rootDir;
 try {</p>
<pre><code>rootDir = rootDirResource.getFile().getAbsoluteFile();
</code></pre><p> }
 catch (IOException ex) {</p>
<pre><code>if (logger.isWarnEnabled()) {
   logger.warn(&quot;Cannot search for matching files underneath &quot; + rootDirResource +
         &quot; because it does not correspond to a directory in the file system&quot;, ex);
}
return Collections.emptySet();
</code></pre><p> }
 return doFindMatchingFileSystemResources(rootDir, subPattern);
}</p>
</li>
<li>doFindMatchingFileSystemResources</li>
<li><p>protected Set<resource> doFindMatchingFileSystemResources(File rootDir, String subPattern) throws IOException {
 if (logger.isDebugEnabled()) {</resource></p>
<pre><code>logger.debug(&quot;Looking for matching resources in directory tree [&quot; + rootDir.getPath() + &quot;]&quot;);
</code></pre><p> }
 Set<file> matchingFiles = retrieveMatchingFiles(rootDir, subPattern);
 Set<resource> result = new LinkedHashSet<resource>(matchingFiles.size());
 for (File file : matchingFiles) {</resource></resource></file></p>
<pre><code>result.add(new FileSystemResource(file));
</code></pre><p> }
 return result;
}</p>
<ul>
<li>1.1.1.1.1.1) retrieveMatchingFiles</li>
<li><p>protected Set<file> retrieveMatchingFiles(File rootDir, String pattern) throws IOException {
if (!rootDir.exists()) {
// Silently skip non-existing directories.
if (logger.isDebugEnabled()) {
   logger.debug(&quot;Skipping [&quot; + rootDir.getAbsolutePath() + &quot;] because it does not exist&quot;);
}
return Collections.emptySet();
}
if (!rootDir.isDirectory()) {
// Complain louder if it exists but is no directory.
if (logger.isWarnEnabled()) {
   logger.warn(&quot;Skipping [&quot; + rootDir.getAbsolutePath() + &quot;] because it does not denote a directory&quot;);
}
return Collections.emptySet();
}
if (!rootDir.canRead()) {
if (logger.isWarnEnabled()) {
   logger.warn(&quot;Cannot search for matching files underneath directory [&quot; + rootDir.getAbsolutePath() +</file></p>
<pre><code>     &quot;] because the application is not allowed to read the directory&quot;);
</code></pre><p>}
return Collections.emptySet();
}
String fullPattern = StringUtils.replace(rootDir.getAbsolutePath(), File.separator, &quot;/&quot;);
if (!pattern.startsWith(&quot;/&quot;)) {
fullPattern += &quot;/&quot;;
}
fullPattern = fullPattern + StringUtils.replace(pattern, File.separator, &quot;/&quot;);
Set<file> result = new LinkedHashSet<file>(8);
doRetrieveMatchingFiles(fullPattern, rootDir, result);
return result;
}</file></file></p>
</li>
<li><p>1.1.1.1.1.1.1) doRetrieveMatchingFiles&#xFF08;&#x9012;&#x5F52;&#x65B9;&#x6CD5;)</p>
</li>
</ul>
</li>
<li>protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set<file> result) throws IOException {
 if (logger.isDebugEnabled()) {<pre><code>logger.debug(&quot;Searching directory [&quot; + dir.getAbsolutePath() +
      &quot;] for files matching pattern [&quot; + fullPattern + &quot;]&quot;);
</code></pre> }</file></li>
<li><p>// &#x62FF;&#x5230;component-scan&#x76EE;&#x5F55;&#x4E0B;&#x7684;&#x6240;&#x6709;class&#x6587;&#x4EF6;
 File[] dirContents = dir.listFiles();
 if (dirContents == null) {</p>
<pre><code>if (logger.isWarnEnabled()) {
   logger.warn(&quot;Could not retrieve contents of directory [&quot; + dir.getAbsolutePath() + &quot;]&quot;);
}
return;
</code></pre><p> }
 Arrays.sort(dirContents);
 for (File content : dirContents) {</p>
<pre><code>String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, &quot;/&quot;);
if (content.isDirectory() &amp;&amp; getPathMatcher().matchStart(fullPattern, currPath + &quot;/&quot;)) {
   if (!content.canRead()) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Skipping subdirectory [&quot; + dir.getAbsolutePath() +
               &quot;] because the application is not allowed to read the directory&quot;);
      }
   }
   else {
      doRetrieveMatchingFiles(fullPattern, content, result);
   }
}
if (getPathMatcher().match(fullPattern, currPath)) {
   result.add(content);
}
</code></pre><p> }
}</p>
</li>
<li><ul>
<li>1.1.2) CachingMetadataResourceFactory.getMetadataReader&#xFF08;&#x8BFB;&#x53D6;class&#x6587;&#x4EF6;)</li>
</ul>
</li>
</ul>
<pre><code>public MetadataReader getMetadataReader(Resource resource) throws IOException {
   if (getCacheLimit() &lt;= 0) {
      return super.getMetadataReader(resource);
   }
   synchronized (this.metadataReaderCache) {
      MetadataReader metadataReader = this.metadataReaderCache.get(resource);
      if (metadataReader == null) {
         metadataReader = super.getMetadataReader(resource);
         this.metadataReaderCache.put(resource, metadataReader);
      }
      return metadataReader;
   }
}
</code></pre><pre><code>- 1.1.2.1) SimpleMetadataReader.getMetadataReader
</code></pre><ul>
<li>&#x8BE5;&#x7C7B;&#x5C01;&#x88C5;&#x4E86;Class&#x6587;&#x4EF6;&#x4E2D;&#x7684;&#x5404;&#x79CD;&#x4FE1;&#x606F;&#xFF0C;&#x4FDD;&#x5B58;&#x5728;ClassMatadata&#x548C;AnnotationMetadata&#x4E2D;&#x3002;</li>
</ul>
<pre><code>final class SimpleMetadataReader implements MetadataReader {

   private final Resource resource;

   private final ClassMetadata classMetadata;

   private final AnnotationMetadata annotationMetadata;
</code></pre><ul>
<li>}</li>
</ul>
<pre><code>public MetadataReader getMetadataReader(Resource resource) throws IOException {
   return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());
}
</code></pre><ul>
<li><p>SimpleMetadataReader(Resource resource, ClassLoader classLoader) throws IOException {
 InputStream is = new BufferedInputStream(resource.getInputStream());
 ClassReader classReader;
 try {</p>
<pre><code>classReader = new ClassReader(is);
</code></pre><p> }
 catch (IllegalArgumentException ex) {</p>
<pre><code>throw new NestedIOException(&quot;ASM ClassReader failed to parse class file - &quot; +
      &quot;probably due to a new Java class file version that isn&apos;t supported yet: &quot; + resource, ex);
</code></pre><p> }
 finally {</p>
<pre><code>is.close();
</code></pre><p> }</p>
<p> AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader);
 classReader.accept(visitor, ClassReader.SKIP_DEBUG);</p>
<p> this.annotationMetadata = visitor;
 // (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)
 this.classMetadata = visitor;
 this.resource = resource;
}</p>
<ul>
<li>1.1.2.1.1) ClassReader.accept</li>
</ul>
</li>
<li>&#x6E90;&#x7801;&#x6BD4;&#x8F83;&#x5947;&#x602A;&#xFF0C;&#x5927;&#x6982;&#x662F;&#x6309;&#x7167;class&#x6587;&#x4EF6;&#x7684;&#x683C;&#x5F0F;&#x89E3;&#x6790;&#xFF0C;&#x5E76;&#x5C06;&#x7ED3;&#x679C;&#x5C01;&#x88C5;&#x5230;visitor&#x91CC;&#x9762;&#x3002;</li>
<li><ul>
<li>1.1.3) isCandidateComponent</li>
</ul>
</li>
<li><p>protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
for (TypeFilter tf : this.excludeFilters) {
   if (tf.match(metadataReader, this.metadataReaderFactory)) {</p>
<pre><code>  return false;
</code></pre><p>   }
}
for (TypeFilter tf : this.includeFilters) {
   if (tf.match(metadataReader, this.metadataReaderFactory)) {</p>
<pre><code>  return isConditionMatch(metadataReader);
</code></pre><p>   }
}
return false;
}</p>
</li>
<li><p>&#x8FD9;&#x91CC;&#x7684;includeFilters&#x6709;&#x4E00;&#x4E2A;AnnotationTypeFilter&#x3002;</p>
<ul>
<li>1.1.3.1) AbstractTypeHierarchyTraversingFilter.match</li>
</ul>
</li>
</ul>
<pre><code>public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
      throws IOException {

   // This method optimizes avoiding unnecessary creation of ClassReaders
   // as well as visiting over those readers.
   if (matchSelf(metadataReader)) {
      return true;
   }
   ClassMetadata metadata = metadataReader.getClassMetadata();
   if (matchClassName(metadata.getClassName())) {
      return true;
   }

   if (this.considerInherited) {
      if (metadata.hasSuperClass()) {
         // Optimization to avoid creating ClassReader for super class.
         Boolean superClassMatch = matchSuperClass(metadata.getSuperClassName());
         if (superClassMatch != null) {
            if (superClassMatch.booleanValue()) {
               return true;
            }
         }
         else {
            // Need to read super class to determine a match...
            try {
               if (match(metadata.getSuperClassName(), metadataReaderFactory)) {
                  return true;
               }
            }
            catch (IOException ex) {
               logger.debug(&quot;Could not read super class [&quot; + metadata.getSuperClassName() +
                     &quot;] of type-filtered class [&quot; + metadata.getClassName() + &quot;]&quot;);
            }
            }
      }
   }

   if (this.considerInterfaces) {
      for (String ifc : metadata.getInterfaceNames()) {
         // Optimization to avoid creating ClassReader for super class
         Boolean interfaceMatch = matchInterface(ifc);
         if (interfaceMatch != null) {
            if (interfaceMatch.booleanValue()) {
               return true;
            }
         }
         else {
            // Need to read interface to determine a match...
            try {
               if (match(ifc, metadataReaderFactory)) {
                  return true;
               }
            }
            catch (IOException ex) {
               logger.debug(&quot;Could not read interface [&quot; + ifc + &quot;] for type-filtered class [&quot; +
                     metadata.getClassName() + &quot;]&quot;);
            }
         }
      }
   }

   return false;
}
</code></pre><ul>
<li><p>protected boolean matchSelf(MetadataReader metadataReader) {
 AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();
 return metadata.hasAnnotation(this.annotationType.getName()) ||</p>
<pre><code>   (this.considerMetaAnnotations &amp;&amp; metadata.hasMetaAnnotation(this.annotationType.getName()));
</code></pre><p>}</p>
</li>
<li><p>this.annotationType&#x662F;@Component&#x7C7B;&#x578B;&#xFF0C;&#x6240;&#x4EE5;</p>
</li>
<li>metadata.hasAnnotation(this.annotationType.getName())&#x5F53;&#x7C7B;&#x4E0A;&#x6CE8;&#x89E3;&#x4E86;@Component&#x65F6;&#x4E3A;true&#x3002;</li>
<li>&#x8FD9;&#x91CC;&#x56E0;&#x4E3A;@Service&#x7B49;&#x4E5F;&#x6CE8;&#x89E3;&#x4E86;@Component&#x4E86;&#xFF0C;&#x6240;&#x4EE5;@Service&#x3001;@Controller&#x7B49;&#x5728;&#x8FD9;&#x91CC;&#x90FD;&#x88AB;&#x89C6;&#x4E3A;@Component&#x3002;</li>
</ul>
<pre><code>public boolean hasMetaAnnotation(String metaAnnotationType) {
   Collection&lt;Set&lt;String&gt;&gt; allMetaTypes = this.metaAnnotationMap.values();
   for (Set&lt;String&gt; metaTypes : allMetaTypes) {
      if (metaTypes.contains(metaAnnotationType)) {
         return true;
      }
   }
   return false;
}
</code></pre><pre><code>- 1.2) registerBeanDefinition&#xFF08;&#x5C06;beanDefinition&#x8BB0;&#x5F55;&#x5230;BeanFactory)
</code></pre><ul>
<li>protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
 BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}</li>
<li><ul>
<li>1.2.1) DefaultListableBeanFactory.registerBeanDefinition&#xFF08;&#x4FDD;&#x5B58;beanDefinition)</li>
</ul>
</li>
</ul>
<pre><code>public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException {

   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

   if (beanDefinition instanceof AbstractBeanDefinition) {
      try {
         ((AbstractBeanDefinition) beanDefinition).validate();
      }
      catch (BeanDefinitionValidationException ex) {
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
               &quot;Validation of bean definition failed&quot;, ex);
      }
   }

   BeanDefinition oldBeanDefinition;

   oldBeanDefinition = this.beanDefinitionMap.get(beanName);
   if (oldBeanDefinition != null) {
      if (!isAllowBeanDefinitionOverriding()) {
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
               &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &apos;&quot; + beanName +
               &quot;&apos;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);
      }
      else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) {
         // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
         if (this.logger.isWarnEnabled()) {
            this.logger.warn(&quot;Overriding user-defined bean definition for bean &apos;&quot; + beanName +
                  &quot;&apos; with a framework-generated bean definition: replacing [&quot; +
                  oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
         }
      }
      else if (!beanDefinition.equals(oldBeanDefinition)) {
         if (this.logger.isInfoEnabled()) {
            this.logger.info(&quot;Overriding bean definition for bean &apos;&quot; + beanName +
                  &quot;&apos; with a different definition: replacing [&quot; + oldBeanDefinition +
                  &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
         }
      }
      else {
         if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Overriding bean definition for bean &apos;&quot; + beanName +
                  &quot;&apos; with an equivalent definition: replacing [&quot; + oldBeanDefinition +
                  &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
         }
      }
      this.beanDefinitionMap.put(beanName, beanDefinition);
   }
   else {
      if (hasBeanCreationStarted()) {
         // Cannot modify startup-time collection elements anymore (for stable iteration)
         synchronized (this.beanDefinitionMap) {
            this.beanDefinitionMap.put(beanName, beanDefinition);
            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);
            updatedDefinitions.addAll(this.beanDefinitionNames);
            updatedDefinitions.add(beanName);
            this.beanDefinitionNames = updatedDefinitions;
            if (this.manualSingletonNames.contains(beanName)) {
               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);
               updatedSingletons.remove(beanName);
               this.manualSingletonNames = updatedSingletons;
            }
         }
      }
      else {
         // Still in startup registration phase
         this.beanDefinitionMap.put(beanName, beanDefinition);
         this.beanDefinitionNames.add(beanName);
         this.manualSingletonNames.remove(beanName);
      }
      this.frozenBeanDefinitionNames = null;
   }

   if (oldBeanDefinition != null || containsSingleton(beanName)) {
      resetBeanDefinition(beanName);
   }
}
</code></pre><ul>
<li><p>&#x6807;&#x7B7E;&#x89E3;&#x6790;&#x5B8C;&#x6BD5;&#x540E;&#x4F1A;&#x5C06;beanName&#x548C;beanDefinition&#x4F5C;&#x4E3A;key&#x548C;value&#x653E;&#x5165;beanfactory&#x7684;beanDefinitionMap&#x4E2D;&#x3002;</p>
</li>
<li><ul>
<li>2) finishBeanFactoryInitialization&#xFF08;&#x521D;&#x59CB;&#x5316;&#x975E;lazy-load&#x4E14;singleton&#x7684;bean)</li>
</ul>
</li>
</ul>
<pre><code>protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
   // Initialize conversion service for this context.
   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
      beanFactory.setConversionService(
            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
   }

   // Register a default embedded value resolver if no bean post-processor
   // (such as a PropertyPlaceholderConfigurer bean) registered any before:
   // at this point, primarily for resolution in annotation attribute values.
   if (!beanFactory.hasEmbeddedValueResolver()) {
      beanFactory.addEmbeddedValueResolver(new StringValueResolver() {
         @Override
         public String resolveStringValue(String strVal) {
            return getEnvironment().resolvePlaceholders(strVal);
         }
      });
   }

   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
   for (String weaverAwareName : weaverAwareNames) {
      getBean(weaverAwareName);
   }

   // Stop using the temporary ClassLoader for type matching.
   beanFactory.setTempClassLoader(null);

   // Allow for caching all bean definition metadata, not expecting further changes.
   beanFactory.freezeConfiguration();

   // Instantiate all remaining (non-lazy-init) singletons.
   beanFactory.preInstantiateSingletons();
}
</code></pre><pre><code>- 2.1) ConfigurableListableBeanFactory#preInstantiateSingletons
</code></pre><ul>
<li>DefaultListableBeanFactory.preInstantiateSingletons</li>
</ul>
<pre><code>public void preInstantiateSingletons() throws BeansException {
   if (this.logger.isDebugEnabled()) {
      this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);
   }

   // Iterate over a copy to allow for init methods which in turn register new bean definitions.
   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
   List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);

   // Trigger initialization of all non-lazy singleton beans...
   for (String beanName : beanNames) {
      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
         if (isFactoryBean(beanName)) {
            final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);
            boolean isEagerInit;
            if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
               isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {
                  @Override
                  public Boolean run() {
                     return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();
                  }
               }, getAccessControlContext());
            }
            else {
               isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
            }
            if (isEagerInit) {
               getBean(beanName);
            }
         }
         else {
            getBean(beanName);
         }
      }
   }

   // Trigger post-initialization callback for all applicable beans...
   for (String beanName : beanNames) {
      Object singletonInstance = getSingleton(beanName);
      if (singletonInstance instanceof SmartInitializingSingleton) {
         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
         if (System.getSecurityManager() != null) {
            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
               @Override
               public Object run() {
                  smartSingleton.afterSingletonsInstantiated();
                  return null;
               }
            }, getAccessControlContext());
         }
         else {
            smartSingleton.afterSingletonsInstantiated();
         }
      }
   }
}
</code></pre><ul>
<li></li>
<li><p>Bean&#x7684;&#x52A0;&#x8F7D;</p>
</li>
<li></li>
<li><p>FactoryBean&#xFF08;&#x5DE5;&#x5382;Bean&#xFF0C;&#x7528;&#x6237;&#x5B9A;&#x5236;)</p>
</li>
<li>Spring&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x673A;&#x5236;&#x5229;&#x7528;bean&#x7684;class&#x5C5E;&#x6027;&#x6307;&#x5B9A;&#x5B9E;&#x73B0;&#x7C7B;&#x6765;&#x5B9E;&#x4F8B;&#x5316;bean&#x3002;</li>
<li>Spring&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x4E2A;FactoryBean&#x7684;&#x5DE5;&#x5382;&#x7C7B;&#x63A5;&#x53E3;&#xFF0C;&#x7528;&#x6237;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5B9E;&#x73B0;&#x8BE5;&#x63A5;&#x53E3;&#x5B9A;&#x5236;&#x5B9E;&#x4F8B;&#x5316;bean&#x7684;&#x903B;&#x8F91;&#x3002;</li>
<li>FactoryBean</li>
</ul>
<pre><code>public interface FactoryBean&lt;T&gt; {
</code></pre><ul>
<li>// &#x8FD4;&#x56DE;bean&#x5B9E;&#x4F8B;&#xFF0C;&#x5982;&#x679C;isSingleton()&#x8FD4;&#x56DE;true&#xFF0C;&#x90A3;&#x4E48;&#x8BE5;&#x5B9E;&#x4F8B;&#x4F1A;&#x653E;&#x5230;Spring&#x5BB9;&#x5668;&#x4E2D;&#x5355;&#x4F8B;&#x7F13;&#x5B58;&#x6C60;&#x4E2D;
 T getObject() throws Exception;
 Class&lt;?&gt; getObjectType();
 boolean isSingleton();
}</li>
<li>FactoryBean&#xFF1A;</li>
<li>&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x4F7F;&#x4F60;&#x53EF;&#x4EE5;&#x63D0;&#x4F9B;&#x4E00;&#x4E2A;&#x590D;&#x6742;&#x7684;&#x903B;&#x8F91;&#x6765;&#x751F;&#x6210;Bean&#x3002;&#x5B83;&#x672C;&#x8D28;&#x662F;&#x4E00;&#x4E2A;Bean&#xFF0C;&#x4F46;&#x8FD9;&#x4E2A;Bean&#x4E0D;&#x662F;&#x7528;&#x6765;&#x6CE8;&#x5165;&#x5230;&#x5176;&#x5B83;&#x5730;&#x65B9;&#x50CF;Service&#x3001;Dao&#x4E00;&#x6837;&#x4F7F;&#x7528;&#x7684;&#xFF0C;&#x5B83;&#x662F;&#x7528;&#x6765;&#x751F;&#x6210;&#x5176;&#x5B83;Bean&#x4F7F;&#x7528;&#x7684;&#x3002;&#x5B9E;&#x73B0;&#x4E86;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x540E;&#xFF0C;Spring&#x5728;&#x5BB9;&#x5668;&#x521D;&#x59CB;&#x5316;&#x65F6;&#xFF0C;&#x628A;&#x5B9E;&#x73B0;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x7684;Bean&#x53D6;&#x51FA;&#x6765;&#xFF0C;&#x4F7F;&#x7528;&#x63A5;&#x53E3;&#x7684;getObject()&#x65B9;&#x6CD5;&#x6765;&#x751F;&#x6210;&#x6211;&#x4EEC;&#x8981;&#x60F3;&#x7684;Bean&#x3002;&#x5F53;&#x7136;&#xFF0C;&#x90A3;&#x4E9B;&#x751F;&#x6210;Bean&#x7684;&#x4E1A;&#x52A1;&#x903B;&#x8F91;&#x4E5F;&#x8981;&#x5199;getObject()&#x65B9;&#x6CD5;&#x4E2D;&#x3002;</li>
<li>&#x5176;&#x8FD4;&#x56DE;&#x7684;&#x5BF9;&#x8C61;&#x4E0D;&#x662F;&#x6307;&#x5B9A;&#x7C7B;&#x7684;&#x4E00;&#x4E2A;&#x5B9E;&#x4F8B;&#xFF0C;&#x5176;&#x8FD4;&#x56DE;&#x7684;&#x662F;&#x8BE5;&#x5DE5;&#x5382;Bean&#x7684;getObject&#x65B9;&#x6CD5;&#x6240;&#x8FD4;&#x56DE;&#x7684;&#x5BF9;&#x8C61;&#x3002;&#x521B;&#x5EFA;&#x51FA;&#x6765;&#x7684;&#x5BF9;&#x8C61;&#x662F;&#x5426;&#x5C5E;&#x4E8E;&#x5355;&#x4F8B;&#x7531;isSingleton&#x4E2D;&#x7684;&#x8FD4;&#x56DE;&#x51B3;&#x5B9A;&#x3002;</li>
<li><p>&#x4F7F;&#x7528;&#x573A;&#x666F;&#xFF1A;1&#x3001;&#x901A;&#x8FC7;&#x5916;&#x90E8;&#x5BF9;&#x7C7B;&#x662F;&#x5426;&#x662F;&#x5355;&#x4F8B;&#x8FDB;&#x884C;&#x63A7;&#x5236;&#xFF0C;&#x8BE5;&#x7C7B;&#x81EA;&#x5DF1;&#x65E0;&#x6CD5;&#x611F;&#x77E5; 2&#x3001;&#x5728;&#x521B;&#x5EFA;Object&#x5BF9;&#x8C61;&#x4E4B;&#x524D;&#x8FDB;&#x884C;&#x521D;&#x59CB;&#x5316;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x5728;afterPropertiesSet()&#x4E2D;&#x5B8C;&#x6210;&#x3002;&#xFF08;&#x4E00;&#x6B21;&#x6027;&#x7684;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x4FDD;&#x5B58;&#x5728;&#x6210;&#x5458;&#x53D8;&#x91CF;&#x4E2D;&#xFF0C;&#x5E76;&#x4E0D;&#x662F;&#x6BCF;&#x6B21;getObject&#x90FD;&#x4F1A;&#x8C03;&#x7528;afterPropertiesSet&#xFF0C;afterPropertiesSet&#x53EA;&#x4F1A;&#x88AB;&#x8C03;&#x7528;&#x4E00;&#x6B21;)</p>
</li>
<li><p>&#x5B9E;&#x4F8B;&#xFF1A;</p>
</li>
</ul>
<pre><code>public class CarFactoryBean implements FactoryBean&lt;Car&gt; {
</code></pre><pre><code>    private String brand;
</code></pre><pre><code>    private double price;
</code></pre><ul>
<li>@Override</li>
</ul>
<pre><code>    public Car getObject() throws Exception {
</code></pre><ul>
<li>return new Car(brand,price);</li>
<li>}</li>
<li>@Override</li>
</ul>
<pre><code>    public Class&lt;?&gt; getObjectType() {
</code></pre><ul>
<li>return Car.class;</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
</ul>
<pre><code>    public boolean isSingleton() {
</code></pre><ul>
<li>return true;</li>
<li>}</li>
</ul>
<pre><code>    public String getBrand() {
</code></pre><ul>
<li>return brand;</li>
<li>}</li>
</ul>
<pre><code>    public void setBrand(String brand) {
</code></pre><ul>
<li>this.brand = brand;</li>
<li>}</li>
</ul>
<pre><code>    public double getPrice() {
</code></pre><ul>
<li>return price;</li>
<li>}</li>
</ul>
<pre><code>    public void setPrice(double price) {
</code></pre><ul>
<li>this.price = price;</li>
<li>}</li>
<li><p>}</p>
</li>
<li><bean id="car" class="factorybean.CarFactoryBean"></bean></li>
<li><property name="brand" value="BMW"></property></li>
<li><property name="price" value="300000"></property></li>
<li>&lt;/bean&gt;</li>
</ul>
<pre><code>public class Main {
</code></pre><pre><code>    public static void main(String[] args) {
</code></pre><ul>
<li>ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans-factoryBean.xml&quot;);</li>
<li>Car car = (Car) ctx.getBean(&quot;car&quot;);</li>
<li>System.out.println(car);</li>
<li>}</li>
<li>}</li>
<li>ObjectFactory&#xFF08;Spring&#x4F7F;&#x7528;)</li>
</ul>
<pre><code>public interface ObjectFactory&lt;T&gt; {
   T getObject() throws BeansException;
}
</code></pre><ul>
<li>ObjectFactory&#xFF1A;</li>
<li>&#x5B83;&#x7684;&#x76EE;&#x7684;&#x4E5F;&#x662F;&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;&#x5DE5;&#x5382;&#xFF0C;&#x6765;&#x751F;&#x6210;Object&#xFF08;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x65B9;&#x6CD5;getObject())&#x3002;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x4E00;&#x822C;&#x88AB;&#x7528;&#x6765;&#xFF0C;&#x5305;&#x88C5;&#x4E00;&#x4E2A;factory&#xFF0C;&#x901A;&#x8FC7;&#x4E2A;&#x8FD9;&#x5DE5;&#x5382;&#x6765;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x65B0;&#x5B9E;&#x4F8B;&#xFF08;prototype&#x7C7B;&#x578B;)&#x3002;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x548C;FactoryBean&#x6709;&#x70B9;&#x50CF;&#xFF0C;&#x4F46;FactoryBean&#x7684;&#x5B9E;&#x73B0;&#x662F;&#x88AB;&#x5F53;&#x505A;&#x4E00;&#x4E2A;SPI&#xFF08;Service Provider Interface)&#x5B9E;&#x4F8B;&#x6765;&#x4F7F;&#x7528;&#x5728;BeanFactory&#x91CC;&#x9762;&#xFF1B;ObjectFactory&#x7684;&#x5B9E;&#x73B0;&#x4E00;&#x822C;&#x88AB;&#x7528;&#x6765;&#x6CE8;&#x5165;&#x5230;&#x5176;&#x5B83;Bean&#x4E2D;&#xFF0C;&#x4F5C;&#x4E3A;API&#x6765;&#x4F7F;&#x7528;&#x3002;&#x5C31;&#x50CF;ObjectFactoryCreatingFactoryBean&#x7684;&#x4F8B;&#x5B50;&#xFF0C;&#x5B83;&#x7684;&#x8FD4;&#x56DE;&#x503C;&#x5C31;&#x662F;&#x4E00;&#x4E2A;ObjectFactory&#xFF0C;&#x8FD9;&#x4E2A;ObjectFactory&#x88AB;&#x6CE8;&#x5165;&#x5230;&#x4E86;Bean&#x4E2D;&#xFF0C;&#x5728;Bean&#x901A;&#x8FC7;&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#x7684;&#x5B9E;&#x4F8B;&#xFF0C;&#x6765;&#x53D6;&#x5F97;&#x6211;&#x4EEC;&#x60F3;&#x8981;&#x7684;Bean&#x3002;</li>
<li>&#x603B;&#x7684;&#x6765;&#x8BF4;&#xFF0C;FactoryBean&#x548C;ObjectFactory&#x90FD;&#x662F;&#x7528;&#x6765;&#x53D6;&#x5F97;Bean&#xFF0C;&#x4F46;&#x4F7F;&#x7528;&#x7684;&#x65B9;&#x6CD5;&#x548C;&#x5730;&#x65B9;&#x4E0D;&#x540C;&#xFF0C;FactoryBean&#x88AB;&#x914D;&#x7F6E;&#x597D;&#x540E;&#xFF0C;Spring&#x8C03;&#x7528;getObject()&#x65B9;&#x6CD5;&#x6765;&#x53D6;&#x5F97;Bean&#xFF0C;ObjectFactory&#x914D;&#x7F6E;&#x597D;&#x540E;&#xFF0C;&#x5728;Bean&#x91CC;&#x9762;&#x53EF;&#x4EE5;&#x53D6;&#x5F97;ObjectFactory&#x5B9E;&#x4F8B;&#xFF0C;&#x9700;&#x8981;&#x6211;&#x4EEC;&#x624B;&#x52A8;&#x6765;&#x8C03;&#x7528;getObject()&#x6765;&#x53D6;&#x5F97;Bean&#x3002;<h2 id="initializingbean"><a name="initializingbean" class="plugin-anchor" href="#initializingbean"><i class="fa fa-link" aria-hidden="true"></i></a>InitializingBean</h2>
</li>
<li>InitializingBean&#x63A5;&#x53E3;&#x4E3A;bean&#x63D0;&#x4F9B;&#x4E86;&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;&#x7684;&#x65B9;&#x5F0F;&#xFF0C;&#x5B83;&#x53EA;&#x5305;&#x62EC;afterPropertiesSet&#x65B9;&#x6CD5;&#xFF0C;&#x51E1;&#x662F;&#x7EE7;&#x627F;&#x8BE5;&#x63A5;&#x53E3;&#x7684;&#x7C7B;&#xFF0C;&#x5728;&#x521D;&#x59CB;&#x5316;bean&#x7684;&#x65F6;&#x5019;&#x4F1A;&#x6267;&#x884C;&#x8BE5;&#x65B9;&#x6CD5;&#x3002;</li>
<li>AbstractBeanFactory#getBean</li>
</ul>
<pre><code>public Object getBean(String name) throws BeansException {
   return doGetBean(name, null, null, false);
}
</code></pre><ul>
<li>doGetBean</li>
<li>&#x6709;&#x4E09;&#x4E2A;&#x65B9;&#x6CD5;&#x975E;&#x5E38;&#x5173;&#x952E;&#xFF1A;getSingleton&#xFF0C;createBean&#x548C;getObjectForBeanInstance&#x3002;</li>
<li><p>protected <t> T doGetBean(</t></p>
<pre><code>final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)
throws BeansException {
</code></pre><p> final String beanName = transformedBeanName(name);
 Object bean;</p>
<p> // Eagerly check singleton cache for manually registered singletons.</p>
</li>
<li>// &#x68C0;&#x67E5;&#x7F13;&#x5B58;&#x4E2D;&#x6216;&#x8005;&#x5B9E;&#x4F8B;&#x5DE5;&#x5382;&#x4E2D;&#x662F;&#x5426;&#x6709;&#x5BF9;&#x5E94;&#x7684;&#x5B9E;&#x4F8B;&#xFF08;&#x89E3;&#x51B3;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x7684;&#x95EE;&#x9898;)</li>
<li>// Spring&#x521B;&#x5EFA;bean&#x7684;&#x539F;&#x5219;&#x662F;&#x4E0D;&#x7B49;bean&#x521B;&#x5EFA;&#x5B8C;&#x6210;&#x5C31;&#x4F1A;&#x5C06;&#x521B;&#x5EFA;bean&#x7684;ObjectFactory&#x63D0;&#x65E9;&#x66DD;&#x5149;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x5C06;ObjectFactory&#x52A0;&#x5165;&#x5230;&#x7F13;&#x5B58;&#x4E2D;&#xFF0C;&#x4E00;&#x65E6;&#x4E0B;&#x4E2A;bean&#x521B;&#x5EFA;&#x65F6;&#x9700;&#x8981;&#x4E0A;&#x4E2A;bean&#x5219;&#x76F4;&#x63A5;&#x4F7F;&#x7528;ObjectFactory&#x3002;</li>
<li>// &#x76F4;&#x63A5;&#x5C1D;&#x8BD5;&#x4ECE;&#x7F13;&#x5B58;&#x83B7;&#x53D6;&#x6216;&#x8005;&#x4ECE;singletonFactories&#x4E2D;&#x7684;ObjectFactory&#x4E2D;&#x83B7;&#x53D6;
 Object sharedInstance = getSingleton(beanName);
 if (sharedInstance != null &amp;&amp; args == null) {</li>
<li>// &#x5DF2;&#x7ECF;&#x521B;&#x5EFA;&#x8FC7;&#x4E86;<pre><code>if (logger.isDebugEnabled()) {
   if (isSingletonCurrentlyInCreation(beanName)) {
      logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName +
            &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);
   }
   else {
      logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);
   }
}
</code></pre></li>
<li>// &#x8FD4;&#x56DE;&#x5BF9;&#x5E94;&#x7684;&#x5B9E;&#x4F8B;&#xFF08;&#x4ECE;&#x7F13;&#x5B58;&#x4E2D;&#x53EA;&#x5F97;&#x5230;&#x4E86;bean&#x7684;&#x539F;&#x59CB;&#x72B6;&#x6001;&#xFF0C;&#x8FD8;&#x9700;&#x8981;&#x5BF9;bean&#x8FDB;&#x884C;&#x5B9E;&#x4F8B;&#x5316;)
bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
}
else {</li>
<li>// &#x6CA1;&#x6709;&#x521B;&#x5EFA;&#xFF0C;&#x9700;&#x8981;&#x521B;&#x5EFA;</li>
<li><p>// Fail if we&apos;re already creating this bean instance:</p>
<pre><code>// We&apos;re assumably within a circular reference.
if (isPrototypeCurrentlyInCreation(beanName)) {
   throw new BeanCurrentlyInCreationException(beanName);
}

// Check if bean definition exists in this factory.
BeanFactory parentBeanFactory = getParentBeanFactory();
</code></pre></li>
<li>// &#x5982;&#x679C;beanDefinitionMap&#xFF08;&#x5DF2;&#x7ECF;&#x52A0;&#x8F7D;&#x4E86;&#x7684;&#x7C7B;)&#x4E2D;&#x4E0D;&#x5305;&#x542B;beanName&#xFF0C;&#x5219;&#x5C1D;&#x8BD5;&#x4ECE;parentBeanFactory&#x5904;&#x7406;<pre><code>if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
   // Not found -&gt; check parent.
   String nameToLookup = originalBeanName(name);
   if (args != null) {
      // Delegation to parent with explicit args.
</code></pre></li>
<li><p>// &#x9012;&#x5F52;</p>
<pre><code>      return (T) parentBeanFactory.getBean(nameToLookup, args);
   }
   else {
      // No args -&gt; delegate to standard getBean method.
      return parentBeanFactory.getBean(nameToLookup, requiredType);
   }
}
// &#x4ECE;&#x8FD9;&#x91CC;&#x5F00;&#x59CB;&#x521B;&#x5EFA;bean&#xFF0C;&#x5148;&#x8FDB;&#x884C;&#x8BB0;&#x5F55;
if (!typeCheckOnly) {
   markBeanAsCreated(beanName);
}

try {
</code></pre></li>
<li><p>// &#x5C06;&#x5B58;&#x50A8;XML&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x7684;GenericBeanDefinition&#x8F6C;&#x6362;&#x4E3A;RootBeanDefinition&#xFF1B;&#x8F6C;&#x6362;&#x7684;&#x65F6;&#x5019;&#x5982;&#x679C;&#x7236;&#x7C7B;bean&#x4E0D;&#x4E3A;&#x7A7A;&#x7684;&#x8BDD;&#xFF0C;&#x90A3;&#x4E48;&#x4F1A;&#x5408;&#x5E76;&#x7236;&#x7C7B;&#x7684;&#x5C5E;&#x6027;&#x3002;
   final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
   checkMergedBeanDefinition(mbd, beanName, args);</p>
<p>   // Guarantee initialization of beans that the current bean depends on.     // &#x82E5;&#x5B58;&#x5728;&#x4F9D;&#x8D56;&#x5219;&#x9700;&#x8981;&#x9012;&#x5F52;&#x5B9E;&#x4F8B;&#x5316;&#x4F9D;&#x8D56;&#x7684;bean
   String[] dependsOn = mbd.getDependsOn();
   if (dependsOn != null) {</p>
<pre><code>  for (String dep : dependsOn) {
     if (isDependent(beanName, dep)) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
              &quot;Circular depends-on relationship between &apos;&quot; + beanName + &quot;&apos; and &apos;&quot; + dep + &quot;&apos;&quot;);
     }
</code></pre></li>
<li><p>// &#x7F13;&#x5B58;&#x4F9D;&#x8D56;&#x8C03;&#x7528;</p>
<pre><code>         registerDependentBean(dep, beanName);
         getBean(dep);
      }
   }

   // Create bean instance.
</code></pre></li>
<li>// &#x771F;&#x6B63;&#x7684;&#x521B;&#x5EFA;bean
   if (mbd.isSingleton()) {</li>
</ul>
<pre><code>    // &#x5355;&#x4F8B;
            sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {
               @Override
               public Object getObject() throws BeansException {
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  catch (BeansException ex) {
                     // Explicitly remove instance from singleton cache: It might have been put there
                     // eagerly by the creation process, to allow for circular reference resolution.
                     // Also remove any beans that received a temporary reference to the bean.
                     destroySingleton(beanName);
                     throw ex;
                  }
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }

         else if (mbd.isPrototype()) {
            // It&apos;s a prototype -&gt; create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
         else {
</code></pre><pre><code>    // &#x5728;&#x6307;&#x5B9A;&#x7684;scope&#x4E0A;&#x5B9E;&#x4F8B;&#x5316;bean
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException(&quot;No Scope registered for scope name &apos;&quot; + scopeName + &quot;&apos;&quot;);
            }
            try {
               Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() {
                  @Override
                  public Object getObject() throws BeansException {
                     beforePrototypeCreation(beanName);
                     try {
                        return createBean(beanName, mbd, args);
                     }
                     finally {
                        afterPrototypeCreation(beanName);
                     }
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; consider &quot; +
                     &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }

   // Check if required type matches the type of the actual bean instance.
   if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) {
      try {
         return getTypeConverter().convertIfNecessary(bean, requiredType);
      }
      catch (TypeMismatchException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type &apos;&quot; +
                  ClassUtils.getQualifiedName(requiredType) + &quot;&apos;&quot;, ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
</code></pre><pre><code>- 1) getSingleton(beanName)&#xFF08;&#x501F;&#x52A9;&#x7F13;&#x5B58;&#x6216;singletonFactories)
</code></pre><ul>
<li>getSingleton(beanName,true) - &gt; true&#x8868;&#x793A;&#x5141;&#x8BB8;&#x65E9;&#x671F;&#x4F9D;&#x8D56;</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x4ECE;singletonObjects&#x4E2D;&#x83B7;&#x53D6;&#xFF0C;&#x5B83;&#x662F;&#x4E00;&#x4E2A;&#x771F;&#x6B63;&#x7684;&#x7F13;&#x5B58;&#xFF0C;&#x6709;&#x5C31;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;</li>
<li>2)&#x83B7;&#x53D6;&#x4E0D;&#x5230;&#x518D;&#x4ECE;earlySingletonObjects&#x91CC;&#x9762;&#x83B7;&#x53D6;</li>
<li>3)&#x8FD8;&#x662F;&#x83B7;&#x53D6;&#x4E0D;&#x5230;&#xFF0C;&#x518D;&#x5C1D;&#x8BD5;&#x4ECE;singletonFactories&#x91CC;&#x9762;&#x83B7;&#x53D6;beanName&#x5BF9;&#x5E94;&#x7684;ObjectFactory&#xFF0C;&#x7136;&#x540E;&#x8C03;&#x7528;&#x8FD9;&#x4E2A;ObjectFactory&#x7684;getObject&#x6765;&#x83B7;&#x53D6;&#x4E4B;&#x524D;&#x521B;&#x5EFA;&#x7684;bean&#xFF0C;&#x5E76;&#x653E;&#x5230;earlySingletonObjects&#x91CC;&#x9762;&#x53BB;&#xFF0C;&#x5E76;&#x4E14;&#x4ECE;singletonFactories&#x4E2D;remove&#x6389;&#x8FD9;&#x4E2A;ObjectFactory&#x3002;</li>
</ul>
</li>
<li><p>&#x6210;&#x5458;&#x53D8;&#x91CF;Map&#xFF1A;</p>
<ul>
<li>1)singletonObjects&#x662F;beanName&#x4E0E;beanInstance&#x7684;Map&#xFF0C;&#x662F;&#x771F;&#x6B63;&#x7684;&#x7F13;&#x5B58;&#xFF0C;beanInstance&#x662F;&#x6784;&#x9020;&#x5B8C;&#x6BD5;&#x7684;&#xFF0C;&#x51E1;&#x662F;&#x6B63;&#x5E38;&#x5730;&#x6784;&#x9020;&#x5B8C;&#x6BD5;&#x7684;&#x5355;&#x4F8B;bean&#x90FD;&#x4F1A;&#x653E;&#x5165;&#x7F13;&#x5B58;&#x4E2D;&#x3002;</li>
<li>2)earlySingletonObjects&#x4E5F;&#x662F;beanName&#x4E0E;beanInstance&#x7684;Map&#xFF0C;beanInstance&#x662F;&#x5DF2;&#x7ECF;&#x8C03;&#x7528;&#x4E86;createBean&#x65B9;&#x6CD5;&#xFF0C;&#x4F46;&#x662F;&#x6CA1;&#x6709;&#x6E05;&#x9664;&#x52A0;&#x8F7D;&#x72B6;&#x6001;&#x548C;&#x52A0;&#x5165;&#x81F3;&#x7F13;&#x5B58;&#x7684;bean&#x3002;&#x4EC5;&#x5728;&#x5F53;&#x524D;bean&#x521B;&#x5EFA;&#x65F6;&#x5B58;&#x5728;&#xFF0C;&#x7528;&#x4E8E;&#x68C0;&#x6D4B;&#x4EE3;&#x7406;bean&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x3002;</li>
<li>3)singleFactories&#x662F;beanName&#x4E0E;ObjectFactory&#x7684;Map&#xFF0C;&#x4EC5;&#x5728;&#x5F53;&#x524D;bean&#x521B;&#x5EFA;&#x65F6;&#x5B58;&#x5728;&#xFF0C;&#x662F;&#x5C1A;&#x672A;&#x8C03;&#x7528;createBean&#x7684;bean&#x3002;&#x7528;&#x4E8E;setter&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x65F6;&#x5B9E;&#x73B0;&#x6CE8;&#x5165;&#x3002;</li>
<li>4)registeredSingletons&#xFF1A;&#x7528;&#x6765;&#x4FDD;&#x5B58;&#x5F53;&#x524D;&#x6240;&#x6709;&#x5DF2;&#x6CE8;&#x518C;&#x7684;bean&#x3002;</li>
</ul>
</li>
<li><p>singletonFactories&#x548C;earlySingletonObjects&#x90FD;&#x662F;&#x4E00;&#x4E2A;&#x4E34;&#x65F6;&#x5DE5;&#x3002;&#x5728;&#x6240;&#x6709;&#x7684;&#x5BF9;&#x8C61;&#x521B;&#x5EFA;&#x5B8C;&#x6BD5;&#x4E4B;&#x540E;&#xFF0C;&#x6B64;&#x4E24;&#x4E2A;&#x5BF9;&#x8C61;&#x7684;size&#x90FD;&#x4E3A;0&#x3002;</p>
</li>
<li>protected Object getSingleton(String beanName, boolean allowEarlyReference) {
 Object singletonObject = this.singletonObjects.get(beanName);
 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {<pre><code>synchronized (this.singletonObjects) {
   singletonObject = this.earlySingletonObjects.get(beanName);
   if (singletonObject == null &amp;&amp; allowEarlyReference) {
      ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
      if (singletonFactory != null) {
         singletonObject = singletonFactory.getObject();
         this.earlySingletonObjects.put(beanName, singletonObject);
         this.singletonFactories.remove(beanName);
      }
   }
}
</code></pre> }
 return (singletonObject != NULL_OBJECT ? singletonObject : null);
}</li>
</ul>
<pre><code>- 2) getSingleton(beanName,ObjectFactory)&#xFF08;&#x4ECE;&#x5934;&#x521B;&#x5EFA;&#x5355;&#x4F8B;bean)
</code></pre><ul>
<li>&#x4ECE;&#x5934;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x5355;&#x4F8B;&#x7684;bean&#x9700;&#x8981;&#x7ECF;&#x8FC7;getSingleton(beanName,ObjectFactory)&#x548C;createBean&#x4E24;&#x4E2A;&#x5173;&#x952E;&#x65B9;&#x6CD5;&#x3002;</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x68C0;&#x67E5;&#x7F13;&#x5B58;&#x662F;&#x5426;&#x5DF2;&#x7ECF;&#x52A0;&#x8F7D;&#x8FC7;</li>
<li>2)&#x82E5;&#x6CA1;&#x6709;&#x52A0;&#x8F7D;&#xFF0C;&#x5219;&#x8BB0;&#x5F55;beanName&#x7684;&#x6B63;&#x5728;&#x52A0;&#x8F7D;&#x72B6;&#x6001;</li>
<li>3)&#x52A0;&#x8F7D;&#x5355;&#x4F8B;&#x524D; &#x8BB0;&#x5F55;&#x52A0;&#x8F7D;&#x72B6;&#x6001;</li>
<li>4)&#x901A;&#x8FC7;ObjectFactory&#x7684;getObject&#x65B9;&#x6CD5;&#x5B9E;&#x4F8B;&#x5316;bean</li>
<li>5)&#x52A0;&#x8F7D;&#x5355;&#x4F8B;&#x540E; &#x6E05;&#x9664;&#x52A0;&#x8F7D;&#x72B6;&#x6001;</li>
<li>6)&#x5C06;&#x7ED3;&#x679C;&#x8BB0;&#x5F55;&#x81F3;&#x7F13;&#x5B58;&#x5E76;&#x5220;&#x9664;&#x52A0;&#x8F7D;bean&#x8FC7;&#x7A0B;&#x4E2D;&#x6240;&#x8BB0;&#x5F55;&#x7684;&#x5404;&#x79CD;&#x8F85;&#x52A9;&#x72B6;&#x6001;</li>
<li>7)&#x8FD4;&#x56DE;&#x5904;&#x7406;&#x7ED3;&#x679C;</li>
</ul>
</li>
</ul>
<pre><code>public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
   Assert.notNull(beanName, &quot;&apos;beanName&apos; must not be null&quot;);
   synchronized (this.singletonObjects) {
</code></pre><ul>
<li>// &#x68C0;&#x67E5;&#x5BF9;&#x5E94;&#x7684;bean&#x662F;&#x5426;&#x5DF2;&#x7ECF;&#x88AB;&#x52A0;&#x8F7D;&#x8FC7;<pre><code>Object singletonObject = this.singletonObjects.get(beanName);
if (singletonObject == null) {
</code></pre></li>
<li>// &#x6CA1;&#x6709;&#x88AB;&#x52A0;&#x8F7D;&#x8FC7;<pre><code>   if (this.singletonsCurrentlyInDestruction) {
      throw new BeanCreationNotAllowedException(beanName,
            &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
            &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);
   }
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Creating shared instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);
   }
</code></pre></li>
<li>// &#x8BB0;&#x5F55;&#x52A0;&#x8F7D;&#x72B6;&#x6001;
   beforeSingletonCreation(beanName);
   boolean newSingleton = false;
   boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
   if (recordSuppressedExceptions) {<pre><code>  this.suppressedExceptions = new LinkedHashSet&lt;Exception&gt;();
</code></pre>   }
   try {</li>
<li>// &#x521D;&#x59CB;&#x5316;bean&#xFF0C;&#x5728;&#x8FD9;&#x91CC;&#x8C03;&#x7528;&#x4E86;createBean&#x65B9;&#x6CD5;<pre><code>  singletonObject = singletonFactory.getObject();
  newSingleton = true;
</code></pre>   }
   catch (IllegalStateException ex) {<pre><code>  // Has the singleton object implicitly appeared in the meantime -&gt;
  // if yes, proceed with it since the exception indicates that state.
  singletonObject = this.singletonObjects.get(beanName);
  if (singletonObject == null) {
     throw ex;
  }
</code></pre>   }
   catch (BeanCreationException ex) {<pre><code>  if (recordSuppressedExceptions) {
     for (Exception suppressedException : this.suppressedExceptions) {
        ex.addRelatedCause(suppressedException);
     }
  }
  throw ex;
</code></pre>   }
   finally {<pre><code>  if (recordSuppressedExceptions) {
     this.suppressedExceptions = null;
  }
</code></pre></li>
<li>// &#x6E05;&#x9664;&#x52A0;&#x8F7D;&#x72B6;&#x6001;<pre><code>  afterSingletonCreation(beanName);
</code></pre>   }
   if (newSingleton) {</li>
<li><p>// &#x52A0;&#x5165;&#x7F13;&#x5B58;</p>
<pre><code>  addSingleton(beanName, singletonObject);
</code></pre><p>   }
}
return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
}</p>
<ul>
<li>2.1) beforeSingletonCreation &#xFF08;&#x8BB0;&#x5F55;&#x52A0;&#x8F7D;&#x72B6;&#x6001;)</li>
</ul>
</li>
<li>&#x8BB0;&#x5F55;&#x52A0;&#x8F7D;&#x72B6;&#x6001;&#xFF0C;&#x901A;&#x8FC7;this.singletonsCurrentlyInCreation.add(beanName)&#x5C06;&#x5F53;&#x524D;&#x6B63;&#x5728;&#x521B;&#x5EFA;&#x7684;bean&#x8BB0;&#x5F55;&#x5728;&#x7F13;&#x5B58;&#x4E2D;&#xFF0C;&#x8FD9;&#x6837;&#x4FBF;&#x53EF;&#x4EE5;&#x5BF9;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x8FDB;&#x884C;&#x68C0;&#x6D4B;&#x3002;</li>
<li><p>protected void beforeSingletonCreation(String beanName) {
 if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.add(beanName)) {</p>
<pre><code>throw new BeanCurrentlyInCreationException(beanName);
</code></pre><p> }
}</p>
<ul>
<li>2.2) afterSingletonCreation&#xFF08;&#x6E05;&#x9664;&#x52A0;&#x8F7D;&#x72B6;&#x6001;)</li>
</ul>
</li>
<li>&#x5F53;bean&#x52A0;&#x8F7D;&#x7ED3;&#x675F;&#x540E;&#x9700;&#x8981;&#x79FB;&#x9664;&#x7F13;&#x5B58;&#x4E2D;&#x5BF9;&#x8BE5;bean&#x7684;&#x6B63;&#x5728;&#x52A0;&#x8F7D;&#x72B6;&#x6001;&#x7684;&#x8BB0;&#x5F55;&#x3002;</li>
<li>protected void afterSingletonCreation(String beanName) {
 if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.remove(beanName)) {<pre><code>throw new IllegalStateException(&quot;Singleton &apos;&quot; + beanName + &quot;&apos; isn&apos;t currently in creation&quot;);
</code></pre> }
}<ul>
<li>2.3) addSingleton&#xFF08;&#x7ED3;&#x679C;&#x8BB0;&#x5F55;&#x81F3;&#x7F13;&#x5B58;)</li>
</ul>
</li>
<li>&#x5C06;&#x7ED3;&#x679C;&#x8BB0;&#x5F55;&#x81F3;&#x7F13;&#x5B58;&#x4E2D;&#x5E76;&#x5220;&#x9664;&#x52A0;&#x8F7D;bean&#x8FC7;&#x7A0B;&#x4E2D;&#x6240;&#x8BB0;&#x5F55;&#x7684;&#x5404;&#x79CD;&#x8F85;&#x52A9;&#x72B6;&#x6001;</li>
<li>protected void addSingleton(String beanName, Object singletonObject) {
 synchronized (this.singletonObjects) {<pre><code>this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
this.singletonFactories.remove(beanName);
this.earlySingletonObjects.remove(beanName);
this.registeredSingletons.add(beanName);
</code></pre> }
}</li>
<li></li>
<li><ul>
<li>3) createBean&#xFF08;&#x521B;&#x5EFA;&#x5355;&#x4F8B;&#x6216;&#x591A;&#x4F8B;&#x7684;bean&#xFF0C;&#x5728;3&#x4E2D;&#x6709;&#x88AB;&#x8C03;&#x7528;)</li>
</ul>
</li>
<li><p>protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {
 if (logger.isDebugEnabled()) {</p>
<pre><code>logger.debug(&quot;Creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);
</code></pre><p> }
 RootBeanDefinition mbdToUse = mbd;</p>
<p> // Make sure bean class is actually resolved at this point, and
 // clone the bean definition in case of a dynamically resolved Class
 // which cannot be stored in the shared merged bean definition.</p>
</li>
<li><p>// &#x9501;&#x5B9A;class&#xFF0C;&#x6839;&#x636E;&#x8BBE;&#x7F6E;&#x7684;class&#x5C5E;&#x6027;&#x6216;&#x8005;&#x6839;&#x636E;className&#x6765;&#x89E3;&#x6790;Class
 Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
 if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {</p>
<pre><code>mbdToUse = new RootBeanDefinition(mbd);
mbdToUse.setBeanClass(resolvedClass);
</code></pre><p> }</p>
<p> // Prepare method overrides.
 try {</p>
</li>
<li><p>// &#x9A8C;&#x8BC1;&#x53CA;&#x51C6;&#x5907;&#x8986;&#x76D6;&#x7684;&#x65B9;&#x6CD5; </p>
<pre><code>mbdToUse.prepareMethodOverrides();
</code></pre><p> }
 catch (BeanDefinitionValidationException ex) {</p>
<pre><code>throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
      beanName, &quot;Validation of method overrides failed&quot;, ex);
</code></pre><p> }</p>
<p> try {</p>
<pre><code>// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
</code></pre></li>
<li>// &#x7ED9;BeanPostProcessor&#x4E00;&#x4E2A;&#x673A;&#x4F1A;&#x6765;&#x8FD4;&#x56DE;&#x4EE3;&#x7406;&#x6765;&#x66FF;&#x4EE3;&#x771F;&#x6B63;&#x7684;&#x5B9E;&#x4F8B;<pre><code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
if (bean != null) {
   return bean;
}
</code></pre> }
 catch (Throwable ex) {<pre><code>throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
      &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
</code></pre> }
 // &#x5B9E;&#x9645;&#x521B;&#x5EFA;bean
 Object beanInstance = doCreateBean(beanName, mbdToUse, args);
 if (logger.isDebugEnabled()) {<pre><code>logger.debug(&quot;Finished creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);
</code></pre> }
 return beanInstance;
}<ul>
<li>3.1) AbstractBeanDefinition#prepareMethodOverrides&#xFF08;&#x51B3;&#x5B9A;&#x5B9E;&#x4F8B;&#x5316;&#x7B56;&#x7565;-&gt;&#x53CD;&#x5C04; or CGLIB)</li>
</ul>
</li>
<li>&#x9A8C;&#x8BC1;&#x53CA;&#x51C6;&#x5907;&#x8986;&#x76D6;&#x7684;&#x65B9;&#x6CD5;</li>
<li>&#x5728;Spring&#x914D;&#x7F6E;&#x4E2D;&#x5B58;&#x5728;lookup-method&#x548C;replace-method&#x4E24;&#x4E2A;&#x914D;&#x7F6E;&#x529F;&#x80FD;&#xFF0C;&#x800C;&#x8FD9;&#x4E24;&#x4E2A;&#x914D;&#x7F6E;&#x7684;&#x52A0;&#x8F7D;&#x5176;&#x5B9E;&#x5C31;&#x662F;&#x5C06;&#x914D;&#x7F6E;&#x7EDF;&#x4E00;&#x5B58;&#x653E;&#x5728;BeanDefinition&#x4E2D;&#x7684;methodOverrides&#x5C5E;&#x6027;&#x91CC;&#xFF0C;&#x8FD9;&#x4E24;&#x4E2A;&#x529F;&#x80FD;&#x5B9E;&#x73B0;&#x539F;&#x7406;&#x5176;&#x5B9E;&#x662F;&#x5728;bean&#x5B9E;&#x4F8B;&#x5316;&#x7684;&#x65F6;&#x5019;&#x5982;&#x679C;&#x68C0;&#x6D4B;&#x5230;&#x5B58;&#x5728;methodOverrides&#x5C5E;&#x6027;&#xFF0C;&#x4F1A;&#x52A8;&#x6001;&#x5730;&#x4E3A;&#x5F53;&#x524D;bean&#x751F;&#x6210;&#x4EE3;&#x7406;&#x5E76;&#x4F7F;&#x7528;&#x5BF9;&#x5E94;&#x7684;&#x62E6;&#x622A;&#x5668;&#x4E3A;bean&#x505A;&#x589E;&#x5F3A;&#x5904;&#x7406;&#xFF0C;&#x76F8;&#x5173;&#x903B;&#x8F91;&#x5B9E;&#x73B0;&#x5728;bean&#x7684;&#x5B9E;&#x4F8B;&#x5316;&#x90E8;&#x5206;&#x8BE6;&#x7EC6;&#x4ECB;&#x7ECD;&#x3002;</li>
</ul>
<pre><code>public void prepareMethodOverrides() throws BeanDefinitionValidationException {
   // Check that lookup methods exists.
   MethodOverrides methodOverrides = getMethodOverrides();
   if (!methodOverrides.isEmpty()) {
      Set&lt;MethodOverride&gt; overrides = methodOverrides.getOverrides();
      synchronized (overrides) {
         for (MethodOverride mo : overrides) {
            prepareMethodOverride(mo);
         }
      }
   }
}
</code></pre><pre><code>- 3.1.1) prepareMethodOverride
</code></pre><ul>
<li>protected void prepareMethodOverride(MethodOverride mo) throws BeanDefinitionValidationException {<ul>
<li>//&#x83B7;&#x53D6;&#x5BF9;&#x5E94;&#x7C7B;&#x4E2D;&#x5BF9;&#x5E94;&#x65B9;&#x6CD5;&#x540D;&#x7684;&#x4E2A;&#x6570;
int count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());
if (count == 0) {
throw new BeanDefinitionValidationException(<pre><code>  &quot;Invalid method override: no method with name &apos;&quot; + mo.getMethodName() +
  &quot;&apos; on class [&quot; + getBeanClassName() + &quot;]&quot;);
</code></pre>}
else if (count == 1) {
// Mark override as not overloaded, to avoid the overhead of arg type checking.</li>
</ul>
</li>
<li>// &#x6807;&#x8BB0;MethodOverride&#x6682;&#x672A;&#x88AB;&#x8986;&#x76D6;&#xFF0C;&#x907F;&#x514D;&#x53C2;&#x6570;&#x7C7B;&#x578B;&#x68C0;&#x67E5;&#x7684;&#x5F00;&#x9500;<pre><code>mo.setOverloaded(false);
</code></pre> }
}<ul>
<li>3.2) resolveBeforeInstantiation&#xFF08;&#x53EF;&#x80FD;&#x4F1A;&#x521B;&#x5EFA;&#x4EE3;&#x7406;&#x8FC7;&#x7684;bean)</li>
</ul>
</li>
<li>&#x5982;&#x679C;&#x8BE5;&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;bean&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x5219;&#x8DF3;&#x8FC7;&#x540E;&#x7EED;&#x5B9E;&#x9645;&#x521B;&#x5EFA;bean&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x4EE3;&#x7406;&#x540E;&#x7684;bean&#x3002;</li>
<li>&#x4E0E;AOP&#x6709;&#x5173;&#xFF01;</li>
<li><p>protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
 Object bean = null;
 if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {</p>
<pre><code>// Make sure bean class is actually resolved at this point.
if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
   Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);
   if (targetType != null) {
      bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
      if (bean != null) {
         bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
      }
   }
}
mbd.beforeInstantiationResolved = (bean != null);
</code></pre><p> }
 return bean;
}</p>
<ul>
<li>3.2.1) applyBeanPostProcessorsBeforeInstantiation&#xFF08;&#x5B9E;&#x4F8B;&#x5316;&#x524D;&#x7684;&#x540E;&#x5904;&#x7406;&#x5668;&#x5E94;&#x7528;)</li>
</ul>
</li>
<li><p>protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {
 for (BeanPostProcessor bp : getBeanPostProcessors()) {</p>
<pre><code>if (bp instanceof InstantiationAwareBeanPostProcessor) {
   InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
   Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
   if (result != null) {
      return result;
   }
}
</code></pre><p> }
 return null;
}</p>
<ul>
<li>3.2.2) applyBeanPostProcessorsAfterInitialization&#xFF08;&#x5B9E;&#x4F8B;&#x5316;&#x540E;&#x7684;&#x540E;&#x5904;&#x7406;&#x5668;&#x5E94;&#x7528;)</li>
</ul>
</li>
<li>Spring&#x4E2D;&#x7684;&#x89C4;&#x5219;&#x662F;&#x5728;bean&#x7684;&#x521D;&#x59CB;&#x5316;&#x540E;&#x5C3D;&#x53EF;&#x80FD;&#x4FDD;&#x8BC1;&#x5C06;&#x6CE8;&#x518C;&#x7684;&#x540E;&#x5904;&#x7406;&#x5668;&#x7684;postProcessAfterInitialization&#x65B9;&#x6CD5;&#x5E94;&#x7528;&#x5230;&#x8BE5;bean&#x4E2D;&#xFF0C;&#x56E0;&#x4E3A;&#x5982;&#x679C;&#x8FD4;&#x56DE;&#x7684;bean&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x90A3;&#x4E48;&#x4FBF;&#x4E0D;&#x4F1A;&#x518D;&#x6B21;&#x7ECF;&#x5386;&#x666E;&#x901A;bean&#x7684;&#x521B;&#x5EFA;&#x8FC7;&#x7A0B;&#x3002;</li>
</ul>
<pre><code>public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
      throws BeansException {

   Object result = existingBean;
   for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
      result = beanProcessor.postProcessAfterInitialization(result, beanName);
      if (result == null) {
         return result;
      }
   }
   return result;
}
</code></pre><ul>
<li><ul>
<li>3.3) doCreateBean&#xFF08;&#x521B;&#x5EFA;&#x5E38;&#x89C4;bean)</li>
</ul>
</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x5982;&#x679C;&#x662F;&#x5355;&#x4F8B;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x9996;&#x5148;&#x6E05;&#x9664;&#x7F13;&#x5B58;factoryBeanInstanceCache</li>
<li>2)&#x5B9E;&#x4F8B;&#x5316;bean&#xFF0C;&#x5C06;BeanDefinition&#x8F6C;&#x6362;&#x4E3A;BeanWrapper&#x3002;</li>
</ul>
</li>
<li>&#x8F6C;&#x6362;&#x8FC7;&#x7A0B;&#xFF1A;</li>
<li>&#x5982;&#x679C;&#x5B58;&#x5728;&#x5DE5;&#x5382;&#x65B9;&#x6CD5;&#xFF0C;&#x5219;&#x4F7F;&#x7528;&#x5DE5;&#x5382;&#x65B9;&#x6CD5;&#x8FDB;&#x884C;&#x521D;&#x59CB;&#x5316;</li>
<li>&#x4E00;&#x4E2A;&#x7C7B;&#x6709;&#x591A;&#x4E2A;&#x6784;&#x9020;&#x51FD;&#x6570;&#xFF0C;&#x6BCF;&#x4E2A;&#x6784;&#x9020;&#x51FD;&#x6570;&#x90FD;&#x6709;&#x4E0D;&#x540C;&#x7684;&#x53C2;&#x6570;&#xFF0C;&#x6240;&#x4EE5;&#x9700;&#x8981;&#x6839;&#x636E;&#x53C2;&#x6570;&#x9501;&#x5B9A;&#x6784;&#x9020;&#x51FD;&#x6570;&#x5E76;&#x8FDB;&#x884C;&#x521D;&#x59CB;&#x5316;</li>
<li>&#x5982;&#x679C;&#x65E2;&#x4E0D;&#x5B58;&#x5728;&#x5DE5;&#x5382;&#x65B9;&#x6CD5;&#x4E5F;&#x4E0D;&#x5B58;&#x5728;&#x5E26;&#x6709;&#x53C2;&#x6570;&#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#xFF0C;&#x5219;&#x4F7F;&#x7528;&#x9ED8;&#x8BA4;&#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#x8FDB;&#x884C;bean&#x7684;&#x521D;&#x59CB;&#x5316;&#x3002;<ul>
<li>3)MergedBeanDefinitionPostProcessor&#x7684;&#x5E94;&#x7528;</li>
</ul>
</li>
<li>bean&#x5408;&#x5E76;&#x540E;&#x7684;&#x5904;&#x7406;&#xFF0C;Autowired&#x6CE8;&#x89E3;&#x6B63;&#x662F;&#x901A;&#x8FC7;&#x6B64;&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#x8BF8;&#x5982;&#x7C7B;&#x578B;&#x7684;&#x9884;&#x89E3;&#x6790;&#x3002;<ul>
<li>4)&#x6DFB;&#x52A0;singletonFactories&#x7F13;&#x5B58;</li>
<li>5)&#x5C5E;&#x6027;&#x586B;&#x5145;</li>
<li>6)&#x4EE3;&#x7406;bean&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x68C0;&#x67E5;&#xFF0C;&#x5BF9;&#x4E8E;&#x5DF2;&#x52A0;&#x8F7D;&#x7684;bean&#xFF0C;&#x68C0;&#x6D4B;&#x662F;&#x5426;&#x5DF2;&#x7ECF;&#x51FA;&#x73B0;&#x4E86;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF0C;&#x5E76;&#x5224;&#x65AD;&#x662F;&#x5426;&#x9700;&#x8981;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002;&#xFF08;&#x4EC5;&#x9488;&#x5BF9;&#x4E8E;&#x5F53;&#x524D;bean&#x5728;initializeBean&#x4E2D;&#x88AB;&#x4EE3;&#x7406;&#x8FC7;&#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x6B63;&#x5E38;&#x7684;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x5728;&#x6B64;&#x4E4B;&#x524D;&#x5C31;&#x5DF2;&#x7ECF;&#x88AB;&#x68C0;&#x6D4B;&#x51FA;&#x6765;&#x7684;&#xFF0C;&#x53EA;&#x6709;&#x4EE3;&#x7406;&#x540E;&#x7684;bean&#x7684;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x662F;&#x5728;&#x8FD9;&#x91CC;&#x68C0;&#x67E5;&#x7684;)</li>
<li>7)&#x6CE8;&#x518C;DisposableBean</li>
</ul>
</li>
<li>&#x5982;&#x679C;&#x914D;&#x7F6E;&#x4E86;destroy-method&#xFF0C;&#x8FD9;&#x91CC;&#x9700;&#x8981;&#x6CE8;&#x518C;&#x4EE5;&#x4FBF;&#x4E8E;&#x5728;&#x9500;&#x6BC1;&#x65F6;&#x5019;&#x8C03;&#x7528;&#x3002;<ul>
<li>8)&#x5B8C;&#x6210;&#x521B;&#x5EFA;&#x5E76;&#x8FD4;&#x56DE;</li>
</ul>
</li>
<li><p>protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</p>
<pre><code>throws BeanCreationException {
</code></pre><p> // Instantiate the bean.
 BeanWrapper instanceWrapper = null;
 if (mbd.isSingleton()) {</p>
<pre><code>instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
</code></pre><p> }</p>
</li>
<li><p>// &#x6839;&#x636E;&#x6307;&#x5B9A;bean&#x4F7F;&#x7528;&#x5BF9;&#x5E94;&#x7684;&#x7B56;&#x7565;&#x521B;&#x5EFA;&#x65B0;&#x7684;&#x5B9E;&#x4F8B;&#xFF0C;&#x5982;&#xFF1A;&#x5DE5;&#x5382;&#x65B9;&#x6CD5;&#xFF1B;&#x6784;&#x9020;&#x5668;&#x6CE8;&#x5165;&#xFF1B;&#x7B80;&#x5355;&#x521D;&#x59CB;&#x5316;
 if (instanceWrapper == null) {</p>
<pre><code>instanceWrapper = createBeanInstance(beanName, mbd, args);
</code></pre><p> }
 final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
 Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);
 mbd.resolvedTargetType = beanType;</p>
<p> // Allow post-processors to modify the merged bean definition.
 synchronized (mbd.postProcessingLock) {</p>
<pre><code>if (!mbd.postProcessed) {
   try {
      applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Post-processing of merged bean definition failed&quot;, ex);
   }
   mbd.postProcessed = true;
}
</code></pre><p> }</p>
<p> // Eagerly cache singletons to be able to resolve circular references
 // even when triggered by lifecycle interfaces like BeanFactoryAware.</p>
</li>
<li>// &#x662F;&#x5426;&#x9700;&#x8981;&#x63D0;&#x65E9;&#x66DD;&#x5149;&#xFF1A;&#x5355;&#x4F8B;&amp;&amp;&#x5141;&#x8BB8;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&amp;&amp;&#x5F53;&#x524D;bean&#x6B63;&#x5728;&#x521B;&#x5EFA;&#x4E2D;</li>
<li>// &#x68C0;&#x6D4B;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;
 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;<pre><code>   isSingletonCurrentlyInCreation(beanName));
</code></pre> if (earlySingletonExposure) {<pre><code>if (logger.isDebugEnabled()) {
   logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName +
         &quot;&apos; to allow for resolving potential circular references&quot;);
}
</code></pre></li>
<li>// &#x653E;&#x5165;singletonFactories&#xFF0C;&#x4E0B;&#x6B21;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#x5F53;&#x524D;bean&#x65F6;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;</li>
</ul>
<pre><code>addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() {
         @Override
         public Object getObject() throws BeansException {
</code></pre><ul>
<li>// &#x5BF9;bean&#x518D;&#x4E00;&#x6B21;&#x4F9D;&#x8D56;&#x5F15;&#x7528;&#xFF0C;&#x4E3B;&#x8981;&#x5E94;&#x7528;SmartInstantiationAware BeanPostProcessor &#xFF0C;&#x5176;&#x4E2D;AOP&#x5C31;&#x662F;&#x5728;&#x8FD9;&#x91CC;&#x5C06;advice&#x52A8;&#x6001;&#x7EC7;&#x5165;bean&#x4E2D;&#xFF0C;&#x82E5;&#x6CA1;&#x6709;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;bean&#xFF0C;&#x4E0D;&#x505A;&#x4EFB;&#x4F55;&#x5904;&#x7406;<pre><code>  return getEarlyBeanReference(beanName, mbd, bean);
</code></pre>   }
});
}
// &#x586B;&#x5145;bean&#xFF0C;&#x5C06;&#x5C5E;&#x6027;&#x503C;&#x6CE8;&#x5165;
// Initialize the bean instance.
Object exposedObject = bean;
try {</li>
<li>// 3.3.3<pre><code>populateBean(beanName, mbd, instanceWrapper);
if (exposedObject != null) {
</code></pre></li>
<li>// 3.3.4</li>
<li>// &#x8C03;&#x7528;&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;&#xFF0C;&#x6BD4;&#x5982;init-method</li>
<li>// &#x6CE8;&#x610F;&#x8FD9;&#x91CC;&#x662F;&#x91CD;&#x65B0;&#x8D4B;&#x503C;&#xFF0C;&#x56E0;&#x4E3A;&#x521D;&#x59CB;&#x5316;&#x4F1A;&#x8C03;&#x7528;BeanPostProcessor&#xFF0C;&#x53EF;&#x80FD;&#x4F1A;&#x8FD4;&#x56DE;&#x4EE3;&#x7406;&#x5BF9;&#x8C61;<pre><code>   exposedObject = initializeBean(beanName, exposedObject, mbd);
}
</code></pre> }
 catch (Throwable ex) {<pre><code>if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
   throw (BeanCreationException) ex;
}
else {
   throw new BeanCreationException(
         mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
}
</code></pre> }
 // &#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x68C0;&#x67E5;
 if (earlySingletonExposure) {<pre><code>Object earlySingletonReference = getSingleton(beanName, false);
</code></pre></li>
<li>// &#x5982;&#x679C;singletonObjects&#xFF08;&#x7F13;&#x5B58;)&#x4E2D;&#x5B58;&#x5728;&#x5F53;&#x524D;bean&#xFF0C;earlySingletonReference&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x5B83;&#x6307;&#x5411;&#x7684;&#x662F;&#x7F13;&#x5B58;&#x4E2D;&#x7684;&#x5F53;&#x524D;bean&#xFF0C;&#x4F46;&#x672A;&#x5FC5;&#x548C;&#x5F53;&#x524D;bean&#x662F;&#x540C;&#x4E00;&#x4E2A;&#xFF0C;&#x56E0;&#x4E3A;&#x4E0A;&#x9762;initializeBean&#x65F6;&#x53EF;&#x80FD;&#x4F1A;&#x8FD4;&#x56DE;&#x4EE3;&#x7406;&#x540E;&#x7684;bean<pre><code>if (earlySingletonReference != null) {
   if (exposedObject == bean) {
      exposedObject = earlySingletonReference;
   }
</code></pre></li>
<li>// bean&#x4E0D;&#x540C;&#xFF0C;&#x8BF4;&#x660E;&#x4F7F;&#x7528;&#x52A8;&#x6001;&#x4EE3;&#x7406;&#x5BF9;&#x5176;&#x8FDB;&#x884C;&#x4E86;&#x589E;&#x5F3A;&#xFF0C;&#x8FD9;&#x662F;&#x4E0D;&#x88AB;&#x5141;&#x8BB8;&#x7684;</li>
<li>// &#x56E0;&#x4E3A;&#x5176;&#x4ED6;bean&#x4F9D;&#x8D56;&#x4E8E;&#x5F53;&#x524D;bean&#xFF0C;&#x6CE8;&#x5165;&#x7684;&#x662F;&#x4ECE;singletonFactories&#x4E2D;&#x53D6;&#x51FA;&#x6765;&#x7684;&#xFF0C;&#x5E76;&#x4E0D;&#x662F;&#x5F53;&#x524D;bean&#xFF08;&#x4EE3;&#x7406;&#x540E;&#x7684;)<pre><code>   else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
      String[] dependentBeans = getDependentBeans(beanName);
      Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);
      for (String dependentBean : dependentBeans) {
         if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
            actualDependentBeans.add(dependentBean);
         }
      }
</code></pre></li>
<li><p>// &#x56E0;&#x4E3A;bean&#x521B;&#x5EFA;&#x540E;&#x5B83;&#x6240;&#x4F9D;&#x8D56;&#x7684;bean&#x4E00;&#x5B9A;&#x662F;&#x5DF2;&#x7ECF;&#x521B;&#x5EFA;&#x7684;&#xFF0C;actualDependentBeans&#x4E0D;&#x4E3A;&#x7A7A;&#x8868;&#x793A;&#x5F53;&#x524D;bean&#x521B;&#x5EFA;&#x540E;&#x5B83;&#x4F9D;&#x8D56;&#x7684;bean&#x5374;&#x6CA1;&#x6709;&#x5168;&#x90E8;&#x521B;&#x5EFA;&#x5B8C;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#x5B58;&#x5728;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;</p>
<pre><code>      if (!actualDependentBeans.isEmpty()) {
         throw new BeanCurrentlyInCreationException(beanName,
               &quot;Bean with name &apos;&quot; + beanName + &quot;&apos; has been injected into other beans [&quot; +
               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
               &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
               &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
               &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
               &quot;&apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for example.&quot;);
      }
   }
}
</code></pre><p> }
 // &#x6CE8;&#x518C;DisposableBean
 // Register bean as disposable.
 try {</p>
<pre><code>registerDisposableBeanIfNecessary(beanName, bean, mbd);
</code></pre><p> }
 catch (BeanDefinitionValidationException ex) {</p>
<pre><code>throw new BeanCreationException(
      mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
</code></pre><p> }</p>
<p> return exposedObject;
}</p>
<ul>
<li>3.3.1) createBeanInstance&#xFF08;&#x5B9E;&#x4F8B;&#x5316;bean)</li>
</ul>
</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x5982;&#x679C;&#x5728;RootBeanDefinition&#x4E2D;&#x5B58;&#x5728;factoryMethodName&#x5C5E;&#x6027;&#xFF0C;&#x6216;&#x8005;&#x8BF4;&#x5728;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#x914D;&#x7F6E;&#x4E86;factory-method&#xFF0C;&#x90A3;&#x4E48;Spring&#x4F1A;&#x5C1D;&#x8BD5;&#x4F7F;&#x7528;instantiateUsingFactoryMethod&#x65B9;&#x6CD5;&#x6839;&#x636E;RootBeanDefinition&#x4E2D;&#x7684;&#x914D;&#x7F6E;&#x751F;&#x6210;bean&#x7684;&#x5B9E;&#x4F8B;&#x3002;</li>
<li>2)&#x89E3;&#x6790;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x5E76;&#x8FDB;&#x884C;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x7684;&#x5B9E;&#x4F8B;&#x5316;&#x3002;&#x56E0;&#x4E3A;&#x4E00;&#x4E2A;bean&#x5BF9;&#x5E94;&#x7684;&#x7C7B;&#x4E2D;&#x53EF;&#x80FD;&#x4F1A;&#x6709;&#x591A;&#x4E2A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#xFF0C;&#x800C;&#x6BCF;&#x4E2A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x7684;&#x53C2;&#x6570;&#x4E0D;&#x540C;&#xFF0C;Spring&#x518D;&#x6839;&#x636E;&#x53C2;&#x6570;&#x53CA;&#x7C7B;&#x578B;&#x53BB;&#x5224;&#x65AD;&#x6700;&#x7EC8;&#x4F1A;&#x4F7F;&#x7528;&#x54EA;&#x4E2A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x8FDB;&#x884C;&#x5B9E;&#x4F8B;&#x5316;&#x3002;&#x4F46;&#x662F;&#xFF0C;&#x5224;&#x65AD;&#x7684;&#x8FC7;&#x7A0B;&#x662F;&#x4E2A;&#x6BD4;&#x8F83;&#x6D88;&#x8017;&#x6027;&#x80FD;&#x7684;&#x6B65;&#x9AA4;&#xFF0C;&#x6240;&#x4EE5;&#x91C7;&#x7528;&#x7F13;&#x5B58;&#x673A;&#x5236;&#xFF0C;&#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x89E3;&#x6790;&#x8FC7;&#xFF0C;&#x5219;&#x4E0D;&#x9700;&#x8981;&#x91CD;&#x590D;&#x89E3;&#x6790;&#x800C;&#x662F;&#x76F4;&#x63A5;&#x4ECE;RootBeanDefinition&#x4E2D;&#x7684;&#x5C5E;&#x6027;resolvedConstructorOrFactoryMethod&#x7F13;&#x5B58;&#x7684;&#x503C;&#x53BB;&#x53D6;&#xFF0C;&#x5426;&#x5219;&#x9700;&#x8981;&#x518D;&#x6B21;&#x89E3;&#x6790;&#xFF0C;&#x5E76;&#x5C06;&#x89E3;&#x6790;&#x7684;&#x7ED3;&#x679C;&#x6DFB;&#x52A0;&#x81F3;RootBeanDefinition&#x4E2D;&#x7684;&#x5C5E;&#x6027;resolvedConstructorOrFactoryMethod&#x3002;</li>
</ul>
</li>
<li>protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {
 // Make sure bean class is actually resolved at this point.</li>
</ul>
<pre><code>// &#x89E3;&#x6790;class
   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);

   if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Bean class isn&apos;t public, and non-public access not allowed: &quot; + beanClass.getName());
   }
   // &#x5982;&#x679C;&#x5DE5;&#x5382;&#x65B9;&#x6CD5;&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x5219;&#x4F7F;&#x7528;&#x5DE5;&#x5382;&#x65B9;&#x6CD5;&#x521D;&#x59CB;&#x5316;&#x7B56;&#x7565;
   if (mbd.getFactoryMethodName() != null)  {
      return instantiateUsingFactoryMethod(beanName, mbd, args);
   }

   // Shortcut when re-creating the same bean...
   boolean resolved = false;
   boolean autowireNecessary = false;
   if (args == null) {
      synchronized (mbd.constructorArgumentLock) {
         if (mbd.resolvedConstructorOrFactoryMethod != null) {
            resolved = true;
            autowireNecessary = mbd.constructorArgumentsResolved;
         }
      }
   }
</code></pre><ul>
<li>// &#x5982;&#x679C;&#x89E3;&#x6790;&#x8FC7;&#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;&#x521B;&#x5EFA;&#xFF1B;&#x5426;&#x5219;&#x8981;&#x83B7;&#x53D6;&#x6784;&#x9020;&#x65B9;&#x6CD5;
 if (resolved) {<pre><code>if (autowireNecessary) {
   return autowireConstructor(beanName, mbd, null, null);
}
else {
   return instantiateBean(beanName, mbd);
}
</code></pre> }
 // &#x9700;&#x8981;&#x6839;&#x636E;&#x53C2;&#x6570;&#x89E3;&#x6790;&#x6784;&#x9020;&#x65B9;&#x6CD5;
 // Need to determine the constructor...
 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
 if (ctors != null ||<pre><code>   mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
   mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
</code></pre></li>
<li>// &#x6784;&#x9020;&#x65B9;&#x6CD5;&#x81EA;&#x52A8;&#x6CE8;&#x5165;<pre><code>return autowireConstructor(beanName, mbd, ctors, args);
</code></pre> }
 // &#x4F7F;&#x7528;&#x9ED8;&#x8BA4;&#x6784;&#x9020;&#x65B9;&#x6CD5;
 // No special handling: simply use no-arg constructor.
 return instantiateBean(beanName, mbd);
}</li>
</ul>
<pre><code>- 3.3.1.1) instantiateUsingFactoryMethod&#xFF08;&#x5DE5;&#x5382;&#x65B9;&#x6CD5;&#x7684;&#x5B9E;&#x4F8B;&#x5316;)
</code></pre><ul>
<li>AbstractAutowireCapableBeanFactory. instantiateUsingFactoryMethod</li>
<li><p>protected BeanWrapper instantiateUsingFactoryMethod(</p>
<pre><code>String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {
</code></pre><p> return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);
}</p>
<ul>
<li>3.3.1.2) autowireConstructor&#xFF08;&#x6709;&#x53C2;&#x6570;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x7684;&#x5B9E;&#x4F8B;&#x5316;)</li>
</ul>
</li>
<li><p>protected BeanWrapper autowireConstructor(</p>
<pre><code>String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt;[] ctors, Object[] explicitArgs) {
</code></pre><p> return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
}</p>
</li>
<li><p>ConstructorResolver.autowireConstructor</p>
</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x786E;&#x5B9A; &#x6784;&#x9020;&#x65B9;&#x6CD5;&#x7684;&#x53C2;&#x6570;</li>
</ul>
</li>
<li>&#x6839;&#x636E;explicitArgs&#x53C2;&#x6570;&#x5224;&#x65AD;</li>
<li>&#x5982;&#x679C;&#x4F20;&#x5165;&#x7684;&#x53C2;&#x6570;explicitArgs&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x90A3;&#x4E48;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x786E;&#x5B9A;&#x53C2;&#x6570;&#xFF0C;&#x56E0;&#x4E3A;explicitArgs&#x53C2;&#x6570;&#x662F;&#x5728;getBean&#x7684;&#x65F6;&#x5019;&#x7528;&#x6237;&#x6307;&#x5B9A;&#x7684;&#x3002;&#x2014;&#x2014;getBean(String name,Object ...args)</li>
<li>&#x5728;&#x83B7;&#x53D6;bean&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x7528;&#x6237;&#x4E0D;&#x4F46;&#x53EF;&#x4EE5;&#x6307;&#x5B9A;bean&#x7684;&#x540D;&#x79F0;&#xFF0C;&#x8FD8;&#x53EF;&#x4EE5;&#x6307;&#x5B9A;bean&#x6240;&#x5BF9;&#x5E94;&#x7C7B;&#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6216;&#x8005;&#x5DE5;&#x5382;&#x65B9;&#x6CD5;&#x7684;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#xFF0C;&#x4E3B;&#x8981;&#x7528;&#x4E8E;&#x9759;&#x6001;&#x5DE5;&#x5382;&#x65B9;&#x6CD5;&#x7684;&#x8C03;&#x7528;&#xFF0C;&#x800C;&#x8FD9;&#x91CC;&#x662F;&#x9700;&#x8981;&#x7ED9;&#x5B9A;&#x5B8C;&#x5168;&#x5339;&#x914D;&#x7684;&#x53C2;&#x6570;&#x7684;&#x3002;</li>
<li><p>&#x6240;&#x4EE5;&#xFF0C;&#x5982;&#x679C;&#x4F20;&#x5165;&#x53C2;&#x6570;explicitArgs&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x5219;&#x53EF;&#x4EE5;&#x786E;&#x5B9A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x5C31;&#x662F;&#x5B83;&#x3002;</p>
</li>
<li><p>&#x4ECE;&#x7F13;&#x5B58;&#x4E2D;&#x83B7;&#x53D6;</p>
</li>
<li>&#x5982;&#x679C;&#x786E;&#x5B9A;&#x53C2;&#x6570;&#x7684;&#x529E;&#x6CD5;&#x4E4B;&#x524D;&#x5DF2;&#x7ECF;&#x5206;&#x6790;&#x8FC7;&#xFF0C;&#x5373;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x5DF2;&#x7ECF;&#x8BB0;&#x5F55;&#x5728;&#x7F13;&#x5B58;&#x4E2D;&#xFF0C;&#x90A3;&#x4E48;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x62FF;&#x6765;&#x4F7F;&#x7528;&#x3002;&#x800C;&#x4E14;&#xFF0C;&#x5728;&#x7F13;&#x5B58;&#x4E2D;&#x7F13;&#x5B58;&#x7684;&#x53EF;&#x80FD;&#x662F;&#x53C2;&#x6570;&#x7684;&#x6700;&#x7EC8;&#x7C7B;&#x578B;&#xFF0C;&#x4E5F;&#x53EF;&#x80FD;&#x662F;&#x53C2;&#x6570;&#x7684;&#x521D;&#x59CB;&#x7C7B;&#x578B;&#x3002;</li>
<li>&#x4ECE;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x83B7;&#x53D6;</li>
<li>&#x5373;&#x4ECE;&#x5934;&#x5F00;&#x59CB;&#x5206;&#x6790;&#x3002;</li>
<li>&#x5206;&#x6790;&#x4ECE;&#x83B7;&#x53D6;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#x914D;&#x7F6E;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4FE1;&#x606F;&#x5F00;&#x59CB;&#xFF0C;&#x53EF;&#x4EE5;&#x8C03;&#x7528;BeanDefinition.getConstructorArgumentValues()&#x6765;&#x83B7;&#x53D6;&#x914D;&#x7F6E;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4FE1;&#x606F;&#x3002;</li>
<li><p>&#x6709;&#x4E86;&#x914D;&#x7F6E;&#x4E2D;&#x7684;&#x4FE1;&#x606F;&#x4FBF;&#x53EF;&#x4EE5;&#x83B7;&#x53D6;&#x5BF9;&#x5E94;&#x7684;&#x53C2;&#x6570;&#x503C;&#x4FE1;&#x606F;&#x4E86;&#xFF0C;&#x83B7;&#x53D6;&#x53C2;&#x6570;&#x503C;&#x7684;&#x4FE1;&#x606F;&#x5305;&#x62EC;&#x76F4;&#x63A5;&#x6307;&#x5B9A;&#x503C;&#xFF0C;&#x800C;&#x8FD9;&#x4E00;&#x5904;&#x7406;&#x59D4;&#x6258;&#x7ED9;resolveConstructorArguments&#x65B9;&#x6CD5;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x80FD;&#x89E3;&#x6790;&#x5230;&#x7684;&#x53C2;&#x6570;&#x7684;&#x4E2A;&#x6570;&#x3002;</p>
<ul>
<li>2)&#x786E;&#x5B9A; &#x6784;&#x9020;&#x65B9;&#x6CD5;</li>
</ul>
</li>
</ul>
<pre><code>&#x6839;&#x636E;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x5728;&#x6240;&#x6709;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4E2D;&#x9501;&#x5B9A;&#x5BF9;&#x5E94;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#xFF0C;&#x5339;&#x914D;&#x7684;&#x65B9;&#x6CD5;&#x5C31;&#x662F;&#x6839;&#x636E;&#x53C2;&#x6570;&#x4E2A;&#x6570;&#x5339;&#x914D;&#xFF0C;&#x6240;&#x4EE5;&#x5728;&#x5339;&#x914D;&#x4E4B;&#x524D;&#x9700;&#x8981;&#x5148;&#x5BF9;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x6309;&#x7167;public&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4F18;&#x5148;&#x53C2;&#x6570;&#x6570;&#x91CF;&#x964D;&#x5E8F;&#x3001;&#x975E;public&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x6570;&#x91CF;&#x964D;&#x5E8F;&#x3002;&#x8FD9;&#x6837;&#x53EF;&#x4EE5;&#x5728;&#x904D;&#x5386;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x8FC5;&#x901F;&#x5224;&#x65AD;&#x6392;&#x5728;&#x540E;&#x9762;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x4E2A;&#x6570;&#x662F;&#x5426;&#x7B26;&#x5408;&#x6761;&#x4EF6;&#x3002;
</code></pre><ul>
<li>&#x7531;&#x4E8E;&#x5728;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#x5E76;&#x4E0D;&#x662F;&#x552F;&#x4E00;&#x9650;&#x5236;&#x4F7F;&#x7528;&#x53C2;&#x6570;&#x4F4D;&#x7F6E;&#x7D22;&#x5F15;&#x7684;&#x65B9;&#x6CD5;&#x53BB;&#x521B;&#x5EFA;&#xFF0C;&#x540C;&#x6837;&#x8FD8;&#x652F;&#x6301;&#x6307;&#x5B9A;&#x53C2;&#x6570;&#x540D;&#x79F0;&#x8FDB;&#x884C;&#x8BBE;&#x5B9A;&#x53C2;&#x6570;&#x503C;&#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x5982;<constructor-arg name="&#x201D;aa&#x201D;">&#xFF0C;&#x90A3;&#x4E48;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x5C31;&#x9700;&#x8981;&#x9996;&#x5148;&#x786E;&#x5B9A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4E2D;&#x7684;&#x53C2;&#x6570;&#x540D;&#x79F0;&#x3002;</constructor-arg></li>
<li><p>&#x83B7;&#x53D6;&#x53C2;&#x6570;&#x540D;&#x79F0;&#x53EF;&#x4EE5;&#x6709;&#x4E24;&#x79CD;&#x65B9;&#x5F0F;&#xFF0C;&#x4E00;&#x79CD;&#x662F;&#x901A;&#x8FC7;&#x6CE8;&#x89E3;&#x7684;&#x65B9;&#x5F0F;&#x76F4;&#x63A5;&#x83B7;&#x53D6;&#xFF0C;&#x53E6;&#x4E00;&#x79CD;&#x5C31;&#x662F;&#x4F7F;&#x7528;Spring&#x4E2D;&#x63D0;&#x4F9B;&#x7684;&#x5DE5;&#x5177;&#x7C7B;ParameterNameDiscoverer&#x6765;&#x83B7;&#x53D6;&#x3002;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x3001;&#x53C2;&#x6570;&#x540D;&#x79F0;&#x3001;&#x53C2;&#x6570;&#x7C7B;&#x578B;&#x3001;&#x53C2;&#x6570;&#x503C;&#x90FD;&#x786E;&#x5B9A;&#x540E;&#x5C31;&#x53EF;&#x4EE5;&#x9501;&#x5B9A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4EE5;&#x53CA;&#x8F6C;&#x6362;&#x5BF9;&#x5E94;&#x7684;&#x53C2;&#x6570;&#x7C7B;&#x578B;&#x4E86;&#x3002;</p>
<ul>
<li>3)&#x6839;&#x636E;&#x786E;&#x5B9A;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x8F6C;&#x6362;&#x5BF9;&#x5E94;&#x7684;&#x53C2;&#x6570;&#x7C7B;&#x578B;</li>
</ul>
</li>
<li>&#x4E3B;&#x8981;&#x662F;&#x4F7F;&#x7528;Spring&#x4E2D;&#x63D0;&#x4F9B;&#x7684;&#x7C7B;&#x578B;&#x8F6C;&#x6362;&#x5668;&#x6216;&#x8005;&#x7528;&#x6237;&#x63D0;&#x4F9B;&#x7684;&#x81EA;&#x5B9A;&#x4E49;&#x7C7B;&#x578B;&#x8F6C;&#x6362;&#x5668;&#x8FDB;&#x884C;&#x8F6C;&#x6362;<ul>
<li>4)&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4E0D;&#x786E;&#x5B9A;&#x6027;&#x7684;&#x9A8C;&#x8BC1;</li>
</ul>
</li>
<li>&#x6709;&#x65F6;&#x5019;&#x5373;&#x4F7F;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x3001;&#x53C2;&#x6570;&#x540D;&#x79F0;&#x3001;&#x53C2;&#x6570;&#x7C7B;&#x578B;&#x3001;&#x53C2;&#x6570;&#x503C;&#x90FD;&#x786E;&#x5B9A;&#x540E;&#x4E5F;&#x4E0D;&#x4E00;&#x5B9A;&#x4F1A;&#x76F4;&#x63A5;&#x9501;&#x5B9A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#xFF0C;&#x6240;&#x4EE5;Spring&#x5728;&#x6700;&#x540E;&#x53C8;&#x505A;&#x4E86;&#x4E00;&#x6B21;&#x9A8C;&#x8BC1;&#x3002;<ul>
<li>5)&#x6839;&#x636E;&#x5B9E;&#x4F8B;&#x5316;&#x7B56;&#x7565;&#x4EE5;&#x53CA;&#x5F97;&#x5230;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53CA;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x5B9E;&#x4F8B;&#x5316;bean&#x3002;</li>
</ul>
</li>
</ul>
<pre><code>public BeanWrapper autowireConstructor(final String beanName, final RootBeanDefinition mbd,
      Constructor&lt;?&gt;[] chosenCtors, final Object[] explicitArgs) {

   BeanWrapperImpl bw = new BeanWrapperImpl();
   this.beanFactory.initBeanWrapper(bw);

   Constructor&lt;?&gt; constructorToUse = null;
   ArgumentsHolder argsHolderToUse = null;
   Object[] argsToUse = null;
   // explicitArgs&#x901A;&#x8FC7;getBean&#x65B9;&#x6CD5;&#x4F20;&#x5165;
</code></pre><ul>
<li>// &#x5982;&#x679C;getBean&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x7684;&#x65F6;&#x5019;&#x6307;&#x5B9A;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;&#x4F7F;&#x7528;
 if (explicitArgs != null) {<pre><code>argsToUse = explicitArgs;
</code></pre> }
 else {</li>
<li>// &#x5982;&#x679C;&#x5728;getBean&#x65B9;&#x6CD5;&#x65F6;&#x5019;&#x6CA1;&#x6709;&#x6307;&#x5B9A;&#x5219;&#x5C1D;&#x8BD5;&#x4ECE;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#x89E3;&#x6790;<pre><code>Object[] argsToResolve = null;
</code></pre></li>
<li>// &#x5C1D;&#x8BD5;&#x4ECE;&#x7F13;&#x5B58;&#x4E2D;&#x83B7;&#x53D6;<pre><code>synchronized (mbd.constructorArgumentLock) {
   constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;
   if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {
      // Found a cached constructor...
</code></pre></li>
<li>// &#x4ECE;&#x7F13;&#x5B58;&#x4E2D;&#x53D6;<pre><code>  argsToUse = mbd.resolvedConstructorArguments;
  if (argsToUse == null) {
</code></pre></li>
<li>// &#x914D;&#x7F6E;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;<pre><code>         argsToResolve = mbd.preparedConstructorArguments;
      }
   }
}
</code></pre></li>
<li>// &#x5982;&#x679C;&#x7F13;&#x5B58;&#x4E2D;&#x5B58;&#x5728;<pre><code>if (argsToResolve != null) {
</code></pre><ul>
<li>// &#x89E3;&#x6790;&#x53C2;&#x6570;&#x7C7B;&#x578B;&#xFF0C;&#x5982;&#x7ED9;&#x5B9A;&#x65B9;&#x6CD5;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;A(int,int)&#xFF0C;&#x5219;&#x901A;&#x8FC7;&#x6B64;&#x65B9;&#x6CD5;&#x540E;&#x5C31;&#x4F1A;&#x628A;&#x914D;&#x7F6E;&#x4E2D;&#x7684;(&#x201C;1&#x201D;,&#x201D;1&#x201D;)&#x8F6C;&#x6362;&#x4E3A;(1,1)</li>
</ul>
</li>
<li><p>// &#x7F13;&#x5B58;&#x4E2D;&#x7684;&#x503C;&#x53EF;&#x80FD;&#x662F;&#x539F;&#x59CB;&#x503C;&#xFF0C;&#x4E5F;&#x53EF;&#x80FD;&#x662F;&#x6700;&#x7EC8;&#x503C;</p>
<pre><code>   argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);
}
</code></pre><p> }
 //&#x6CA1;&#x6709;&#x88AB;&#x7F13;&#x5B58;
 if (constructorToUse == null) {</p>
<pre><code>// Need to resolve the constructor.
boolean autowiring = (chosenCtors != null ||
      mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
ConstructorArgumentValues resolvedValues = null;

int minNrOfArgs;
if (explicitArgs != null) {
   minNrOfArgs = explicitArgs.length;
}
else {
</code></pre></li>
<li>// &#x63D0;&#x53D6;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#x7684;&#x914D;&#x7F6E;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;<pre><code>   ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
</code></pre></li>
<li>// &#x7528;&#x4E8E;&#x627F;&#x8F7D;&#x89E3;&#x6790;&#x540E;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x7684;&#x503C;<pre><code>   resolvedValues = new ConstructorArgumentValues();
</code></pre></li>
<li><p>// &#x80FD;&#x89E3;&#x6790;&#x5230;&#x7684;&#x53C2;&#x6570;&#x4E2A;&#x6570;</p>
<pre><code>   minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
}

// Take specified constructors, if any.
Constructor&lt;?&gt;[] candidates = chosenCtors;
if (candidates == null) {
   Class&lt;?&gt; beanClass = mbd.getBeanClass();
   try {
      candidates = (mbd.isNonPublicAccessAllowed() ?
            beanClass.getDeclaredConstructors() : beanClass.getConstructors());
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +
            &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);
   }
}
</code></pre></li>
</ul>
<pre><code>// &#x6392;&#x5E8F;&#x7ED9;&#x5B9A;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#xFF0C;public&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4F18;&#x5148;&#x53C2;&#x6570;&#x6570;&#x91CF;&#x964D;&#x5E8F;&#x3001;&#x975E;public&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x6570;&#x91CF;&#x964D;&#x5E8F;
      AutowireUtils.sortConstructors(candidates);
      int minTypeDiffWeight = Integer.MAX_VALUE;
      Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = null;
      LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;

      for (Constructor&lt;?&gt; candidate : candidates) {
         Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();

         if (constructorToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) {
</code></pre><ul>
<li>// &#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x627E;&#x5230;&#x9009;&#x7528;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x6216;&#x8005;&#x9700;&#x8981;&#x7684;&#x53C2;&#x6570;&#x4E2A;&#x6570;&#x5C0F;&#x4E8E;&#x5F53;&#x524D;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x4E2A;&#x6570;&#xFF0C;&#x5219;&#x7EC8;&#x6B62;<pre><code>      // Already found greedy constructor that can be satisfied -&gt;
      // do not look any further, there are only less greedy constructors left.
      break;
   }
   if (paramTypes.length &lt; minNrOfArgs) {
</code></pre></li>
<li>// &#x53C2;&#x6570;&#x4E2A;&#x6570;&#x4E0D;&#x76F8;&#x7B49;<pre><code>      continue;
   }
   // &#x53C2;&#x6570;&#x4E2A;&#x6570;&#x76F8;&#x7B49;
   ArgumentsHolder argsHolder;
</code></pre></li>
<li>// &#x5982;&#x679C;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x6709;&#x53C2;&#x6570;&#xFF0C;&#x5219;&#x6839;&#x636E;&#x503C;&#x6784;&#x9020;&#x5BF9;&#x5E94;&#x53C2;&#x6570;&#x7C7B;&#x578B;&#x7684;&#x53C2;&#x6570;<pre><code>   if (resolvedValues != null) {
      try {
</code></pre></li>
<li>// &#x4ECE;&#x6CE8;&#x89E3;&#x4E0A;&#x83B7;&#x53D6;&#x53C2;&#x6570;&#x540D;&#x79F0;<pre><code>         String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
         if (paramNames == null) {
</code></pre></li>
<li>// &#x83B7;&#x53D6;&#x53C2;&#x6570;&#x540D;&#x79F0;&#x63A2;&#x7D22;&#x5668;<pre><code>            ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
            if (pnd != null) {
</code></pre></li>
<li>// &#x83B7;&#x53D6;&#x6307;&#x5B9A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x7684;&#x53C2;&#x6570;&#x540D;&#x79F0;<pre><code>               paramNames = pnd.getParameterNames(candidate);
            }
         }
</code></pre></li>
<li>// &#x6839;&#x636E;&#x540D;&#x79F0;&#x548C;&#x6570;&#x636E;&#x7C7B;&#x578B; &#x521B;&#x5EFA;&#x53C2;&#x6570;&#x6301;&#x6709;&#x8005;<pre><code>     argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
           getUserDeclaredConstructor(candidate), autowiring);
  }
  catch (UnsatisfiedDependencyException ex) {
     if (this.beanFactory.logger.isTraceEnabled()) {
        this.beanFactory.logger.trace(
              &quot;Ignoring constructor [&quot; + candidate + &quot;] of bean &apos;&quot; + beanName + &quot;&apos;: &quot; + ex);
     }
     // Swallow and try next constructor.
     if (causes == null) {
        causes = new LinkedList&lt;UnsatisfiedDependencyException&gt;();
     }
     causes.add(ex);
     continue;
  }
</code></pre>   }</li>
<li>// &#x5982;&#x679C;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x6CA1;&#x6709;&#x53C2;&#x6570;<pre><code>   else {
      // Explicit arguments given -&gt; arguments length must match exactly.
      if (paramTypes.length != explicitArgs.length) {
         continue;
      }
      argsHolder = new ArgumentsHolder(explicitArgs);
   }
   // &#x63A2;&#x6D4B;&#x662F;&#x5426;&#x6709;&#x4E0D;&#x786E;&#x5B9A;&#x6027;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x5B58;&#x5728;&#xFF0C;&#x4F8B;&#x5982;&#x4E0D;&#x540C;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x7684;&#x53C2;&#x6570;&#x4E3A;&#x7236;&#x5B50;&#x5173;&#x7CFB;
   int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
         argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
   // Choose this constructor if it represents the closest match.
</code></pre></li>
<li><p>// &#x5982;&#x679C;&#x5B83;&#x4EE3;&#x8868;&#x7740;&#x5F53;&#x524D;&#x6700;&#x63A5;&#x8FD1;&#x7684;&#x5339;&#x914D;&#x5219;&#x9009;&#x62E9;&#x4F5C;&#x4E3A;&#x6784;&#x9020;&#x65B9;&#x6CD5;</p>
<pre><code>   if (typeDiffWeight &lt; minTypeDiffWeight) {
      constructorToUse = candidate;
      argsHolderToUse = argsHolder;
      argsToUse = argsHolder.arguments;
      minTypeDiffWeight = typeDiffWeight;
      ambiguousConstructors = null;
   }
   else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight) {
      if (ambiguousConstructors == null) {
         ambiguousConstructors = new LinkedHashSet&lt;Constructor&lt;?&gt;&gt;();
         ambiguousConstructors.add(constructorToUse);
      }
      ambiguousConstructors.add(candidate);
   }
}

if (constructorToUse == null) {
   if (causes != null) {
      UnsatisfiedDependencyException ex = causes.removeLast();
      for (Exception cause : causes) {
         this.beanFactory.onSuppressedException(cause);
      }
      throw ex;
   }
   throw new BeanCreationException(mbd.getResourceDescription(), beanName,
         &quot;Could not resolve matching constructor &quot; +
         &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;);
}
else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution()) {
   throw new BeanCreationException(mbd.getResourceDescription(), beanName,
         &quot;Ambiguous constructor matches found in bean &apos;&quot; + beanName + &quot;&apos; &quot; +
         &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +
         ambiguousConstructors);
}

if (explicitArgs == null) {
</code></pre></li>
</ul>
<pre><code>// &#x5C06;&#x89E3;&#x6790;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x52A0;&#x5165;&#x7F13;&#x5B58;
         argsHolderToUse.storeCache(mbd, constructorToUse);
      }
   }

   try {
      Object beanInstance;

      if (System.getSecurityManager() != null) {
         final Constructor&lt;?&gt; ctorToUse = constructorToUse;
         final Object[] argumentsToUse = argsToUse;
         beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
            @Override
            public Object run() {
               return beanFactory.getInstantiationStrategy().instantiate(
                     mbd, beanName, beanFactory, ctorToUse, argumentsToUse);
            }
         }, beanFactory.getAccessControlContext());
      }
      else {
         beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(
               mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
      }
      // &#x5C06;&#x6784;&#x5EFA;&#x7684;&#x5B9E;&#x4F8B;&#x52A0;&#x5165;BeanWrapper&#x4E2D;
      bw.setBeanInstance(beanInstance);
      return bw;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Bean instantiation via constructor failed&quot;, ex);
   }
}
</code></pre><pre><code>- 3.3.1.2.1) createArgumentArray&#xFF08;&#x9012;&#x5F52;&#x83B7;&#x53D6;&#x53C2;&#x6570;&#x7684;bean)
</code></pre><pre><code>private ArgumentsHolder createArgumentArray(
      String beanName, RootBeanDefinition mbd, ConstructorArgumentValues resolvedValues,
      BeanWrapper bw, Class&lt;?&gt;[] paramTypes, String[] paramNames, Object methodOrCtor,
      boolean autowiring) throws UnsatisfiedDependencyException {

   String methodType = (methodOrCtor instanceof Constructor ? &quot;constructor&quot; : &quot;factory method&quot;);
   TypeConverter converter = (this.beanFactory.getCustomTypeConverter() != null ?
         this.beanFactory.getCustomTypeConverter() : bw);

   ArgumentsHolder args = new ArgumentsHolder(paramTypes.length);
   Set&lt;ConstructorArgumentValues.ValueHolder&gt; usedValueHolders =
         new HashSet&lt;ConstructorArgumentValues.ValueHolder&gt;(paramTypes.length);
   Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;String&gt;(4);

   for (int paramIndex = 0; paramIndex &lt; paramTypes.length; paramIndex++) {
      Class&lt;?&gt; paramType = paramTypes[paramIndex];
      String paramName = (paramNames != null ? paramNames[paramIndex] : null);
      // Try to find matching constructor argument value, either indexed or generic.
      ConstructorArgumentValues.ValueHolder valueHolder =
            resolvedValues.getArgumentValue(paramIndex, paramType, paramName, usedValueHolders);
      // If we couldn&apos;t find a direct match and are not supposed to autowire,
      // let&apos;s try the next generic, untyped argument value as fallback:
      // it could match after type conversion (for example, String -&gt; int).
      if (valueHolder == null &amp;&amp; !autowiring) {
         valueHolder = resolvedValues.getGenericArgumentValue(null, null, usedValueHolders);
      }
      if (valueHolder != null) {
         // We found a potential match - let&apos;s give it a try.
         // Do not consider the same value definition multiple times!
         usedValueHolders.add(valueHolder);
         Object originalValue = valueHolder.getValue();
         Object convertedValue;
         if (valueHolder.isConverted()) {
            convertedValue = valueHolder.getConvertedValue();
            args.preparedArguments[paramIndex] = convertedValue;
         }
         else {
            ConstructorArgumentValues.ValueHolder sourceHolder =
                  (ConstructorArgumentValues.ValueHolder) valueHolder.getSource();
            Object sourceValue = sourceHolder.getValue();
            try {
               convertedValue = converter.convertIfNecessary(originalValue, paramType,
                     MethodParameter.forMethodOrConstructor(methodOrCtor, paramIndex));
               // TODO re-enable once race condition has been found (SPR-7423)
               /*
               if (originalValue == sourceValue || sourceValue instanceof TypedStringValue) {
                  // Either a converted value or still the original one: store converted value.
                  sourceHolder.setConvertedValue(convertedValue);
                  args.preparedArguments[paramIndex] = convertedValue;
               }
               else {
               */
                  args.resolveNecessary = true;
                  args.preparedArguments[paramIndex] = sourceValue;
               // }
            }
            catch (TypeMismatchException ex) {
               throw new UnsatisfiedDependencyException(
                     mbd.getResourceDescription(), beanName, paramIndex, paramType,
                     &quot;Could not convert &quot; + methodType + &quot; argument value of type [&quot; +
                     ObjectUtils.nullSafeClassName(valueHolder.getValue()) +
                     &quot;] to required type [&quot; + paramType.getName() + &quot;]: &quot; + ex.getMessage());
            }
         }
         args.arguments[paramIndex] = convertedValue;
         args.rawArguments[paramIndex] = originalValue;
      }
      else {
         // No explicit match found: we&apos;re either supposed to autowire or
         // have to fail creating an argument array for the given constructor.
         if (!autowiring) {
            throw new UnsatisfiedDependencyException(
                  mbd.getResourceDescription(), beanName, paramIndex, paramType,
                  &quot;Ambiguous &quot; + methodType + &quot; argument types - &quot; +
                  &quot;did you specify the correct bean references as &quot; + methodType + &quot; arguments?&quot;);
         }
         try {
            MethodParameter param = MethodParameter.forMethodOrConstructor(methodOrCtor, paramIndex);
            Object autowiredArgument = resolveAutowiredArgument(param, beanName, autowiredBeanNames, converter);
            args.rawArguments[paramIndex] = autowiredArgument;
            args.arguments[paramIndex] = autowiredArgument;
            args.preparedArguments[paramIndex] = new AutowiredArgumentMarker();
            args.resolveNecessary = true;
         }
         catch (BeansException ex) {
            throw new UnsatisfiedDependencyException(
                  mbd.getResourceDescription(), beanName, paramIndex, paramType, ex);
         }
      }
   }

   for (String autowiredBeanName : autowiredBeanNames) {
      this.beanFactory.registerDependentBean(autowiredBeanName, beanName);
      if (this.beanFactory.logger.isDebugEnabled()) {
         this.beanFactory.logger.debug(&quot;Autowiring by type from bean name &apos;&quot; + beanName +
               &quot;&apos; via &quot; + methodType + &quot; to bean named &apos;&quot; + autowiredBeanName + &quot;&apos;&quot;);
      }
   }

   return args;
}
</code></pre><pre><code>- 3.3.1.2.1.1) resolveAutowiredArgument
</code></pre><ul>
<li><p>protected Object resolveAutowiredArgument(</p>
<pre><code>MethodParameter param, String beanName, Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter) {
</code></pre><p> return this.beanFactory.resolveDependency(</p>
<pre><code>   new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);
</code></pre><p>}</p>
<ul>
<li>3.3.1.2.2) InstantiationStrategy.instantiate</li>
</ul>
</li>
<li><p>&#x5B9E;&#x4F8B;&#x5316;&#x7684;&#x65F6;&#x5019;&#x53EF;&#x4EE5;&#x91C7;&#x7528;&#x4E0D;&#x540C;&#x7684;&#x7B56;&#x7565;&#x8FDB;&#x884C;&#x5B9E;&#x4F8B;&#x5316;&#x3002;</p>
</li>
<li>&#x5982;&#x679C;beanDefinition.getMethodOverrides()&#x4E3A;&#x7A7A;&#xFF0C;&#x5373;&#x7528;&#x6237;&#x6CA1;&#x6709;&#x4F7F;&#x7528;replace&#x6216;lookup&#x7684;&#x914D;&#x7F6E;&#x65B9;&#x6CD5;&#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;&#x4F7F;&#x7528;&#x53CD;&#x5C04;&#x7684;&#x65B9;&#x5F0F;&#xFF1B;&#x5982;&#x679C;&#x4F7F;&#x7528;&#x4E86;&#xFF0C;&#x9700;&#x8981;&#x5C06;&#x8FD9;&#x4E24;&#x4E2A;&#x914D;&#x7F6E;&#x901A;&#x8FC7;&#x7684;&#x529F;&#x80FD;&#x5207;&#x5165;&#x8FDB;&#x53BB;&#xFF0C;&#x6240;&#x4EE5;&#x5C31;&#x5FC5;&#x987B;&#x8981;&#x4F7F;&#x7528;&#x52A8;&#x6001;&#x4EE3;&#x7406;&#x7684;&#x65B9;&#x5F0F;&#x5C06;&#x5305;&#x542B;&#x4E24;&#x4E2A;&#x7279;&#x6027;&#x6240;&#x5BF9;&#x5E94;&#x7684;&#x903B;&#x8F91;&#x7684;&#x62E6;&#x622A;&#x589E;&#x5F3A;&#x5668;&#x8BBE;&#x7F6E;&#x8FDB;&#x53BB;&#xFF0C;&#x8FD9;&#x6837;&#x624D;&#x53EF;&#x4EE5;&#x4FDD;&#x8BC1;&#x5728;&#x8C03;&#x7528;&#x65B9;&#x6CD5;&#x7684;&#x65F6;&#x5019;&#x4F1A;&#x88AB;&#x76F8;&#x5E94;&#x7684;&#x62E6;&#x622A;&#x5668;&#x589E;&#x5F3A;&#xFF0C;&#x8FD4;&#x56DE;&#x503C;&#x4E3A;&#x5305;&#x542B;&#x62E6;&#x622A;&#x5668;&#x7684;&#x4EE3;&#x7406;&#x5B9E;&#x4F8B;&#x3002;</li>
<li>&#x4EE5;SimpleInstantiationStrategy&#x4E3A;&#x4F8B;&#xFF1A;</li>
</ul>
<pre><code>public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {
   // Don&apos;t override the class with CGLIB if no overrides.
</code></pre><ul>
<li>// &#x5982;&#x679C;&#x6709;&#x9700;&#x8981;&#x8986;&#x76D6;&#x6216;&#x8005;&#x52A8;&#x6001;&#x66FF;&#x6362;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x5219;&#x4F7F;&#x7528;cglib&#x8FDB;&#x884C;&#x52A8;&#x6001;&#x4EE3;&#x7406;&#xFF0C;&#x56E0;&#x4E3A;&#x53EF;&#x4EE5;&#x5728;&#x521B;&#x5EFA;&#x4EE3;&#x7406;&#x7684;&#x540C;&#x65F6;&#x5C06;&#x52A8;&#x6001;&#x65B9;&#x6CD5;&#x7EC7;&#x5165;&#x7C7B;&#x4E2D;&#xFF0C;&#x4F46;&#x662F;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x9700;&#x8981;&#x52A8;&#x6001;&#x6539;&#x53D8;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x4E3A;&#x4E86;&#x65B9;&#x4FBF;&#x76F4;&#x63A5;&#x53CD;&#x5C04;&#x5C31;&#x53EF;&#x4EE5;&#x4E86;
 if (bd.getMethodOverrides().isEmpty()) {</li>
</ul>
<pre><code>// &#x6CA1;&#x6709;&#x9700;&#x8981;&#x8986;&#x76D6;&#x7684;&#x65B9;&#x6CD5;
      Constructor&lt;?&gt; constructorToUse;
      synchronized (bd.constructorArgumentLock) {
         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;
         if (constructorToUse == null) {
            final Class&lt;?&gt; clazz = bd.getBeanClass();
            if (clazz.isInterface()) {
               throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);
            }
            try {
               if (System.getSecurityManager() != null) {
                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() {
                     @Override
                     public Constructor&lt;?&gt; run() throws Exception {
                        return clazz.getDeclaredConstructor((Class[]) null);
                     }
                  });
               }
               else {
                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);
               }
               bd.resolvedConstructorOrFactoryMethod = constructorToUse;
            }
            catch (Throwable ex) {
               throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);
            }
         }
      }
</code></pre><ul>
<li><p>// &#x53CD;&#x5C04;&#x5B9E;&#x4F8B;&#x5316;</p>
<pre><code>return BeanUtils.instantiateClass(constructorToUse);
</code></pre><p> }
 else {</p>
<pre><code>// Must generate CGLIB subclass.
return instantiateWithMethodInjection(bd, beanName, owner);
</code></pre><p> }
}</p>
</li>
<li><p>&#x4EE5;CglibSubclassingInstantiationStrategy&#x4E3A;&#x4F8B;&#xFF1A;</p>
</li>
</ul>
<pre><code>public Object instantiate(Constructor&lt;?&gt; ctor, Object... args) {
   Class&lt;?&gt; subclass = createEnhancedSubclass(this.beanDefinition);
   Object instance;
   if (ctor == null) {
      instance = BeanUtils.instantiateClass(subclass);
   }
   else {
      try {
         Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());
         instance = enhancedSubclassConstructor.newInstance(args);
      }
      catch (Exception ex) {
         throw new BeanInstantiationException(this.beanDefinition.getBeanClass(),
               &quot;Failed to invoke constructor for CGLIB enhanced subclass [&quot; + subclass.getName() + &quot;]&quot;, ex);
      }
   }
   // SPR-10785: set callbacks directly on the instance instead of in the
   // enhanced class (via the Enhancer) in order to avoid memory leaks.
   Factory factory = (Factory) instance;
   factory.setCallbacks(new Callback[] {NoOp.INSTANCE,
         new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),
         new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});
   return instance;
}
</code></pre><ul>
<li>createEnhancedSubclass:</li>
</ul>
<pre><code>private Class&lt;?&gt; createEnhancedSubclass(RootBeanDefinition beanDefinition) {
   Enhancer enhancer = new Enhancer();
   enhancer.setSuperclass(beanDefinition.getBeanClass());
   enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
   if (this.owner instanceof ConfigurableBeanFactory) {
      ClassLoader cl = ((ConfigurableBeanFactory) this.owner).getBeanClassLoader();
      enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(cl));
   }
   enhancer.setCallbackFilter(new MethodOverrideCallbackFilter(beanDefinition));
   enhancer.setCallbackTypes(CALLBACK_TYPES);
   return enhancer.createClass();
}
</code></pre><ul>
<li><ul>
<li>3.3.1.3) instantiateBean&#xFF08;&#x65E0;&#x53C2;&#x6570;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x7684;&#x5B9E;&#x4F8B;&#x5316;)</li>
</ul>
</li>
</ul>
<pre><code>protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
   try {
      Object beanInstance;
      final BeanFactory parent = this;
      if (System.getSecurityManager() != null) {
         beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
            @Override
            public Object run() {
               return getInstantiationStrategy().instantiate(mbd, beanName, parent);
            }
         }, getAccessControlContext());
      }
      else {
</code></pre><ul>
<li><p>// &#x5B9E;&#x4F8B;&#x5316;&#x5373;&#x53EF;&#xFF0C;&#x89C1;3.3.1.2.1</p>
<pre><code>   beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
}
BeanWrapper bw = new BeanWrapperImpl(beanInstance);
initBeanWrapper(bw);
return bw;
</code></pre><p> }
 catch (Throwable ex) {</p>
<pre><code>throw new BeanCreationException(
      mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);
</code></pre><p> }
}</p>
<ul>
<li>3.3.2) addSingletonFactory&#xFF08;singletonFactories&#x7F13;&#x5B58;)</li>
</ul>
</li>
<li>&#x6267;&#x884C;&#x5230;&#x8FD9;&#x91CC;&#x65F6;&#x53EF;&#x4EE5;&#x80AF;&#x5B9A;&#x5F53;&#x524D;bean&#x5DF2;&#x7ECF;&#x6784;&#x9020;&#x5B8C;&#x6210;&#xFF0C;&#x53EA;&#x662F;&#x5C1A;&#x672A;&#x586B;&#x5145;&#x5C5E;&#x6027;&#xFF0C;&#x4F46;&#x662F;&#x5185;&#x5B58;&#x5730;&#x5740;&#x5DF2;&#x7ECF;&#x786E;&#x5B9A;&#x4E86;&#x3002;&#x5C06;&#x5F53;&#x524D;bean&#x52A0;&#x5165;&#x5230;singletonFactories&#x4E2D;&#xFF0C;&#x4E0B;&#x6B21;getBean&#x65F6;&#x4F1A;&#x5148;&#x68C0;&#x6D4B;&#x5F53;&#x524D;bean&#x662F;&#x5426;&#x5DF2;&#x7ECF;&#x88AB;&#x52A0;&#x5165;&#x5230;singletonFactories&#xFF0C;&#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#xFF0C;&#x5219;&#x8FD4;&#x56DE;&#x7F13;&#x5B58;&#xFF0C;&#x5426;&#x5219;&#x5C31;&#x6B63;&#x5E38;&#x521B;&#x5EFA;&#x3002;</li>
<li>protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
 Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);
 synchronized (this.singletonObjects) {<pre><code>if (!this.singletonObjects.containsKey(beanName)) {
   this.singletonFactories.put(beanName, singletonFactory);
   this.earlySingletonObjects.remove(beanName);
   this.registeredSingletons.add(beanName);
}
</code></pre> }
}<ul>
<li>3.3.3) getEarlyBeanReference&#xFF08;&#x4ECE;singletonFactories&#x53D6;&#x51FA;&#x6765;&#x65F6;&#x8C03;&#x7528;&#x7684;getObject)</li>
</ul>
</li>
<li>protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
 Object exposedObject = bean;
 if (bean != null &amp;&amp; !mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {<pre><code>for (BeanPostProcessor bp : getBeanPostProcessors()) {
   if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
      SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
      exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);
      if (exposedObject == null) {
         return null;
      }
   }
}
</code></pre> }
 return exposedObject;
}</li>
</ul>
<pre><code>- 3.3.4) polulateBean&#xFF08;&#x5C5E;&#x6027;&#x503C;&#x6CE8;&#x5165;)
</code></pre><ul>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)InstantiationAwareBeanPostProcessor&#x5904;&#x7406;&#x5668;&#x7684;postProcessAfterInstantiation&#x51FD;&#x6570;&#x7684;&#x5E94;&#x7528;&#xFF0C;&#x6B64;&#x51FD;&#x6570;&#x53EF;&#x4EE5;&#x63A7;&#x5236;&#x7A0B;&#x5E8F;&#x662F;&#x5426;&#x7EE7;&#x7EED;&#x8FDB;&#x884C;&#x5C5E;&#x6027;&#x586B;&#x5145;&#x3002;</li>
<li>2)&#x6839;&#x636E;&#x6CE8;&#x5165;&#x7C7B;&#x578B;&#xFF08;byName/byType)&#xFF0C;&#x63D0;&#x53D6;&#x4F9D;&#x8D56;&#x7684;bean&#xFF0C;&#x5E76;&#x7EDF;&#x4E00;&#x5B58;&#x5165;PropertyValues&#x4E2D;&#x3002;</li>
<li>3)&#x5E94;&#x7528;InstantiationAwareBeanPostProcessor&#x5904;&#x7406;&#x5668;&#x7684;postProcessPropertyValues&#x65B9;&#x6CD5;&#xFF0C;&#x5BF9;&#x5C5E;&#x6027;&#x83B7;&#x53D6;&#x5B8C;&#x6BD5;&#x586B;&#x5145;&#x524D; &#x5BF9;&#x5C5E;&#x6027;&#x7684;&#x518D;&#x6B21;&#x5904;&#x7406;&#xFF0C;&#x5178;&#x578B;&#x5E94;&#x7528;&#x662F;RequiredAnnotationBeanPostProcessor&#x7C7B;&#x4E2D;&#x5BF9;&#x5C5E;&#x6027;&#x7684;&#x9A8C;&#x8BC1;</li>
<li>4)&#x5C06;&#x6240;&#x6709;PropertyValues&#x4E2D;&#x7684;&#x5C5E;&#x6027;&#x586B;&#x5145;&#x81F3;BeanWrapper&#x4E2D;&#x3002;</li>
</ul>
</li>
<li><p>protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {
 PropertyValues pvs = mbd.getPropertyValues();</p>
<p> if (bw == null) {</p>
<pre><code>if (!pvs.isEmpty()) {
   throw new BeanCreationException(
         mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
}
else {
</code></pre></li>
<li>// &#x6CA1;&#x6709;&#x53EF;&#x586B;&#x5145;&#x7684;&#x5C5E;&#x6027;
   // Skip property population phase for null instance.
   return;
}
}
// &#x7ED9;InstantiationAwareBeanPostProcessor&#x6700;&#x540E;&#x4E00;&#x6B21;&#x673A;&#x4F1A;&#x5728;&#x5C5E;&#x6027;&#x8BBE;&#x7F6E;&#x524D;&#x6765;&#x6539;&#x53D8;bean</li>
<li><p>// &#x5982;&#xFF1A;&#x53EF;&#x4EE5;&#x7528;&#x6765;&#x652F;&#x6301;&#x5C5E;&#x6027;&#x6CE8;&#x5165;&#x7684;&#x7C7B;&#x578B;
 // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
 // state of the bean before properties are set. This can be used, for example,
 // to support styles of field injection.
 boolean continueWithPropertyPopulation = true;</p>
<p> if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {</p>
<pre><code>for (BeanPostProcessor bp : getBeanPostProcessors()) {
   if (bp instanceof InstantiationAwareBeanPostProcessor) {
      InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
</code></pre></li>
<li><p>// &#x8FD4;&#x56DE;&#x503C;&#x4E3A;&#x662F;&#x5426;&#x7EE7;&#x7EED;&#x586B;&#x5145;bean</p>
<pre><code>  if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
     continueWithPropertyPopulation = false;
     break;
  }
</code></pre><p>   }
}
}
// &#x5982;&#x679C;&#x540E;&#x5904;&#x7406;&#x5668;&#x53D1;&#x51FA;&#x505C;&#x6B62;&#x586B;&#x5145;&#x547D;&#x4EE4;&#x5219;&#x7EC8;&#x6B62;&#x540E;&#x7EED;&#x7684;&#x6267;&#x884C;
if (!continueWithPropertyPopulation) {
return;
}</p>
<p>if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
   mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</p>
<p>// Add property values based on autowire by name if applicable.
if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {</p>
</li>
<li><p>// &#x6839;&#x636E;&#x540D;&#x79F0;&#x81EA;&#x52A8;&#x6CE8;&#x5165;&#xFF0C;&#x5B58;&#x5165;PropertyValues</p>
<pre><code>   autowireByName(beanName, mbd, bw, newPvs);
}

// Add property values based on autowire by type if applicable.
if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
</code></pre></li>
<li><p>// &#x6839;&#x636E;&#x7C7B;&#x578B;&#x81EA;&#x52A8;&#x6CE8;&#x5165;&#xFF0C;&#x5B58;&#x5165;PropertyValues</p>
<pre><code>   autowireByType(beanName, mbd, bw, newPvs);
}

pvs = newPvs;
</code></pre><p> }
 // &#x540E;&#x5904;&#x7406;&#x5668;&#x5DF2;&#x7ECF;&#x521D;&#x59CB;&#x5316;
 boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</p>
</li>
<li><p>// &#x9700;&#x8981;&#x4F9D;&#x8D56;&#x68C0;&#x67E5;
 boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</p>
<p> if (hasInstAwareBpps || needsDepCheck) {</p>
<pre><code>PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
if (hasInstAwareBpps) {
</code></pre></li>
<li>// &#x5BF9;&#x6240;&#x6709;&#x9700;&#x8981;&#x4F9D;&#x8D56;&#x68C0;&#x67E5;&#x7684;&#x5C5E;&#x6027;&#x8FDB;&#x884C;&#x540E;&#x5904;&#x7406;<pre><code>   for (BeanPostProcessor bp : getBeanPostProcessors()) {
      if (bp instanceof InstantiationAwareBeanPostProcessor) {
         InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
         pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
         if (pvs == null) {
            return;
         }
      }
   }
}
if (needsDepCheck) {
   checkDependencies(beanName, mbd, filteredPds, pvs);
}
</code></pre> }
 // &#x5C06;&#x5C5E;&#x6027;&#x5E94;&#x7528;&#x5230;bean&#x4E2D;
 applyPropertyValues(beanName, mbd, bw, pvs);
}</li>
<li><ul>
<li>3.3.4.1) autowireByName&#xFF08;&#x6309;&#x540D;&#x83B7;&#x53D6;&#x5F85;&#x6CE8;&#x5165;&#x7684;&#x5C5E;&#x6027;)</li>
</ul>
</li>
<li>protected void autowireByName(<pre><code>String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {  
</code></pre> // &#x5BFB;&#x627E;bw&#x4E2D;&#x9700;&#x8981;&#x4F9D;&#x8D56;&#x6CE8;&#x5165;&#x7684;&#x5C5E;&#x6027;
 String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
 for (String propertyName : propertyNames) {<pre><code>if (containsBean(propertyName)) {
</code></pre></li>
<li>// &#x9012;&#x5F52;&#x521D;&#x59CB;&#x5316;&#x76F8;&#x5173;&#x7684;bean<pre><code>   Object bean = getBean(propertyName);
</code></pre></li>
<li>pvs.add(propertyName, bean);</li>
<li><p>// &#x6CE8;&#x518C;&#x4F9D;&#x8D56;</p>
<pre><code>   registerDependentBean(propertyName, beanName);
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Added autowiring by name from bean name &apos;&quot; + beanName +
            &quot;&apos; via property &apos;&quot; + propertyName + &quot;&apos; to bean named &apos;&quot; + propertyName + &quot;&apos;&quot;);
   }
}
else {
   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Not autowiring property &apos;&quot; + propertyName + &quot;&apos; of bean &apos;&quot; + beanName +
            &quot;&apos; by name: no matching bean found&quot;);
   }
}
</code></pre><p> }
}</p>
<ul>
<li>3.3.4.2) autowireByType&#xFF08;&#x6309;&#x7C7B;&#x578B;&#x83B7;&#x53D6;&#x5F85;&#x6CE8;&#x5165;&#x7684;&#x5C5E;&#x6027;)</li>
<li><p>protected void autowireByType(
String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {</p>
<p>TypeConverter converter = getCustomTypeConverter();
if (converter == null) {
converter = bw;
}</p>
<p>Set<string> autowiredBeanNames = new LinkedHashSet<string>(4);</string></string></p>
</li>
</ul>
</li>
<li>// &#x5BFB;&#x627E;bw&#x4E2D;&#x9700;&#x8981;&#x4F9D;&#x8D56;&#x6CE8;&#x5165;&#x7684;&#x5C5E;&#x6027;
 String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
 for (String propertyName : propertyNames) {<pre><code>try {
   PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);
   // Don&apos;t try autowiring by type for type Object: never makes sense,
   // even if it technically is a unsatisfied, non-simple property.
</code></pre></li>
<li>if (Object.class != pd.getPropertyType()) {</li>
<li>// &#x63A2;&#x6D4B;&#x6307;&#x5B9A;&#x5C5E;&#x6027;&#x7684;set&#x65B9;&#x6CD5;<pre><code>      MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);
      // Do not allow eager init for type matching in case of a prioritized post-processor.
      boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());
      DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);
</code></pre></li>
<li>// &#x89E3;&#x6790;&#x6307;&#x5B9A;beanName&#x7684;&#x5C5E;&#x6027;&#x6240;&#x5339;&#x914D;&#x7684;&#x503C;&#xFF0C;&#x5E76;&#x628A;&#x89E3;&#x6790;&#x5230;&#x7684;&#x5C5E;&#x6027;&#x540D;&#x79F0;&#x5B58;&#x50A8;&#x5728;autowireBeanNames&#x4E2D;<pre><code>      Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);
      if (autowiredArgument != null) {
         pvs.add(propertyName, autowiredArgument);
      }
</code></pre></li>
</ul>
<pre><code>// &#x5982;@Autowired private List&lt;A&gt; list;
</code></pre><ul>
<li>// &#x8FD9;&#x65F6;&#x5019;&#x4F1A;&#x627E;&#x5230;&#x6240;&#x6709;&#x5339;&#x914D;A&#x7C7B;&#x578B;&#x7684;bean&#x5E76;&#x5C06;&#x5176;&#x6CE8;&#x5165;&#xFF0C;&#x6240;&#x4EE5;&#x6BCF;&#x4E2A;&#x5C5E;&#x6027;&#x53EF;&#x80FD;&#x4F1A;&#x5BF9;&#x5E94;&#x591A;&#x4E2A;bean<pre><code>      for (String autowiredBeanName : autowiredBeanNames) {
</code></pre></li>
<li>// &#x6CE8;&#x518C;&#x4F9D;&#x8D56;<pre><code>         registerDependentBean(autowiredBeanName, beanName);
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Autowiring by type from bean name &apos;&quot; + beanName + &quot;&apos; via property &apos;&quot; +
                  propertyName + &quot;&apos; to bean named &apos;&quot; + autowiredBeanName + &quot;&apos;&quot;);
         }
      }
      autowiredBeanNames.clear();
   }
}
catch (BeansException ex) {
   throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);
}
</code></pre> }
}</li>
<li><ul>
<li>3.3.4.2.1) DefaultListableBeanFactory#resolveDependency&#xFF08;&#x5BFB;&#x627E;&#x7C7B;&#x578B;&#x5339;&#x914D;)</li>
</ul>
</li>
</ul>
<pre><code>public Object resolveDependency(DependencyDescriptor descriptor, String requestingBeanName,
      Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter) throws BeansException {

   descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
</code></pre><ul>
<li>// &#x5904;&#x7406;&#x7279;&#x5B9A;&#x7684;&#x7C7B;&#x7684;&#x6CE8;&#x5165;
 if (javaUtilOptionalClass == descriptor.getDependencyType()) {<pre><code>return new OptionalDependencyFactory().createOptionalDependency(descriptor, requestingBeanName);
</code></pre> }
 else if (ObjectFactory.class == descriptor.getDependencyType() ||<pre><code>   ObjectProvider.class == descriptor.getDependencyType()) {
return new DependencyObjectProvider(descriptor, requestingBeanName);
</code></pre> }
 else if (javaxInjectProviderClass == descriptor.getDependencyType()) {<pre><code>return new Jsr330ProviderFactory().createDependencyProvider(descriptor, requestingBeanName);
</code></pre> }
 else {<pre><code>Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
      descriptor, requestingBeanName);
if (result == null) {
</code></pre></li>
<li><p>// &#x5904;&#x7406;&#x901A;&#x7528;&#x903B;&#x8F91;</p>
<pre><code>   result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
}
return result;
</code></pre><p> }
}</p>
<ul>
<li>3.3.4.2.1.1) doResolveDependency</li>
</ul>
</li>
</ul>
<pre><code>public Object doResolveDependency(DependencyDescriptor descriptor, String beanName,
      Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter) throws BeansException {

   InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
   try {
      Object shortcut = descriptor.resolveShortcut(this);
      if (shortcut != null) {
         return shortcut;
      }

      Class&lt;?&gt; type = descriptor.getDependencyType();
      Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
      if (value != null) {
         if (value instanceof String) {
            String strVal = resolveEmbeddedValue((String) value);
            BeanDefinition bd = (beanName != null &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);
            value = evaluateBeanDefinitionString(strVal, bd);
         }
         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
         return (descriptor.getField() != null ?
               converter.convertIfNecessary(value, type, descriptor.getField()) :
               converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
      }

      Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
      if (multipleBeans != null) {
         return multipleBeans;
      }

      Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);
      if (matchingBeans.isEmpty()) {
         if (descriptor.isRequired()) {
            raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
         }
         return null;
      }

      String autowiredBeanName;
      Object instanceCandidate;

      if (matchingBeans.size() &gt; 1) {
         autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
         if (autowiredBeanName == null) {
            if (descriptor.isRequired() || !indicatesMultipleBeans(type)) {
               return descriptor.resolveNotUnique(type, matchingBeans);
            }
            else {
               // In case of an optional Collection/Map, silently ignore a non-unique case:
               // possibly it was meant to be an empty collection of multiple regular beans
               // (before 4.3 in particular when we didn&apos;t even look for collection beans).
               return null;
            }
         }
         instanceCandidate = matchingBeans.get(autowiredBeanName);
      }
      else {
         // We have exactly one match.
         Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();
         autowiredBeanName = entry.getKey();
         instanceCandidate = entry.getValue();
      }

      if (autowiredBeanNames != null) {
         autowiredBeanNames.add(autowiredBeanName);
      }
      return (instanceCandidate instanceof Class ?
            descriptor.resolveCandidate(autowiredBeanName, type, this) : instanceCandidate);
   }
   finally {
      ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
   }
}
</code></pre><pre><code>- 3.3.4.2.1.1.1) findAutowireCandidates&#xFF08;&#x83B7;&#x53D6;setter&#x6CE8;&#x5165;&#x7684;bean)
</code></pre><ul>
<li><p>protected Map<string, object=""> findAutowireCandidates(</string,></p>
<pre><code>String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor) {
</code></pre><p> String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</p>
<pre><code>   this, requiredType, true, descriptor.isEager());
</code></pre><p> Map<string, object=""> result = new LinkedHashMap<string, object="">(candidateNames.length);
 for (Class&lt;?&gt; autowiringType : this.resolvableDependencies.keySet()) {</string,></string,></p>
<pre><code>if (autowiringType.isAssignableFrom(requiredType)) {
   Object autowiringValue = this.resolvableDependencies.get(autowiringType);
   autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);
   if (requiredType.isInstance(autowiringValue)) {
      result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);
      break;
   }
}
</code></pre><p> }
 for (String candidateName : candidateNames) {</p>
<pre><code>if (!isSelfReference(beanName, candidateName) &amp;&amp; isAutowireCandidate(candidateName, descriptor)) {
   result.put(candidateName, getBean(candidateName));
}
</code></pre><p> }
 if (result.isEmpty()) {</p>
<pre><code>DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();
for (String candidateName : candidateNames) {
   if (!candidateName.equals(beanName) &amp;&amp; isAutowireCandidate(candidateName, fallbackDescriptor)) {
      result.put(candidateName, getBean(candidateName));
   }
}
</code></pre><p> }
 return result;
}</p>
</li>
<li><ul>
<li>3.3.4.3) AutowiredAnnotationBeanPostProcesser#postProcessPropertyValues&#xFF08;@Autowired&#x4F9D;&#x8D56;&#x6CE8;&#x5165;)</li>
</ul>
</li>
</ul>
<pre><code>public PropertyValues postProcessPropertyValues(
      PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {

   InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
   try {
      metadata.inject(bean, beanName, pvs);
   }
   catch (Throwable ex) {
      throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, ex);
   }
   return pvs;
}
</code></pre><pre><code>- 3.3.4.3.1) InjectionMetadata#inject
</code></pre><pre><code>public void inject(Object target, String beanName, PropertyValues pvs) throws Throwable {
   Collection&lt;InjectedElement&gt; elementsToIterate =
         (this.checkedElements != null ? this.checkedElements : this.injectedElements);
   if (!elementsToIterate.isEmpty()) {
      boolean debug = logger.isDebugEnabled();
      for (InjectedElement element : elementsToIterate) {
         if (debug) {
            logger.debug(&quot;Processing injected element of bean &apos;&quot; + beanName + &quot;&apos;: &quot; + element);
         }
         element.inject(target, beanName, pvs);
      }
   }
}
</code></pre><pre><code>- 3.3.4.3.1.1) AutowiredFieldElement#inject
- protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {
</code></pre><p>   Field field = (Field) this.member;
   try {
      Object value;
      if (this.cached) {
         value = resolvedCachedArgument(beanName, this.cachedFieldValue);
      }
      else {
         DependencyDescriptor desc = new DependencyDescriptor(field, this.required);
         desc.setContainingClass(bean.getClass());
         Set<string> autowiredBeanNames = new LinkedHashSet<string>(1);
         TypeConverter typeConverter = beanFactory.getTypeConverter();</string></string></p>
<pre><code>- // 3.3.4.2.1
     value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
     synchronized (this) {
        if (!this.cached) {
           if (value != null || this.required) {
              this.cachedFieldValue = desc;
              registerDependentBeans(beanName, autowiredBeanNames);
              if (autowiredBeanNames.size() == 1) {
                 String autowiredBeanName = autowiredBeanNames.iterator().next();
                 if (beanFactory.containsBean(autowiredBeanName)) {
                    if (beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {
                       this.cachedFieldValue = new RuntimeBeanReference(autowiredBeanName);
                    }
                 }
              }
           }
           else {
              this.cachedFieldValue = null;
           }
           this.cached = true;
        }
     }
  }
  if (value != null) {
     ReflectionUtils.makeAccessible(field);
     field.set(bean, value);
  }
</code></pre><p>   }
   catch (Throwable ex) {
      throw new BeanCreationException(&quot;Could not autowire field: &quot; + field, ex);
   }
}</p>
<pre><code>- 3.3.4.4) applyPropertyValues&#xFF08;&#x6CE8;&#x5165;&#x5C5E;&#x6027;&#x503C;)
</code></pre><ul>
<li>AbstractAutowireCapableBeanFactory</li>
<li><p>protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {
 if (pvs == null || pvs.isEmpty()) {</p>
<pre><code>return;
</code></pre><p> }</p>
<p> MutablePropertyValues mpvs = null;
 List<propertyvalue> original;</propertyvalue></p>
<p> if (System.getSecurityManager() != null) {</p>
<pre><code>if (bw instanceof BeanWrapperImpl) {
   ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());
}
</code></pre><p> }</p>
<p> if (pvs instanceof MutablePropertyValues) {</p>
<pre><code>mpvs = (MutablePropertyValues) pvs;
</code></pre></li>
<li>// &#x5982;&#x679C;mpvs&#x4E2D;&#x7684;&#x503C;&#x5DF2;&#x7ECF;&#x88AB;&#x8F6C;&#x6362;&#x4E3A;&#x5BF9;&#x5E94;&#x7684;&#x7C7B;&#x578B;&#xFF0C;&#x5219;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x8BBE;&#x7F6E;&#x5230;beanwrapper&#x4E2D;<pre><code>if (mpvs.isConverted()) {
   // Shortcut: use the pre-converted values as-is.
   try {
      bw.setPropertyValues(mpvs);
      return;
   }
   catch (BeansException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);
   }
}
original = mpvs.getPropertyValueList();
</code></pre> }
 else {</li>
<li><p>// &#x5982;&#x679C;pvs&#x5E76;&#x4E0D;&#x662F;&#x4F7F;&#x7528;MutablePropertyValues&#x5C01;&#x88C5;&#x7684;&#x7C7B;&#x578B;&#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;&#x4F7F;&#x7528;&#x539F;&#x59CB;&#x7684;&#x5C5E;&#x6027;&#x83B7;&#x53D6;&#x65B9;&#x6CD5;</p>
<pre><code>original = Arrays.asList(pvs.getPropertyValues());
</code></pre><p> }</p>
<p> TypeConverter converter = getCustomTypeConverter();
 if (converter == null) {</p>
<pre><code>converter = bw;
</code></pre><p> }</p>
</li>
<li><p>// &#x83B7;&#x53D6;&#x5BF9;&#x5E94;&#x7684;&#x89E3;&#x6790;&#x5668;
 BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);</p>
<p> // Create a deep copy, resolving any references for values.
 List<propertyvalue> deepCopy = new ArrayList<propertyvalue>(original.size());
 boolean resolveNecessary = false;</propertyvalue></propertyvalue></p>
</li>
<li><p>// &#x904D;&#x5386;&#x5C5E;&#x6027;&#xFF0C;&#x5C06;&#x5C5E;&#x6027;&#x8F6C;&#x6362;&#x4E3A;&#x5BF9;&#x5E94;&#x7C7B;&#x7684;&#x5BF9;&#x5E94;&#x5C5E;&#x6027;&#x7684;&#x7C7B;&#x578B;
 for (PropertyValue pv : original) {</p>
<pre><code>if (pv.isConverted()) {
   deepCopy.add(pv);
}
else {
   String propertyName = pv.getName();
   Object originalValue = pv.getValue();
   Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
   Object convertedValue = resolvedValue;
   boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp;
         !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
   if (convertible) {
      convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
   }
   // Possibly store converted value in merged bean definition,
   // in order to avoid re-conversion for every created bean instance.
   if (resolvedValue == originalValue) {
      if (convertible) {
         pv.setConvertedValue(convertedValue);
      }
      deepCopy.add(pv);
   }
   else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;
         !((TypedStringValue) originalValue).isDynamic() &amp;&amp;
         !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
      pv.setConvertedValue(convertedValue);
      deepCopy.add(pv);
   }
   else {
      resolveNecessary = true;
      deepCopy.add(new PropertyValue(pv, convertedValue));
   }
}
</code></pre><p> }
 if (mpvs != null &amp;&amp; !resolveNecessary) {</p>
<pre><code>mpvs.setConverted();
</code></pre><p> }</p>
<p> // Set our (possibly massaged) deep copy.
 try {</p>
<pre><code>bw.setPropertyValues(new MutablePropertyValues(deepCopy));
</code></pre><p> }
 catch (BeansException ex) {</p>
<pre><code>throw new BeanCreationException(
      mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);
</code></pre><p> }
}</p>
</li>
<li><ul>
<li>3.3.5) initializeBean&#xFF08;&#x8C03;&#x7528;init-method&#x65B9;&#x6CD5;)</li>
</ul>
</li>
<li>AbstractAutowireCapableBeanFactory</li>
<li>&#x4E3B;&#x8981;&#x662F;&#x8C03;&#x7528;&#x7528;&#x6237;&#x8BBE;&#x5B9A;&#x7684;&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;&#xFF0C;&#x8FD8;&#x6709;&#x4E00;&#x4E9B;&#x5176;&#x4ED6;&#x5DE5;&#x4F5C;</li>
</ul>
<pre><code>protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
   if (System.getSecurityManager() != null) {
      AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
         @Override
         public Object run() {
</code></pre><ul>
<li><p>// &#x6FC0;&#x6D3B;Aware&#x65B9;&#x6CD5;</p>
<pre><code>      invokeAwareMethods(beanName, bean);
      return null;
   }
}, getAccessControlContext());
</code></pre><p> }
 else {</p>
<pre><code>invokeAwareMethods(beanName, bean);
</code></pre><p> }</p>
<p> Object wrappedBean = bean;
 if (mbd == null || !mbd.isSynthetic()) {</p>
</li>
<li><p>// &#x5E94;&#x7528;&#x540E;&#x5904;&#x7406;&#x5668;</p>
<pre><code>wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
</code></pre><p> }</p>
<p> try {</p>
</li>
<li><p>// &#x6FC0;&#x6D3B;&#x7528;&#x6237;&#x81EA;&#x5B9A;&#x4E49;&#x7684;init&#x65B9;&#x6CD5;</p>
<pre><code>invokeInitMethods(beanName, wrappedBean, mbd);
</code></pre><p> }
 catch (Throwable ex) {</p>
<pre><code>throw new BeanCreationException(
      (mbd != null ? mbd.getResourceDescription() : null),
      beanName, &quot;Invocation of init method failed&quot;, ex);
</code></pre><p> }</p>
<p> if (mbd == null || !mbd.isSynthetic()) {</p>
<pre><code>wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
</code></pre><p> }
 return wrappedBean;
}</p>
<ul>
<li>3.3.5.1) invokeAwareMethods</li>
</ul>
</li>
<li>Aware</li>
<li>Spring&#x4E2D;&#x63D0;&#x4F9B;&#x4E00;&#x4E9B;Aware&#x76F8;&#x5173;&#x63A5;&#x53E3;&#xFF0C;&#x6BD4;&#x5982;BeanFactoryAware&#x3001;ApplicationContextAware&#x7B49;&#xFF0C;&#x5B9E;&#x73B0;&#x8FD9;&#x4E9B;Aware&#x63A5;&#x53E3;&#x7684;bean&#x88AB;&#x521D;&#x59CB;&#x5316;&#x540E;&#xFF0C;&#x53EF;&#x4EE5;&#x53D6;&#x5F97;&#x4E00;&#x4E9B;&#x76F8;&#x5BF9;&#x5E94;&#x7684;&#x8D44;&#x6E90;&#x3002;</li>
<li>&#x5982;&#x5B9E;&#x73B0;BeanFactoryAware&#x7684;bean&#x5728;&#x521D;&#x59CB;&#x5316;&#x540E;&#xFF0C;Spring&#x5BB9;&#x5668;&#x5C06;&#x4F1A;&#x6CE8;&#x5165;BeanFactory&#x7684;&#x5B9E;&#x4F8B;&#x3002;</li>
</ul>
<pre><code>private void invokeAwareMethods(final String beanName, final Object bean) {
   if (bean instanceof Aware) {
      if (bean instanceof BeanNameAware) {
         ((BeanNameAware) bean).setBeanName(beanName);
      }
      if (bean instanceof BeanClassLoaderAware) {
         ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());
      }
      if (bean instanceof BeanFactoryAware) {
         ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
      }
   }
}
</code></pre><pre><code>- 3.3.5.2) BeanPostProcessor
</code></pre><ul>
<li>&#x8C03;&#x7528;&#x7528;&#x6237;&#x81EA;&#x5B9A;&#x4E49;&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;&#x4E4B;&#x524D;&#x548C;&#x4E4B;&#x540E;&#x5206;&#x522B;&#x4F1A;&#x8C03;&#x7528;BeanPostProcessor&#x7684;postProcessBeforeInitialization&#x548C;postProcessAfterInitialization&#x65B9;&#x6CD5;&#xFF0C;&#x4F7F; &#x7528;&#x6237;&#x53EF;&#x4EE5;&#x6839;&#x636E;&#x81EA;&#x5DF1;&#x7684;&#x4E1A;&#x52A1;&#x9700;&#x6C42;&#x8FDB;&#x884C;&#x54CD;&#x5E94;&#x7684;&#x5904;&#x7406;&#x3002;</li>
</ul>
<pre><code>public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
      throws BeansException {

   Object result = existingBean;
   for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
      result = beanProcessor.postProcessBeforeInitialization(result, beanName);
      if (result == null) {
         return result;
      }
   }
   return result;
}
</code></pre><pre><code>public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
      throws BeansException {

   Object result = existingBean;
   for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
      result = beanProcessor.postProcessAfterInitialization(result, beanName);
      if (result == null) {
         return result;
      }
   }
   return result;
}
</code></pre><pre><code>- 3.3.5.2.1) @PostConstructor
</code></pre><ul>
<li>&#x5F53;&#x4F7F;&#x7528;&#x8BE5;&#x6CE8;&#x89E3;&#x65F6;&#xFF0C;Spring&#x4F1A;&#x53BB;&#x6CE8;&#x518C;&#x4E00;&#x4E2A;BeanPostProcessor&#xFF1A;InitDestroyAnnotationBeanPostProcessor&#x3002;&#x8BE5;bean&#x4F1A;&#x540C;&#x81EA;&#x5B9A;&#x4E49;&#x7684;BeanPostProcessor&#x4E00;&#x6837;&#xFF0C;&#x5728;&#x81EA;&#x5B9A;&#x4E49;&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;&#x4E4B;&#x524D;&#x548C;&#x4E4B;&#x540E;&#x88AB;&#x8C03;&#x7528;&#xFF08;&#x5F53;&#x7136;@PostConstrcut&#x53EA;&#x4F1A;&#x5728;&#x4E4B;&#x524D;&#x88AB;&#x8C03;&#x7528;)&#x3002;</li>
<li>InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization</li>
</ul>
<pre><code>public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
   LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());
   try {
      metadata.invokeInitMethods(bean, beanName);
   }
   catch (InvocationTargetException ex) {
      throw new BeanCreationException(beanName, &quot;Invocation of init method failed&quot;, ex.getTargetException());
   }
   catch (Throwable ex) {
      throw new BeanCreationException(beanName, &quot;Couldn&apos;t invoke init method&quot;, ex);
   }
   return bean;
}
</code></pre><pre><code>- 3.3.5.2.1.1) findLifecycleMetadata
</code></pre><pre><code>private LifecycleMetadata findLifecycleMetadata(Class&lt;?&gt; clazz) {
   if (this.lifecycleMetadataCache == null) {
      // Happens after deserialization, during destruction...
      return buildLifecycleMetadata(clazz);
   }
   // Quick check on the concurrent map first, with minimal locking.
   LifecycleMetadata metadata = this.lifecycleMetadataCache.get(clazz);
   if (metadata == null) {
      synchronized (this.lifecycleMetadataCache) {
         metadata = this.lifecycleMetadataCache.get(clazz);
         if (metadata == null) {
            metadata = buildLifecycleMetadata(clazz);
            this.lifecycleMetadataCache.put(clazz, metadata);
         }
         return metadata;
      }
   }
   return metadata;
}
</code></pre><pre><code>private LifecycleMetadata buildLifecycleMetadata(final Class&lt;?&gt; clazz) {
   final boolean debug = logger.isDebugEnabled();
   LinkedList&lt;LifecycleElement&gt; initMethods = new LinkedList&lt;LifecycleElement&gt;();
   LinkedList&lt;LifecycleElement&gt; destroyMethods = new LinkedList&lt;LifecycleElement&gt;();
   Class&lt;?&gt; targetClass = clazz;

   do {
      final LinkedList&lt;LifecycleElement&gt; currInitMethods = new LinkedList&lt;LifecycleElement&gt;();
      final LinkedList&lt;LifecycleElement&gt; currDestroyMethods = new LinkedList&lt;LifecycleElement&gt;();

      ReflectionUtils.doWithLocalMethods(targetClass, new ReflectionUtils.MethodCallback() {
         @Override
         public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
            if (initAnnotationType != null) {
               if (method.getAnnotation(initAnnotationType) != null) {
                  LifecycleElement element = new LifecycleElement(method);
                  currInitMethods.add(element);
                  if (debug) {
                     logger.debug(&quot;Found init method on class [&quot; + clazz.getName() + &quot;]: &quot; + method);
                  }
               }
            }
            if (destroyAnnotationType != null) {
               if (method.getAnnotation(destroyAnnotationType) != null) {
                  currDestroyMethods.add(new LifecycleElement(method));
                  if (debug) {
                     logger.debug(&quot;Found destroy method on class [&quot; + clazz.getName() + &quot;]: &quot; + method);
                  }
               }
            }
         }
      });

      initMethods.addAll(0, currInitMethods);
      destroyMethods.addAll(currDestroyMethods);
      targetClass = targetClass.getSuperclass();
   }
   while (targetClass != null &amp;&amp; targetClass != Object.class);

   return new LifecycleMetadata(clazz, initMethods, destroyMethods);
}
</code></pre><pre><code>- 3.3.5.2.1.2) invokeInitMethods
</code></pre><pre><code>public void invokeInitMethods(Object target, String beanName) throws Throwable {
   Collection&lt;LifecycleElement&gt; initMethodsToIterate =
         (this.checkedInitMethods != null ? this.checkedInitMethods : this.initMethods);
   if (!initMethodsToIterate.isEmpty()) {
      boolean debug = logger.isDebugEnabled();
      for (LifecycleElement element : initMethodsToIterate) {
         if (debug) {
            logger.debug(&quot;Invoking init method on bean &apos;&quot; + beanName + &quot;&apos;: &quot; + element.getMethod());
         }
         element.invoke(target);
      }
   }
}
</code></pre><h5 id="3353-invokeinitmethods&#xFF08;&#x6FC0;&#x6D3B;&#x81EA;&#x5B9A;&#x4E49;&#x7684;init&#x65B9;&#x6CD5;"><a name="3353-invokeinitmethods&#xFF08;&#x6FC0;&#x6D3B;&#x81EA;&#x5B9A;&#x4E49;&#x7684;init&#x65B9;&#x6CD5;" class="plugin-anchor" href="#3353-invokeinitmethods&#xFF08;&#x6FC0;&#x6D3B;&#x81EA;&#x5B9A;&#x4E49;&#x7684;init&#x65B9;&#x6CD5;"><i class="fa fa-link" aria-hidden="true"></i></a>3.3.5.3) invokeInitMethods&#xFF08;&#x6FC0;&#x6D3B;&#x81EA;&#x5B9A;&#x4E49;&#x7684;init&#x65B9;&#x6CD5;)</h5>
<ul>
<li>&#x5BA2;&#x6237;&#x5B9A;&#x5236;&#x7684;&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;&#x9664;&#x4E86;&#x4F7F;&#x7528;&#x914D;&#x7F6E;init-method&#x5916;&#xFF0C;&#x8FD8;&#x53EF;&#x4EE5;&#x4F7F;&#x81EA;&#x5B9A;&#x4E49;&#x7684;bean&#x5B9E;&#x73B0;InitializingBean&#x63A5;&#x53E3;,&#x5E76;&#x5728;afterPropertiesSet&#x4E2D;&#x5B9E;&#x73B0;&#x81EA;&#x5DF1;&#x7684;&#x521D;&#x59CB;&#x5316;&#x4E1A;&#x52A1;&#x903B;&#x8F91;&#x3002;</li>
<li>init-method&#x548C;afterPropertiesSet&#x90FD;&#x662F;&#x5728;&#x521D;&#x59CB;&#x5316;bean&#x65F6;&#x6267;&#x884C;&#xFF0C;&#x6267;&#x884C;&#x987A;&#x5E8F;&#x662F;afterPropertiesSet&#x5148;&#x6267;&#x884C;&#xFF0C;init-method&#x540E;&#x6267;&#x884C;&#x3002;</li>
<li>&#x8BE5;&#x65B9;&#x6CD5;&#x4E2D;&#x5B9E;&#x73B0;&#x4E86;&#x8FD9;&#x4E24;&#x4E2A;&#x6B65;&#x9AA4;&#x7684;&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x3002;</li>
</ul>
<pre><code>protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)
      throws Throwable {
   // &#x9996;&#x5148;&#x68C0;&#x67E5;&#x662F;&#x5426;&#x662F;InitializingBean&#xFF0C;&#x5982;&#x679C;&#x662F;&#x7684;&#x8BDD;&#x9700;&#x8981;&#x8C03;&#x7528;afterPropertiesSet&#x65B9;&#x6CD5;
   boolean isInitializingBean = (bean instanceof InitializingBean);
   if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &apos;&quot; + beanName + &quot;&apos;&quot;);
      }
      if (System.getSecurityManager() != null) {
         try {
            AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() {
               @Override
               public Object run() throws Exception {
                  ((InitializingBean) bean).afterPropertiesSet();
                  return null;
               }
            }, getAccessControlContext());
         }
         catch (PrivilegedActionException pae) {
            throw pae.getException();
         }
      }
      else {
         ((InitializingBean) bean).afterPropertiesSet();
      }
   }

   if (mbd != null) {
      String initMethodName = mbd.getInitMethodName();
      if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;
            !mbd.isExternallyManagedInitMethod(initMethodName)) {
         invokeCustomInitMethod(beanName, bean, mbd);
      }
   }
}
</code></pre><ul>
<li><ul>
<li>3.3.5.3.1) invokeCustomInitMethod</li>
</ul>
</li>
</ul>
<pre><code>protected void invokeCustomInitMethod(String beanName, final Object bean, RootBeanDefinition mbd)
      throws Throwable {

   String initMethodName = mbd.getInitMethodName();
   final Method initMethod = (mbd.isNonPublicAccessAllowed() ?
         BeanUtils.findMethod(bean.getClass(), initMethodName) :
         ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));
   if (initMethod == null) {
      if (mbd.isEnforceInitMethod()) {
         throw new BeanDefinitionValidationException(&quot;Couldn&apos;t find an init method named &apos;&quot; +
               initMethodName + &quot;&apos; on bean with name &apos;&quot; + beanName + &quot;&apos;&quot;);
      }
      else {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;No default init method named &apos;&quot; + initMethodName +
                  &quot;&apos; found on bean with name &apos;&quot; + beanName + &quot;&apos;&quot;);
         }
         // Ignore non-existent default lifecycle methods.
         return;
      }
   }

   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Invoking init method  &apos;&quot; + initMethodName + &quot;&apos; on bean with name &apos;&quot; + beanName + &quot;&apos;&quot;);
   }

   if (System.getSecurityManager() != null) {
      AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() {
         @Override
         public Object run() throws Exception {
            ReflectionUtils.makeAccessible(initMethod);
            return null;
         }
      });
      try {
         AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() {
            @Override
            public Object run() throws Exception {
               initMethod.invoke(bean);
               return null;
            }
         }, getAccessControlContext());
      }
      catch (PrivilegedActionException pae) {
         InvocationTargetException ex = (InvocationTargetException) pae.getException();
         throw ex.getTargetException();
      }
   }
   else {
      try {
         ReflectionUtils.makeAccessible(initMethod);
         initMethod.invoke(bean);
      }
      catch (InvocationTargetException ex) {
         throw ex.getTargetException();
      }
   }
}
</code></pre><ul>
<li><ul>
<li>3.3.6) getSingleton(beanName,allowEarlyReference)</li>
</ul>
</li>
<li>protected Object getSingleton(String beanName, boolean allowEarlyReference) {
 Object singletonObject = this.singletonObjects.get(beanName);
 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {<pre><code>synchronized (this.singletonObjects) {
   singletonObject = this.earlySingletonObjects.get(beanName);
   if (singletonObject == null &amp;&amp; allowEarlyReference) {
      ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
      if (singletonFactory != null) {
         singletonObject = singletonFactory.getObject();
         this.earlySingletonObjects.put(beanName, singletonObject);
         this.singletonFactories.remove(beanName);
      }
   }
}
</code></pre> }
 return (singletonObject != NULL_OBJECT ? singletonObject : null);
}</li>
<li><ul>
<li>3.3.7) registerDisposableBeanIfNecessary&#xFF08;&#x6CE8;&#x518C;DisposableBean)</li>
</ul>
</li>
<li>&#x5BF9;&#x4E8E;&#x9500;&#x6BC1;&#x65B9;&#x6CD5;&#x7684;&#x6269;&#x5C55;&#xFF0C;&#x9664;&#x4E86;&#x914D;&#x7F6E;&#x5C5E;&#x6027;destroy-method&#xFF0C;&#x7528;&#x6237;&#x8FD8;&#x53EF;&#x4EE5;&#x6CE8;&#x518C;&#x540E;&#x5904;&#x7406;&#x5668;DestructionAwareBeanPostProcessor&#x6765;&#x7EDF;&#x4E00;&#x5904;&#x7406;bean&#x7684;&#x9500;&#x6BC1;&#x65B9;&#x6CD5;&#x3002;</li>
<li>protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
 AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
 if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) {<pre><code>if (mbd.isSingleton()) {
</code></pre></li>
<li>// &#x5355;&#x4F8B;&#x6A21;&#x5F0F;&#x4E0B;&#xFF0C;&#x6CE8;&#x518C;&#x9700;&#x8981;&#x9500;&#x6BC1;&#x7684;bean&#xFF0C;&#x6B64;&#x65B9;&#x6CD5;&#x4E2D;&#x4F1A;&#x5904;&#x7406;&#x5B9E;&#x73B0;DisposableBean&#x7684;bean&#xFF0C;&#x5E76;&#x4E14;&#x5BF9;&#x6240;&#x6709;&#x7684;bean&#x4F7F;&#x7528;DestructionAwareBeanPostProcessors&#x5904;&#x7406;
   // Register a DisposableBean implementation that performs all destruction
   // work for the given bean: DestructionAwareBeanPostProcessors,
   // DisposableBean interface, custom destroy method.
   registerDisposableBean(beanName,<pre><code>     new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
</code></pre>}
else {</li>
<li>// &#x81EA;&#x5B9A;&#x4E49;scope&#x7684;&#x5904;&#x7406;<pre><code>   // A bean with a custom scope...
   Scope scope = this.scopes.get(mbd.getScope());
   if (scope == null) {
      throw new IllegalStateException(&quot;No Scope registered for scope name &apos;&quot; + mbd.getScope() + &quot;&apos;&quot;);
   }
   scope.registerDestructionCallback(beanName,
         new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
}
</code></pre> }
}</li>
<li><ul>
<li>4) getObjectForBeanInstance&#xFF08;&#x4ECE;bean &#x7684;&#x5B9E;&#x4F8B;&#x4E2D;&#x83B7;&#x53D6;&#x5BF9;&#x8C61;)</li>
</ul>
</li>
<li>&#x65E0;&#x8BBA;&#x662F;&#x4ECE;&#x7F13;&#x5B58;&#x4E2D;&#x83B7;&#x53D6;&#x5230;&#x7684;bean&#x8FD8;&#x662F;&#x901A;&#x8FC7;&#x4E0D;&#x540C;&#x7684;scope&#x7B56;&#x7565;&#x52A0;&#x8F7D;&#x7684;bean&#x90FD;&#x53EA;&#x662F;&#x6700;&#x539F;&#x59CB;&#x7684;bean&#x72B6;&#x6001;&#xFF0C;&#x5E76;&#x4E0D;&#x4E00;&#x5B9A;&#x662F;&#x6211;&#x4EEC;&#x6700;&#x7EC8;&#x60F3;&#x8981;&#x7684;bean&#x3002;</li>
<li><p>&#x6BD4;&#x5982;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x5BF9;FactoryBean&#x8FDB;&#x884C;&#x5904;&#x7406;&#xFF0C;&#x90A3;&#x4E48;&#x8FD9;&#x91CC;&#x5F97;&#x5230;&#x7684;&#x5176;&#x5B9E;&#x662F;FactoryBean&#x7684;&#x521D;&#x59CB;&#x72B6;&#x6001;&#xFF0C;&#x4F46;&#x662F;&#x6211;&#x4EEC;&#x771F;&#x6B63;&#x9700;&#x8981;&#x7684;&#x662F;FactoryBean&#x4E2D;&#x5B9A;&#x4E49;&#x7684;factory-method&#xFF08;getObject&#x65B9;&#x6CD5;)&#x65B9;&#x6CD5;&#x4E2D;&#x8FD4;&#x56DE;&#x7684;bean&#xFF0C;&#x800C;getObjectForBeanInstance&#x5C31;&#x662F;&#x5B8C;&#x6210;&#x8FD9;&#x4E2A;&#x5DE5;&#x4F5C;&#x7684;&#x3002;</p>
</li>
<li><p>&#x4E0B;&#x9762;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x5B8C;&#x6210;&#x4E86;&#x4EE5;&#x4E0B;&#x4EFB;&#x52A1;&#xFF1A;</p>
<ul>
<li>1)&#x5BF9;FactoryBean&#x6B63;&#x786E;&#x6027;&#x7684;&#x9A8C;&#x8BC1;</li>
<li>2)&#x5BF9;&#x975E;FactoryBean&#x4E0D;&#x505A;&#x4EFB;&#x4F55;&#x5904;&#x7406;</li>
<li>3)&#x5BF9;bean&#x8FDB;&#x884C;&#x8F6C;&#x6362;</li>
<li>4)&#x5C06;&#x4ECE;Factory&#x89E3;&#x6790;bean&#x7684;&#x5DE5;&#x4F5C;&#x59D4;&#x6258;&#x7ED9;getObjectFromFactoryBean&#x3002;</li>
</ul>
</li>
<li><p>protected Object getObjectForBeanInstance(</p>
<pre><code>Object beanInstance, String name, String beanName, RootBeanDefinition mbd) {
</code></pre><p> // Don&apos;t let calling code try to dereference the factory if the bean isn&apos;t a factory.
 if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) {</p>
<pre><code>throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());
</code></pre><p> }</p>
<p> // Now we have the bean instance, which may be a normal bean or a FactoryBean.
 // If it&apos;s a FactoryBean, we use it to create a bean instance, unless the
 // caller actually wants a reference to the factory.
 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {</p>
<pre><code>return beanInstance;
</code></pre><p> }</p>
<p> Object object = null;
 if (mbd == null) {</p>
<pre><code>object = getCachedObjectForFactoryBean(beanName);
</code></pre><p> }
 if (object == null) {</p>
<pre><code>// Return bean instance from factory.
FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;
// Caches object obtained from FactoryBean if it is a singleton.
if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) {
   mbd = getMergedLocalBeanDefinition(beanName);
}
boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());
object = getObjectFromFactoryBean(factory, beanName, !synthetic);
</code></pre><p> }
 return object;
}</p>
<ul>
<li>4.1) getObjectFromFactoryBean&#xFF08;&#x4ECE;FactoryBean&#x4E2D;&#x89E3;&#x6790;bean)</li>
</ul>
</li>
<li>&#x8FD4;&#x56DE;&#x7684;bean&#x5982;&#x679C;&#x662F;&#x5355;&#x4F8B;&#x7684;&#xFF0C;&#x90A3;&#x5C31;&#x5FC5;&#x987B;&#x8981;&#x4FDD;&#x8BC1;&#x5168;&#x5C40;&#x552F;&#x4E00;&#xFF0C;&#x540C;&#x65F6;&#xFF0C;&#x4E5F;&#x56E0;&#x4E3A;&#x662F;&#x5355;&#x4F8B;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x4E0D;&#x5FC5;&#x91CD;&#x590D;&#x521B;&#x5EFA;&#xFF0C;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x7F13;&#x5B58;&#x6765;&#x63D0;&#x9AD8;&#x6027;&#x80FD;&#x3002;</li>
<li>protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {
 if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {<pre><code>synchronized (getSingletonMutex()) {
   Object object = this.factoryBeanObjectCache.get(beanName);
   if (object == null) {
      object = doGetObjectFromFactoryBean(factory, beanName);
      // Only post-process and store if not put there already during getObject() call above
      // (e.g. because of circular reference processing triggered by custom getBean calls)
      Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
      if (alreadyThere != null) {
         object = alreadyThere;
      }
      else {
         if (object != null &amp;&amp; shouldPostProcess) {
            try {
               object = postProcessObjectFromFactoryBean(object, beanName);
            }
            catch (Throwable ex) {
               throw new BeanCreationException(beanName,
                     &quot;Post-processing of FactoryBean&apos;s singleton object failed&quot;, ex);
            }
         }
         this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT));
      }
   }
   return (object != NULL_OBJECT ? object : null);
}
</code></pre> }
 else {<pre><code>Object object = doGetObjectFromFactoryBean(factory, beanName);
if (object != null &amp;&amp; shouldPostProcess) {
   try {
      object = postProcessObjectFromFactoryBean(object, beanName);
   }
   catch (Throwable ex) {
      throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean&apos;s object failed&quot;, ex);
   }
}
return object;
</code></pre> }
}<ul>
<li>4.1.1) doGetObjectFromFactoryBean</li>
</ul>
</li>
</ul>
<pre><code>private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName)
      throws BeanCreationException {

   Object object;
   try {
      if (System.getSecurityManager() != null) {
         AccessControlContext acc = getAccessControlContext();
         try {
            object = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() {
               @Override
               public Object run() throws Exception {
                     return factory.getObject();
                  }
               }, acc);
         }
         catch (PrivilegedActionException pae) {
            throw pae.getException();
         }
      }
      else {
         object = factory.getObject();
      }
   }
   catch (FactoryBeanNotInitializedException ex) {
      throw new BeanCurrentlyInCreationException(beanName, ex.toString());
   }
   catch (Throwable ex) {
      throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);
   }

   // Do not accept a null value for a FactoryBean that&apos;s not fully
   // initialized yet: Many FactoryBeans just return null then.
   if (object == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
      throw new BeanCurrentlyInCreationException(
            beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);
   }
   return object;
}
</code></pre><ul>
<li></li>
<li><p>&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;</p>
</li>
<li><p>Spring&#x5BB9;&#x5668;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x5305;&#x62EC;&#x6784;&#x9020;&#x5668;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x548C;setter&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x3002;</p>
</li>
<li><p>&#x6838;&#x5FC3;&#x5C31;&#x662F;singletonObjects&#x3001;singletonFactories&#x3001;earlySingletonObjects&#x548C;singletonsCurrentlyInCreation&#x56DB;&#x4E2A;&#x96C6;&#x5408;&#x3002;</p>
<ul>
<li>1)singletonObjects&#x662F;beanName&#x4E0E;beanInstance&#x7684;Map&#xFF0C;&#x662F;&#x771F;&#x6B63;&#x7684;&#x7F13;&#x5B58;&#xFF0C;beanInstance&#x662F;&#x6784;&#x9020;&#x5B8C;&#x6BD5;&#x7684;&#xFF0C;&#x51E1;&#x662F;&#x6B63;&#x5E38;&#x5730;&#x6784;&#x9020;&#x5B8C;&#x6BD5;&#x7684;&#x5355;&#x4F8B;bean&#x90FD;&#x4F1A;&#x653E;&#x5165;&#x7F13;&#x5B58;&#x4E2D;&#x3002;</li>
<li>2)earlySingletonObjects&#x4E5F;&#x662F;beanName&#x4E0E;beanInstance&#x7684;Map&#xFF0C;beanInstance&#x662F;&#x5DF2;&#x7ECF;&#x8C03;&#x7528;&#x4E86;createBean&#x65B9;&#x6CD5;&#xFF0C;&#x4F46;&#x662F;&#x6CA1;&#x6709;&#x6E05;&#x9664;&#x52A0;&#x8F7D;&#x72B6;&#x6001;&#x548C;&#x52A0;&#x5165;&#x81F3;&#x7F13;&#x5B58;&#x7684;bean&#x3002;&#x4EC5;&#x5728;&#x5F53;&#x524D;bean&#x521B;&#x5EFA;&#x65F6;&#x5B58;&#x5728;&#xFF0C;&#x7528;&#x4E8E;&#x68C0;&#x6D4B;&#x4EE3;&#x7406;bean&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x3002;</li>
<li>3)singleFactories&#x662F;beanName&#x4E0E;ObjectFactory&#x7684;Map&#xFF0C;&#x4EC5;&#x5728;&#x5F53;&#x524D;bean&#x521B;&#x5EFA;&#x65F6;&#x5B58;&#x5728;&#xFF0C;&#x662F;&#x5C1A;&#x672A;&#x8C03;&#x7528;createBean&#x7684;bean&#x3002;&#x7528;&#x4E8E;setter&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x65F6;&#x5B9E;&#x73B0;&#x6CE8;&#x5165;&#x3002;</li>
<li>4)singletonsCurrentlyInCreation&#x662F;beanName&#x7684;&#x96C6;&#x5408;&#xFF0C;&#x7528;&#x4E8E;&#x68C0;&#x6D4B;&#x6784;&#x9020;&#x5668;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x3002;</li>
</ul>
</li>
<li><p>getBean&#x5728;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x65F6;&#x6240;&#x6267;&#x884C;&#x7684;&#x6B65;&#x9AA4;&#x662F;&#x8FD9;&#x6837;&#x7684;&#xFF1A;</p>
<ul>
<li><p>1)&#x68C0;&#x6D4B;&#x5F53;&#x524D;bean&#x662F;&#x5426;&#x5728;singletonObjects&#x4E2D;&#xFF0C;&#x5728;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x7F13;&#x5B58;&#x597D;&#x7684;bean&#xFF1B;&#x4E0D;&#x5728;&#x5219;&#x68C0;&#x6D4B;&#x662F;&#x5426;&#x5728;singletonFactories&#x4E2D;&#xFF0C;&#x5728;&#xFF0C;&#x5219;&#x8C03;&#x7528;&#x5176;getObject&#x65B9;&#x6CD5;&#xFF0C;&#x8FD4;&#x56DE;&#xFF0C;&#x5E76;&#x4ECE;singletonFactories&#x4E2D;&#x79FB;&#x9664;&#xFF0C;&#x52A0;&#x5165;&#x5230;earlySingletonObjects&#x4E2D;&#x3002;</p>
</li>
<li><p>2)&#x6B63;&#x5E38;&#x521B;&#x5EFA;&#xFF0C;beforeSingletonCreation:&#x68C0;&#x6D4B;&#x5F53;&#x524D;bean&#x662F;&#x5426;&#x5728;singletonsCurrentlyInCreation&#xFF0C;&#x5982;&#x679C;&#x5B58;&#x5728;&#xFF0C;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002;&#x8868;&#x793A;&#x5B58;&#x5728;&#x6784;&#x9020;&#x5668;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x5219;&#x5C06;&#x5F53;&#x524D;bean&#x52A0;&#x5165;&#x3002;</p>
</li>
<li><p>3)bean&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x5206;&#x4E3A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x521D;&#x59CB;&#x5316;&#x3001;&#x5DE5;&#x5382;&#x65B9;&#x6CD5;&#x521D;&#x59CB;&#x5316;&#x548C;&#x7B80;&#x5355;&#x521D;&#x59CB;&#x5316;&#x3002;&#x5982;&#x679C;&#x662F;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x90A3;&#x4E48;&#x9012;&#x5F52;&#x5730;&#x83B7;&#x53D6;&#x53C2;&#x6570;bean&#x3002;&#x5176;&#x4ED6;&#x60C5;&#x51B5;&#x4E0D;&#x4F1A;&#x9012;&#x5F52;&#x83B7;&#x53D6;bean&#x3002;</p>
</li>
<li><p>4)addSingletonFactory:&#x5982;&#x679C;&#x5F53;&#x524D;bean&#x4E0D;&#x5728;singletonObjects&#x4E2D;&#xFF0C;&#x5219;&#x5C06;&#x5F53;&#x524D;bean&#x52A0;&#x5165;&#x5230;singletonFactories&#x4E2D;&#xFF08;getObject&#x65B9;&#x6CD5;&#x662F;getEarlyBeanReference)&#xFF0C;&#x5E76;&#x4ECE;earlySingletonObjects&#x4E2D;&#x79FB;&#x9664;&#x3002;</p>
</li>
<li><p>5)&#x586B;&#x5145;&#x5C5E;&#x6027;&#xFF0C;&#x7B80;&#x5355;&#x521D;&#x59CB;&#x5316;&#x7684;&#x8BDD;&#x4F1A;&#x9012;&#x5F52;&#x521B;&#x5EFA;&#x6240;&#x4F9D;&#x8D56;&#x7684;bean&#x3002;</p>
</li>
<li>6)&#x8C03;&#x7528;&#x7528;&#x6237;&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;&#xFF0C;&#x6BD4;&#x5982;BeanPostProcesser&#x3001;InitializingBean&#x3001;init-method&#xFF0C;&#x6709;&#x53EF;&#x80FD;&#x8FD4;&#x56DE;&#x4EE3;&#x7406;&#x540E;&#x7684;bean&#x3002;</li>
<li><p>6) &#x68C0;&#x6D4B;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF0C;&#x5982;&#x679C;&#x5F53;&#x524D;bean&#x5728;singletonObjects&#x4E2D;&#xFF0C;&#x5219;&#x5224;&#x65AD;&#x5F53;&#x524D;bean(current bean)&#x4E0E;singletonObjects&#x4E2D;&#x7684;bean(cached bean)&#x662F;&#x5426;&#x662F;&#x540C;&#x4E00;&#x4E2A;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x662F;&#xFF0C;&#x90A3;&#x4E48;&#x8BF4;&#x660E;&#x5F53;&#x524D;bean&#x662F;&#x88AB;&#x4EE3;&#x7406;&#x8FC7;&#x7684;&#xFF0C;&#x7531;&#x4E8E;&#x4F9D;&#x8D56;&#x5F53;&#x524D;bean&#x7684;bean&#x6301;&#x6709;&#x7684;&#x662F;&#x5BF9;cached bean&#x7684;&#x5F15;&#x7528;&#xFF0C;&#x8FD9;&#x662F;&#x4E0D;&#x88AB;&#x5141;&#x8BB8;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x4F1A;&#x629B;&#x51FA;BeanCurrentlyInCreationException&#x5F02;&#x5E38;&#x3002;</p>
</li>
<li><p>7)afterSingletonCreation:&#x5C06;&#x5F53;&#x524D;bean&#x4ECE;singletonsCurrentlyInCreation&#x4E2D;&#x5220;&#x9664;</p>
</li>
<li>8)addSingleton:&#x5C06;&#x5F53;&#x524D;bean&#x52A0;&#x5165;&#x5230;singletonObjects&#xFF0C;&#x7136;&#x540E;&#x4ECE;singletonFactories, earlySingletonObjects&#x4E2D;&#x79FB;&#x9664;&#xFF0C;&#x7ED3;&#x675F;</li>
</ul>
</li>
<li>&#x6784;&#x9020;&#x5668;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;</li>
<li>&#x8868;&#x793A;&#x901A;&#x8FC7;&#x6784;&#x9020;&#x5668;&#x6CE8;&#x5165;&#x6784;&#x6210;&#x7684;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF0C;&#x6B64;&#x4F9D;&#x8D56;&#x662F;&#x65E0;&#x6CD5;&#x89E3;&#x51B3;&#x7684;&#xFF0C;&#x53EA;&#x80FD;&#x629B;&#x51FA;BeanCurrentlyInCreationException&#x5F02;&#x5E38;&#x8868;&#x793A;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x3002;</li>
<li>1&#x3001;Spring&#x5BB9;&#x5668;&#x521B;&#x5EFA;&#x5355;&#x4F8B;&#x201C;A&#x201D; Bean&#xFF0C;&#x9996;&#x5148;&#x68C0;&#x6D4B;singletonFactories&#x662F;&#x5426;&#x5305;&#x542B;A&#xFF0C;&#x53D1;&#x73B0;&#x6CA1;&#x6709;&#xFF0C;&#x4E8E;&#x662F;&#x6B63;&#x5E38;&#x521B;&#x5EFA;&#xFF0C;&#x7136;&#x540E;&#x68C0;&#x6D4B;A&#x662F;&#x5426;&#x5305;&#x542B;&#x5728;singletonsCurrentlyInCreation&#x4E2D;&#xFF0C;&#x6CA1;&#x6709;&#xFF0C;&#x5219;&#x5C06;A&#x653E;&#x5165;&#x3002;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x521D;&#x59CB;&#x5316;&#x65F6;&#x9700;&#x8981;B&#x5B9E;&#x4F8B;&#xFF08;A&#x5C1A;&#x672A;&#x653E;&#x5165;&#x5230;singletonFactories&#x4E2D;)&#xFF0C;&#x4E8E;&#x662F;&#x8C03;&#x7528;&#x4E86;getBean(B)&#x65B9;&#x6CD5;&#x3001;</li>
<li>2&#x3001;Spring&#x5BB9;&#x5668;&#x521B;&#x5EFA;&#x5355;&#x4F8B;&#x201C;B&#x201D; Bean&#xFF0C;&#x9996;&#x5148;&#x68C0;&#x6D4B;singletonFactories&#x662F;&#x5426;&#x5305;&#x542B;B&#xFF0C;&#x53D1;&#x73B0;&#x6CA1;&#x6709;&#xFF0C;&#x4E8E;&#x662F;&#x6B63;&#x5E38;&#x521B;&#x5EFA;&#xFF0C;&#x7136;&#x540E;&#x68C0;&#x6D4B;B&#x662F;&#x5426;&#x5305;&#x542B;&#x5728;singletonsCurrentlyInCreation&#x4E2D;&#xFF0C;&#x6CA1;&#x6709;&#xFF0C;&#x5219;&#x5C06;B&#x653E;&#x5165;&#x3002;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x521D;&#x59CB;&#x5316;&#x65F6;&#x9700;&#x8981;C&#x5B9E;&#x4F8B;&#xFF08;B&#x5C1A;&#x672A;&#x653E;&#x5165;&#x5230;singletonFactories&#x4E2D;)&#xFF0C;&#x4E8E;&#x662F;&#x8C03;&#x7528;&#x4E86;getBean(C)&#x65B9;&#x6CD5;&#x3001;</li>
<li>3&#x3001;Spring&#x5BB9;&#x5668;&#x521B;&#x5EFA;&#x5355;&#x4F8B;&#x201C;C&#x201D; Bean&#xFF0C;&#x9996;&#x5148;&#x68C0;&#x6D4B;singletonFactories&#x662F;&#x5426;&#x5305;&#x542B;C&#xFF0C;&#x53D1;&#x73B0;&#x6CA1;&#x6709;&#xFF0C;&#x4E8E;&#x662F;&#x6B63;&#x5E38;&#x521B;&#x5EFA;&#xFF0C;&#x7136;&#x540E;&#x68C0;&#x6D4B;C&#x662F;&#x5426;&#x5305;&#x542B;&#x5728;singletonsCurrentlyInCreation&#x4E2D;&#xFF0C;&#x6CA1;&#x6709;&#xFF0C;&#x5219;&#x5C06;C&#x653E;&#x5165;&#x3002;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x521D;&#x59CB;&#x5316;&#x65F6;&#x9700;&#x8981;A&#x5B9E;&#x4F8B;&#xFF08;C&#x5C1A;&#x672A;&#x653E;&#x5165;&#x5230;singletonFactories&#x4E2D;)&#xFF0C;&#x4E8E;&#x662F;&#x8C03;&#x7528;&#x4E86;getBean(A)&#x65B9;&#x6CD5;&#x3001;</li>
<li>4&#x3001;Spring&#x5BB9;&#x5668;&#x521B;&#x5EFA;&#x5355;&#x4F8B;&#x201C;A&#x201D; Bean&#xFF0C;&#x9996;&#x5148;&#x68C0;&#x6D4B;singletonFactories&#x662F;&#x5426;&#x5305;&#x542B;A&#xFF0C;&#x53D1;&#x73B0;&#x6CA1;&#x6709;&#x4E8E;&#x662F;&#x6B63;&#x5E38;&#x521B;&#x5EFA;&#xFF0C;&#x7136;&#x540E;&#x68C0;&#x6D4B;A&#x662F;&#x5426;&#x5305;&#x542B;&#x5728;singletonsCurrentlyInCreation&#x4E2D;&#xFF0C;&#x6709;&#xFF0C;&#x629B;&#x51FA;BeanCurrentlyInCreationException&#x5F02;&#x5E38;&#x3002;</li>
<li>setter&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;</li>
<li>&#x8868;&#x793A;&#x901A;&#x8FC7;setter&#x6CE8;&#x5165;&#x65B9;&#x5F0F;&#x6784;&#x6210;&#x7684;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x3002;</li>
<li>&#x5BF9;&#x4E8E;setter&#x6CE8;&#x5165;&#x9020;&#x6210;&#x7684;&#x4F9D;&#x8D56;&#x662F;&#x901A;&#x8FC7;Spring&#x5BB9;&#x5668;&#x63D0;&#x524D;&#x66B4;&#x9732;&#x521A;&#x5B8C;&#x6210;&#x6784;&#x9020;&#x5668;&#x6CE8;&#x5165;&#x4F46;&#x672A;&#x5B8C;&#x6210;&#x5176;&#x4ED6;&#x6B65;&#x9AA4;&#xFF08;&#x5982;setter&#x6CE8;&#x5165;)&#x7684;Bean&#x6765;&#x5B8C;&#x6210;&#x7684;&#xFF0C;&#x800C;&#x4E14;&#x53EA;&#x80FD;&#x89E3;&#x51B3;&#x5355;&#x4F8B;&#x4F5C;&#x7528;&#x57DF;&#x7684;Bean&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#x3002;</li>
<li>1&#x3001;Spring&#x5BB9;&#x5668;&#x521B;&#x5EFA;&#x5355;&#x4F8B;&#x201C;A&#x201D; Bean&#xFF0C;&#x9996;&#x5148;&#x68C0;&#x6D4B;singletonFactories&#x662F;&#x5426;&#x5305;&#x542B;A&#xFF0C;&#x53D1;&#x73B0;&#x6CA1;&#x6709;&#xFF0C;&#x4E8E;&#x662F;&#x6B63;&#x5E38;&#x521B;&#x5EFA;&#xFF0C;&#x7136;&#x540E;&#x68C0;&#x6D4B;A&#x662F;&#x5426;&#x5305;&#x542B;&#x5728;singletonsCurrentlyInCreation&#x4E2D;&#xFF0C;&#x6CA1;&#x6709;&#xFF0C;&#x5219;&#x5C06;A&#x653E;&#x5165;&#x3002;&#x6CE8;&#x5165;&#x5C5E;&#x6027;&#x65F6;&#x9700;&#x8981;B&#x5B9E;&#x4F8B;&#xFF0C;&#x4E8E;&#x662F;&#x8C03;&#x7528;&#x4E86;getBean(B)&#x65B9;&#x6CD5;&#x3001;</li>
<li>2&#x3001;Spring&#x5BB9;&#x5668;&#x521B;&#x5EFA;&#x5355;&#x4F8B;&#x201C;B&#x201D; Bean&#xFF0C;&#x9996;&#x5148;&#x68C0;&#x6D4B;singletonFactories&#x662F;&#x5426;&#x5305;&#x542B;B&#xFF0C;&#x53D1;&#x73B0;&#x6CA1;&#x6709;&#xFF0C;&#x4E8E;&#x662F;&#x6B63;&#x5E38;&#x521B;&#x5EFA;&#xFF0C;&#x7136;&#x540E;&#x68C0;&#x6D4B;B&#x662F;&#x5426;&#x5305;&#x542B;&#x5728;singletonsCurrentlyInCreation&#x4E2D;&#xFF0C;&#x6CA1;&#x6709;&#xFF0C;&#x5219;&#x5C06;B&#x653E;&#x5165;&#x3002;&#x6CE8;&#x5165;&#x5C5E;&#x6027;&#x65F6;&#x9700;&#x8981;C&#x5B9E;&#x4F8B;&#xFF0C;&#x4E8E;&#x662F;&#x8C03;&#x7528;&#x4E86;getBean(C)&#x65B9;&#x6CD5;&#x3001;</li>
<li>3&#x3001;Spring&#x5BB9;&#x5668;&#x521B;&#x5EFA;&#x5355;&#x4F8B;&#x201C;C&#x201D; Bean&#xFF0C;&#x9996;&#x5148;&#x68C0;&#x6D4B;singletonFactories&#x662F;&#x5426;&#x5305;&#x542B;C&#xFF0C;&#x53D1;&#x73B0;&#x6CA1;&#x6709;&#xFF0C;&#x4E8E;&#x662F;&#x6B63;&#x5E38;&#x521B;&#x5EFA;&#xFF0C;&#x7136;&#x540E;&#x68C0;&#x6D4B;C&#x662F;&#x5426;&#x5305;&#x542B;&#x5728;singletonsCurrentlyInCreation&#x4E2D;&#xFF0C;&#x6CA1;&#x6709;&#xFF0C;&#x5219;&#x5C06;C&#x653E;&#x5165;&#x3002;&#x6CE8;&#x5165;&#x5C5E;&#x6027;&#x65F6;&#x9700;&#x8981;A&#x5B9E;&#x4F8B;&#xFF0C;&#x4E8E;&#x662F;&#x8C03;&#x7528;&#x4E86;getBean(A)&#x65B9;&#x6CD5;&#x3001;</li>
<li>4&#x3001;Spring&#x5BB9;&#x5668;&#x521B;&#x5EFA;&#x5355;&#x4F8B;&#x201C;A&#x201D; Bean&#xFF0C;&#x9996;&#x5148;&#x68C0;&#x6D4B;singletonFactories&#x662F;&#x5426;&#x5305;&#x542B;A&#xFF0C;&#x53D1;&#x73B0;&#x6709;&#xFF0C;&#x4E8E;&#x662F;&#x8FD4;&#x56DE;&#x7F13;&#x5B58;&#x4E86;&#x7684;bean&#xFF0C;&#x5E76;&#x5C06;A&#x4ECE;singletonFactories&#x5220;&#x9664;&#xFF0C;&#x8FD4;&#x56DE;A&#x5B9E;&#x4F8B;&#x3002;</li>
<li><p>5&#x3001;C&#x5F97;&#x5230;A&#x5B9E;&#x4F8B;&#x3002;set&#x8FDB;&#x6765;&#xFF0C;B&#x3001;A&#x4E5F;&#x662F;&#x8FD9;&#x6837;&#x3002;&#x7ED3;&#x675F;&#x3002;</p>
</li>
<li><p>&#x5BF9;&#x4E8E;&#x201C;prototype&#x201D;&#x4F5C;&#x7528;&#x57DF;Bean&#xFF0C;Spring&#x5BB9;&#x5668;&#x65E0;&#x6CD5;&#x5B8C;&#x6210;&#x4F9D;&#x8D56;&#x6CE8;&#x5165;&#xFF0C;&#x56E0;&#x4E3A;&#x201C;prototype&#x201D;&#x4F5C;&#x7528;&#x57DF;&#x7684;Bean&#xFF0C;Spring&#x5BB9;&#x5668;&#x4E0D;&#x8FDB;&#x884C;&#x7F13;&#x5B58;&#xFF0C;&#x56E0;&#x6B64;&#x65E0;&#x6CD5;&#x63D0;&#x524D;&#x66B4;&#x9732;&#x4E00;&#x4E2A;&#x521B;&#x5EFA;&#x4E2D;&#x7684;Bean&#x3002;</p>
</li>
<li></li>
<li><p>&#x5B9E;&#x4F8B;</p>
</li>
</ul>
<pre><code>public class Main {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);
        userService.login();
    }
}
</code></pre><h1 id="&#x5B9E;&#x4F8B;&#x2014;&#x2014;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;"><a name="&#x5B9E;&#x4F8B;&#x2014;&#x2014;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;" class="plugin-anchor" href="#&#x5B9E;&#x4F8B;&#x2014;&#x2014;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;"><i class="fa fa-link" aria-hidden="true"></i></a>&#x5B9E;&#x4F8B;&#x2014;&#x2014;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;</h1>
<h2 id="&#x6CE8;&#x89E3;&#x6CE8;&#x5165;"><a name="&#x6CE8;&#x89E3;&#x6CE8;&#x5165;" class="plugin-anchor" href="#&#x6CE8;&#x89E3;&#x6CE8;&#x5165;"><i class="fa fa-link" aria-hidden="true"></i></a>&#x6CE8;&#x89E3;&#x6CE8;&#x5165;</h2>
<pre><code>public class A {
    @Autowired
    private B b;
}
</code></pre><pre><code>public class B {
    @Autowired
    private C c;
}
</code></pre><pre><code>public class C {
    @Autowired
    private A a;
}
</code></pre><pre><code>- 1)&#x521B;&#x5EFA;A&#x65F6;&#x8C03;&#x7528;beforeSingletonCreation

- 2)&#x8C03;&#x7528;doCreateBean&#x65F6;earlySingletonExposure&#x4E3A;true&#xFF0C;&#x8C03;&#x7528;&#x4E86;addSingletonFactory
</code></pre><ul>
<li>&#x6CE8;&#x610F;&#xFF0C;&#x5E76;&#x6CA1;&#x6709;&#x9012;&#x5F52;&#x53BB;&#x521D;&#x59CB;&#x5316;B&#xFF0C;&#x8FD4;&#x56DE;&#x5B83;&#x6240;&#x4F9D;&#x8D56;&#x7684;bean&#x65F6;&#x5F97;&#x5230;&#x7684;&#x662F;null&#x3002;</li>
</ul>
<pre><code>- 3)&#x7136;&#x540E;&#x8C03;&#x7528;populateBean&#xFF0C;&#x5728;postProcesser&#x5904;&#x7406;&#x65F6;&#x8C03;&#x7528;&#x4E86;
- AutowiredAnnotationBeanPostProcesser#postProcessPropertyValues&#xFF0C;&#x6700;&#x7EC8;&#x8C03;&#x7528;&#x4E86;3.3.4.2.1.1.1) findAutowireCandidates&#xFF0C;&#x5B83;&#x8C03;&#x7528;&#x4E86;A&#x6240;&#x4F9D;&#x8D56;&#x7684;B&#x7684;getBean&#x65B9;&#x6CD5;&#x3002;
- 4)B&#x7684;getBean&#x65F6;&#x8C03;&#x7528;&#x4E86;beforeSingletonCreation&#xFF0C;

- 5)&#x8C03;&#x7528;doCreateBean&#x65F6;earlySingletonExposure&#x4E3A;true&#xFF0C;&#x8C03;&#x7528;&#x4E86;addSingletonFactory
</code></pre><ul>
<li><p>&#x6CE8;&#x610F;&#xFF0C;&#x5E76;&#x6CA1;&#x6709;&#x9012;&#x5F52;&#x53BB;&#x521D;&#x59CB;&#x5316;C&#xFF0C;&#x8FD4;&#x56DE;&#x5B83;&#x6240;&#x4F9D;&#x8D56;&#x7684;bean&#x65F6;&#x5F97;&#x5230;&#x7684;&#x662F;null&#x3002;</p>
<ul>
<li>6)&#x7136;&#x540E;&#x8C03;&#x7528;populateBean&#xFF0C;&#x5728;postProcesser&#x5904;&#x7406;&#x65F6;&#x8C03;&#x7528;&#x4E86;</li>
<li>AutowiredAnnotationBeanPostProcesser#postProcessPropertyValues&#xFF0C;&#x6700;&#x7EC8;&#x8C03;&#x7528;&#x4E86;3.3.4.2.1.1.1) findAutowireCandidates&#xFF0C;&#x5B83;&#x8C03;&#x7528;&#x4E86;B&#x6240;&#x4F9D;&#x8D56;&#x7684;C&#x7684;getBean&#x65B9;&#x6CD5;&#x3002;</li>
<li><p>7)B&#x7684;getBean&#x65F6;&#x8C03;&#x7528;&#x4E86;beforeSingletonCreation&#xFF0C;</p>
</li>
<li><p>8)&#x8C03;&#x7528;doCreateBean&#x65F6;earlySingletonExposure&#x4E3A;true&#xFF0C;&#x8C03;&#x7528;&#x4E86;addSingletonFactory</p>
</li>
</ul>
</li>
<li><p>&#x6CE8;&#x610F;&#xFF0C;&#x5E76;&#x6CA1;&#x6709;&#x9012;&#x5F52;&#x53BB;&#x521D;&#x59CB;&#x5316;A&#xFF0C;&#x8FD4;&#x56DE;&#x5B83;&#x6240;&#x4F9D;&#x8D56;&#x7684;bean&#x65F6;&#x5F97;&#x5230;&#x7684;&#x662F;null&#x3002;</p>
<ul>
<li>9)&#x7136;&#x540E;&#x8C03;&#x7528;populateBean&#xFF0C;&#x5728;postProcesser&#x5904;&#x7406;&#x65F6;&#x8C03;&#x7528;&#x4E86;</li>
<li>AutowiredAnnotationBeanPostProcesser#postProcessPropertyValues&#xFF0C;&#x6700;&#x7EC8;&#x8C03;&#x7528;&#x4E86;3.3.4.2.1.1.1) findAutowireCandidates&#xFF0C;&#x5B83;&#x8C03;&#x7528;&#x4E86;C&#x6240;&#x4F9D;&#x8D56;&#x7684;A&#x7684;getBean&#x65B9;&#x6CD5;&#x3002;</li>
</ul>
</li>
<li>10)A&#x5728;&#x8C03;&#x7528;getSingleton&#x65F6;&#x53D1;&#x73B0;singletonFactories&#x5B58;&#x5728;CircleA&#xFF0C;&#x7136;&#x540E;&#x8C03;&#x7528;&#x5176;getObject&#x65B9;&#x6CD5;&#xFF08;&#x8C03;&#x7528;&#x4E86;getEarlyReference)&#xFF0C;&#x4E4B;&#x540E;&#x5C06;CircleA&#x653E;&#x5165;earlySingletonObjects&#xFF0C;&#x7136;&#x540E;&#x4ECE;singletonFactories&#x4E2D;&#x79FB;&#x9664;&#x3002;</li>
</ul>
<pre><code>- 11)&#x4ECE;getBean(CircleA)&#x4E2D;&#x8FD4;&#x56DE;&#xFF0C;&#x56DE;&#x5230;CircleC&#x7684;findAutowireCandidates&#xFF0C;&#x7136;&#x540E;&#x5E26;&#x7740;CircleA&#x5B9E;&#x4F8B;&#x56DE;&#x5230;&#x4E86;inject&#x65B9;&#x6CD5;&#xFF0C;&#x5C06;CircleA&#x5B9E;&#x4F8B;&#x8BBE;&#x7F6E;&#x7ED9;&#x4E86;CircleC&#x3002;
- 12)CircleC&#x53BB;&#x68C0;&#x6D4B;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF0C;&#x6CA1;&#x6709;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF0C;&#x8FD4;&#x56DE;bean&#x3002;
- 13)&#x5728;&#x8C03;&#x7528;getSingleton&#x65F6;&#x53D1;&#x73B0;singletonFactories&#x5B58;&#x5728;CircleA&#xFF0C;&#x7136;&#x540E;&#x8C03;&#x7528;&#x5176;getObject&#x65B9;&#x6CD5;&#xFF08;&#x8C03;&#x7528;&#x4E86;getEarlyReference)&#xFF0C;&#x4E4B;&#x540E;&#x5C06;CircleA&#x653E;&#x5165;earlySingletonObjects&#xFF0C;&#x7136;&#x540E;&#x4ECE;singletonFactories&#x4E2D;&#x79FB;&#x9664;&#x3002;
- 13)&#x4ECE;getBean(CircleC)&#x4E2D;&#x8FD4;&#x56DE;&#xFF0C;&#x56DE;&#x5230;CircleB&#x7684;findAutowireCandidates&#xFF0C;&#x7136;&#x540E;&#x5E26;&#x7740;CircleC&#x5B9E;&#x4F8B;&#x56DE;&#x5230;&#x4E86;inject&#x65B9;&#x6CD5;&#xFF0C;&#x5C06;CircleC&#x5B9E;&#x4F8B;&#x8BBE;&#x7F6E;&#x7ED9;&#x4E86;CircleB&#x3002;
- 14)CircleB&#x53BB;&#x68C0;&#x6D4B;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF0C;&#x6CA1;&#x6709;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF0C;&#x8FD4;&#x56DE;bean&#x3002;
- 15)&#x4ECE;getBean(CircleB)&#x4E2D;&#x8FD4;&#x56DE;&#xFF0C;&#x56DE;&#x5230;CircleA&#x7684;findAutowireCandidates&#xFF0C;&#x7136;&#x540E;&#x5E26;&#x7740;CircleB&#x5B9E;&#x4F8B;&#x56DE;&#x5230;&#x4E86;inject&#x65B9;&#x6CD5;&#xFF0C;&#x5C06;CircleB&#x5B9E;&#x4F8B;&#x8BBE;&#x7F6E;&#x7ED9;&#x4E86;CircleA&#x3002;
- 16)CircleA&#x53BB;&#x68C0;&#x6D4B;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF0C;&#x6CA1;&#x6709;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF0C;&#x8FD4;&#x56DE;bean&#x3002;&#x7ED3;&#x675F;&#x3002;
</code></pre><h2 id="setter&#x6CE8;&#x5165;"><a name="setter&#x6CE8;&#x5165;" class="plugin-anchor" href="#setter&#x6CE8;&#x5165;"><i class="fa fa-link" aria-hidden="true"></i></a>setter&#x6CE8;&#x5165;</h2>
<pre><code>public class A {
    private B b;

    @Autowired
    public void setB(B b) {
        this.b = b;
    }
}
</code></pre><pre><code>public class B {
    private C c;
    @Autowired
    public C getC() {
        return c;
    }
}
</code></pre><pre><code>public class C {
    private A a;

    @Autowired
    public void setA(A a) {
        this.a = a;
    }
}
</code></pre><ul>
<li>&#x8C03;&#x7528;&#x6808;&#x4E0E;&#x6CE8;&#x89E3;&#x6CE8;&#x5165;&#x4E00;&#x81F4;</li>
</ul>
<h2 id="&#x6784;&#x9020;&#x5668;&#x6CE8;&#x5165;&#xFF08;&#x629B;&#x51FA;beancurrentlyincreationexception&#x5F02;&#x5E38;"><a name="&#x6784;&#x9020;&#x5668;&#x6CE8;&#x5165;&#xFF08;&#x629B;&#x51FA;beancurrentlyincreationexception&#x5F02;&#x5E38;" class="plugin-anchor" href="#&#x6784;&#x9020;&#x5668;&#x6CE8;&#x5165;&#xFF08;&#x629B;&#x51FA;beancurrentlyincreationexception&#x5F02;&#x5E38;"><i class="fa fa-link" aria-hidden="true"></i></a>&#x6784;&#x9020;&#x5668;&#x6CE8;&#x5165;&#xFF08;&#x629B;&#x51FA;BeanCurrentlyInCreationException&#x5F02;&#x5E38;)</h2>
<pre><code>public class A {
    private B b;
    @Autowired
    public A(B b) {
        this.b = b;
    }
}
</code></pre><ul>
<li>&#x6B65;&#x9AA4;&#x7C7B;&#x4F3C;&#xFF0C;&#x53EA;&#x6709;&#x4E24;&#x4E2A;&#x5730;&#x65B9;&#x4E0D;&#x540C;&#x3002;<ul>
<li>1)&#x8C03;&#x7528;doCreateBean&#x65F6;&#xFF0C;&#x4F1A;&#x91C7;&#x7528;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x521D;&#x59CB;&#x5316;&#x7684;&#x65B9;&#x5F0F;&#xFF0C;&#x6B64;&#x65F6;&#x4F1A;&#x9012;&#x5F52;&#x5730;&#x521D;&#x59CB;&#x5316;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53C2;&#x6570;bean&#x3002;&#x56E0;&#x4E3A;&#x662F;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x6240;&#x4EE5;&#x9012;&#x5F52;&#x83B7;&#x53D6;&#x53C2;&#x6570;bean&#x662F;&#x5728;&#x5C06;&#x81EA;&#x5DF1;&#x653E;&#x5165;singletonFactories&#x4E4B;&#x524D;&#x3002;</li>
<li>2)&#x6B63;&#x56E0;&#x4E3A;&#x6CA1;&#x6709;&#x5C06;&#x81EA;&#x5DF1;&#x653E;&#x5165;singletonFactories&#xFF0C;&#x6240;&#x4EE5;&#x4E0D;&#x4F1A;&#x5728;getBean&#x4ECE;singletonFactories&#x8FD4;&#x56DE;&#x5DF2;&#x7ECF;&#x521B;&#x5EFA;&#x8FC7;&#x7684;bean&#x3002;</li>
</ul>
</li>
</ul>
<h2 id="&#x5B58;&#x5728;&#x4EE3;&#x7406;&#x65F6;&#x7684;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF08;&#x629B;&#x51FA;beancurrentlyincreationexception&#x5F02;&#x5E38;"><a name="&#x5B58;&#x5728;&#x4EE3;&#x7406;&#x65F6;&#x7684;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF08;&#x629B;&#x51FA;beancurrentlyincreationexception&#x5F02;&#x5E38;" class="plugin-anchor" href="#&#x5B58;&#x5728;&#x4EE3;&#x7406;&#x65F6;&#x7684;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF08;&#x629B;&#x51FA;beancurrentlyincreationexception&#x5F02;&#x5E38;"><i class="fa fa-link" aria-hidden="true"></i></a>&#x5B58;&#x5728;&#x4EE3;&#x7406;&#x65F6;&#x7684;&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF08;&#x629B;&#x51FA;BeanCurrentlyInCreationException&#x5F02;&#x5E38;)</h2>
<pre><code>@Component(&quot;CircleA&quot;)
public class A {
    @Autowired
    private B b;
}
</code></pre><pre><code>@Component(&quot;CircleB&quot;)
public class B {
    @Autowired
    private A a;
}
</code></pre><pre><code>@Component
public class ABeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if(beanName.equals(&quot;CircleA&quot;)) {
            System.out.println(&quot;proxy-A&quot;);
            return new Object();
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
}
</code></pre><ul>
<li><p><context:component-scan base-package="proxycircle">&lt;/context:component-scan&gt;</context:component-scan></p>
</li>
<li><p>Exception in thread &quot;main&quot; </p>
</li>
<li><p>org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &apos;CircleA&apos;: Bean with name &apos;CircleA&apos; has been injected into other beans [CircleB] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for example.</p>
</li>
<li><p>&#x6B64;&#x65F6;&#x5C31;&#x4E0E;earlySIngletonObjects&#x6709;&#x5173;&#x7CFB;&#x4E86;&#x3002;</p>
<ul>
<li>1)getBean(A)&#x65F6;&#xFF0C;&#x5C06;A&#x52A0;&#x5165;&#x4E86;singletonFactories&#xFF0C;&#x6CE8;&#x5165;&#x5C5E;&#x6027;&#x65F6;setter&#x6CE8;&#x5165;B&#xFF0C;&#x8C03;&#x7528;getBean(B)</li>
<li>2)&#x8C03;&#x7528;getBean(B)&#x65F6;&#xFF0C;&#x5C06;B&#x52A0;&#x5165;&#x4E86;singletonFactories&#xFF0C;&#x6CE8;&#x5165;&#x5C5E;&#x6027;&#x65F6;setter&#x6CE8;&#x5165;A&#xFF0C;&#x8C03;&#x7528;getBean(A)</li>
<li>3)&#x56E0;&#x4E3A;A&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#x5728;singletonFactories&#xFF0C;&#x4E8E;&#x662F;&#x53D6;&#x51FA;&#xFF0C;&#x8C03;&#x7528;getObject&#xFF0C;&#x7136;&#x540E;&#x5C06;A&#x52A0;&#x5165;&#x5230;earlySIngletonObjects&#xFF0C;&#x8FD4;&#x56DE;A&#x3002;</li>
<li>4)B&#x6CE8;&#x5165;&#x5C5E;&#x6027;A&#x5B8C;&#x6BD5;&#x540E;&#xFF0C;B&#x6784;&#x9020;&#x5B8C;&#x6BD5;&#xFF0C;&#x5C06;B&#x52A0;&#x5165;singletonObjects&#xFF0C;&#x4ECE; earlySIngletonObjects&#x548C;singletonFactories&#x4E2D;&#x79FB;&#x9664;B</li>
<li>5)A&#x6CE8;&#x5165;&#x5C5E;&#x6027;B&#x5B8C;&#x6BD5;&#x540E;&#xFF0C;&#x6267;&#x884C;BeanPostProcessor&#xFF0C;&#x6B64;&#x65F6;A&#x53D8;&#x4E3A;&#x4E86;Object&#xFF08;CurrentA)&#x3002;&#x68C0;&#x6D4B;&#x4EE3;&#x7406;bean&#x5FAA;&#x73AF;&#x4F9D;&#x8D56;&#xFF0C;&#x53D1;&#x73B0;singletonObjects&#x4E2D;&#x5B58;&#x5728;Cached A&#xFF0C;&#x4E8E;&#x662F;&#x53D6;&#x51FA;&#xFF0C;&#x5C06;CachedA &#x4E0E; CurrentA&#x6BD4;&#x8F83;&#xFF0C;&#x53D1;&#x73B0;&#x4E0D;&#x540C;&#xFF0C;&#x7136;&#x540E;&#x53D1;&#x73B0;&#x6709;B&#x4F9D;&#x8D56;&#x7740;Cached A&#xFF0C;&#x6570;&#x636E;&#x53D1;&#x751F;&#x4E0D;&#x4E00;&#x81F4;&#xFF0C;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002;</li>
</ul>
</li>
<li><p><a href="https://www.iflym.com/index.php/code/201208280003.html" target="_blank">https://www.iflym.com/index.php/code/201208280003.html</a></p>
</li>
<li>Spring AOP&#xFF08;AspectJ)</li>
<li>AOP&#x672F;&#x8BED;</li>
<li>1&#x3001;&#x5207;&#x9762;&#xFF08;aspect/advisor)</li>
<li>&#x7C7B;&#x662F;&#x5BF9;&#x7269;&#x4F53;&#x7279;&#x5F81;&#x7684;&#x62BD;&#x8C61;&#xFF0C;&#x5207;&#x9762;&#x5C31;&#x662F;&#x5BF9;&#x6A2A;&#x5207;&#x5173;&#x6CE8;&#x70B9;&#x7684;&#x62BD;&#x8C61;&#x3002;&#x7EC4;&#x5408;&#x4E86;Pointcut&#x4E0E;Advice&#xFF0C;&#x5728;Spring&#x4E2D;&#x6709;&#x65F6;&#x5019;&#x4E5F;&#x79F0;&#x4E3A;Advisor&#x3002;</li>
<li>2&#x3001;&#x8FDE;&#x63A5;&#x70B9;&#xFF08;join point)</li>
<li>&#x88AB;&#x62E6;&#x622A;&#x5230;&#x7684;&#x70B9;&#xFF0C;&#x56E0;&#x4E3A;Spring&#x53EA;&#x652F;&#x6301;&#x65B9;&#x6CD5;&#x7C7B;&#x578B;&#x7684;&#x8FDE;&#x63A5;&#x70B9;&#xFF0C;&#x6240;&#x4EE5;&#x5728;Spring&#x4E2D;&#x8FDE;&#x63A5;&#x70B9;&#x6307;&#x7684;&#x5C31;&#x662F;&#x88AB;&#x62E6;&#x622A;&#x5230;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x5B9E;&#x9645;&#x4E0A;&#x8FDE;&#x63A5;&#x70B9;&#x8FD8;&#x53EF;&#x4EE5;&#x662F;&#x5B57;&#x6BB5;&#x6216;&#x8005;&#x6784;&#x9020;&#x5668;&#x3002;</li>
<li>3&#x3001;&#x5207;&#x5165;&#x70B9;&#xFF08;pointcut)</li>
<li>&#x63CF;&#x8FF0;&#x7684;&#x4E00;&#x7EC4;&#x7B26;&#x5408;&#x67D0;&#x4E2A;&#x6761;&#x4EF6;&#x7684;join point&#xFF0C;&#x901A;&#x5E38;&#x4F7F;&#x7528;pointcut&#x8868;&#x8FBE;&#x5F0F;&#x6765;&#x9650;&#x5B9A;join point&#x3002;</li>
<li>4&#x3001;&#x901A;&#x77E5;&#xFF08;advice)</li>
<li>&#x6240;&#x8C13;&#x901A;&#x77E5;&#x6307;&#x7684;&#x5C31;&#x662F;&#x6307;&#x62E6;&#x622A;&#x5230;&#x8FDE;&#x63A5;&#x70B9;&#x4E4B;&#x540E;&#x8981;&#x6267;&#x884C;&#x7684;&#x4EE3;&#x7801;&#xFF0C;&#x901A;&#x77E5;&#x5206;&#x4E3A;&#x524D;&#x7F6E;&#x3001;&#x540E;&#x7F6E;&#x3001;&#x5F02;&#x5E38;&#x3001;&#x8FD4;&#x56DE;&#x3001;&#x73AF;&#x7ED5;&#x901A;&#x77E5;&#x4E94;&#x7C7B;&#x3002;</li>
<li>5&#x3001;&#x76EE;&#x6807;&#x5BF9;&#x8C61;</li>
<li>&#x4EE3;&#x7406;&#x7684;&#x76EE;&#x6807;&#x5BF9;&#x8C61;</li>
<li>6&#x3001;&#x7EC7;&#x5165;&#xFF08;weave)</li>
<li>&#x5C06;Advice&#x7EC7;&#x5165;join point&#x7684;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;</li>
<li>7&#x3001;&#x5F15;&#x4ECB;&#xFF08;introduction)</li>
<li>&#x5728;&#x4E0D;&#x4FEE;&#x6539;&#x4EE3;&#x7801;&#x7684;&#x524D;&#x63D0;&#x4E0B;&#xFF0C;&#x5F15;&#x4ECB;&#x53EF;&#x4EE5;&#x5728;&#x8FD0;&#x884C;&#x671F;&#x4E3A;&#x7C7B;&#x52A8;&#x6001;&#x5730;&#x6DFB;&#x52A0;&#x4E00;&#x4E9B;&#x65B9;&#x6CD5;&#x6216;&#x5B57;&#x6BB5;</li>
<li>Advisor</li>
<li>&#x901A;&#x77E5;Advice&#x662F;Spring&#x63D0;&#x4F9B;&#x7684;&#x4E00;&#x79CD;&#x5207;&#x9762;(Aspect)&#x3002;&#x4F46;&#x5176;&#x529F;&#x80FD;&#x8FC7;&#x4E8E;&#x7B80;&#x5355;&#xFF0C;&#x53EA;&#x80FD;&#x5C06;&#x5207;&#x9762;&#x7EC7;&#x5165;&#x5230;&#x76EE;&#x6807;&#x7C7B;&#x7684;&#x6240;&#x6709;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;&#x65E0;&#x6CD5;&#x5B8C;&#x6210;&#x5C06;&#x5207;&#x9762;&#x7EC7;&#x5165;&#x5230;&#x6307;&#x5B9A;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x4E2D;&#x3002;</li>
<li>&#x987E;&#x95EE;Advisor&#x662F;Spring&#x63D0;&#x4F9B;&#x7684;&#x53E6;&#x4E00;&#x79CD;&#x5207;&#x9762;&#x3002;&#x5176;&#x53EF;&#x4EE5;&#x5B8C;&#x6210;&#x66F4;&#x4E3A;&#x590D;&#x6742;&#x7684;&#x5207;&#x9762;&#x7EC7;&#x5165;&#x529F;&#x80FD;&#x3002;PointcutAdvisor&#x662F;&#x987E;&#x95EE;&#x7684;&#x4E00;&#x79CD;&#xFF0C;&#x53EF;&#x4EE5;&#x6307;&#x5B9A;&#x5177;&#x4F53;&#x7684;&#x5207;&#x5165;&#x70B9;&#x3002;&#x987E;&#x95EE;&#x5BF9;&#x901A;&#x77E5;&#x8FDB;&#x884C;&#x4E86;&#x5305;&#x88C5;&#xFF0C;&#x4F1A;&#x6839;&#x636E;&#x4E0D;&#x540C;&#x7684;&#x901A;&#x77E5;&#x7C7B;&#x578B;&#xFF0C;&#x5728;&#x4E0D;&#x540C;&#x7684;&#x65F6;&#x95F4;&#x70B9;&#xFF0C;&#x5C06;&#x5207;&#x9762;&#x7EC7;&#x5165;&#x5230;&#x4E0D;&#x540C;&#x7684;&#x5207;&#x5165;&#x70B9;&#x3002;</li>
<li>Advisor&#x7EC4;&#x5408;&#x4E86;Pointcut&#x4E0E;Advice&#x3002;</li>
<li>&#x9664;&#x4E86;&#x5F15;&#x4ECB;Advisor&#x5916;&#xFF0C;&#x51E0;&#x4E4E;&#x6240;&#x6709;&#x7684;advisor&#x90FD;&#x662F;PointcutAdvisor&#x3002;</li>
</ul>
<pre><code>public interface Advisor {
   Advice getAdvice();
   /**
     * @return whether this advice is associated with a particular target instance
    */
   boolean isPerInstance();
}
</code></pre><pre><code>public interface PointcutAdvisor extends Advisor {

   /**
    * Get the Pointcut that drives this advisor.
    */
   Pointcut getPointcut();

}
</code></pre><ul>
<li>Advice</li>
</ul>
<pre><code>public interface Advice {

}
</code></pre><ul>
<li>&#x589E;&#x5F3A;&#xFF08;advice)&#x4E3B;&#x8981;&#x5305;&#x62EC;&#x5982;&#x4E0B;&#x4E94;&#x79CD;&#x7C7B;&#x578B; </li>
<li><ol>
<li>&#x524D;&#x7F6E;&#x589E;&#x5F3A;(BeforeAdvice)&#xFF1A;&#x5728;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x6267;&#x884C;&#x524D;&#x5B9E;&#x65BD;&#x589E;&#x5F3A; </li>
</ol>
</li>
<li><ol>
<li>&#x540E;&#x7F6E;&#x589E;&#x5F3A;(AfterAdvice)&#xFF1A;&#x5728;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x6267;&#x884C;&#x540E;&#xFF08;&#x65E0;&#x8BBA;&#x662F;&#x5426;&#x629B;&#x51FA;&#x9057;&#x4EA7;)&#x5B9E;&#x65BD;&#x589E;&#x5F3A; </li>
</ol>
</li>
<li><ol>
<li>&#x73AF;&#x7ED5;&#x589E;&#x5F3A;(MethodInterceptor)&#xFF1A;&#x5728;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x6267;&#x884C;&#x524D;&#x540E;&#x5B9E;&#x65BD;&#x589E;&#x5F3A; </li>
</ol>
</li>
<li><ol>
<li>&#x5F02;&#x5E38;&#x629B;&#x51FA;&#x589E;&#x5F3A;(ThrowsAdvice)&#xFF1A;&#x5728;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x540E;&#x5B9E;&#x65BD;&#x589E;&#x5F3A; </li>
</ol>
</li>
<li><ol>
<li>&#x8FD4;&#x56DE;&#x589E;&#x5F3A;&#xFF08;AfterReturningAdvice)&#xFF1A;&#x5728;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x6B63;&#x5E38;&#x8FD4;&#x56DE;&#x540E;&#x5B9E;&#x65BD;&#x589E;&#x5F3A;</li>
</ol>
</li>
<li><ol>
<li>&#x5F15;&#x4ECB;&#x589E;&#x5F3A;(IntroductionIntercrptor)&#xFF1A;&#x5728;&#x76EE;&#x6807;&#x7C7B;&#x4E2D;&#x6DFB;&#x52A0;&#x4E00;&#x4E9B;&#x65B0;&#x7684;&#x65B9;&#x6CD5;&#x548C;&#x5C5E;&#x6027;</li>
</ol>
</li>
<li>BeanPostProcessor</li>
</ul>
<pre><code>public interface BeanPostProcessor {
   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;
   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
}
</code></pre><ul>
<li>JDK&#x52A8;&#x6001;&#x4EE3;&#x7406;&#x4E0E;CGLIB&#x4EE3;&#x7406;</li>
<li>JDK&#x52A8;&#x6001;&#x4EE3;&#x7406;&#xFF1A;</li>
<li>&#x5176;&#x4EE3;&#x7406;&#x5BF9;&#x8C61;&#x5FC5;&#x987B;&#x662F;&#x67D0;&#x4E2A;&#x63A5;&#x53E3;&#x7684;&#x5B9E;&#x73B0;&#xFF0C;&#x5B83;&#x662F;&#x901A;&#x8FC7;&#x5728;&#x8FD0;&#x884C;&#x65F6;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x63A5;&#x53E3;&#x7684;&#x5B9E;&#x73B0;&#x7C7B;&#x6765;&#x5B8C;&#x6210;&#x5BF9;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x7684;&#x4EE3;&#x7406;</li>
<li>CGLIB&#x4EE3;&#x7406;&#xFF1A;&#x5728;&#x8FD0;&#x884C;&#x65F6;&#x751F;&#x6210;&#x7684;&#x4EE3;&#x7406;&#x5BF9;&#x8C61;&#x662F;&#x9488;&#x5BF9;&#x76EE;&#x6807;&#x7C7B;&#x6269;&#x5C55;&#x7684;&#x5B50;&#x7C7B;&#x3002;</li>
<li>CGLIB&#x662F;&#x9AD8;&#x6548;&#x7684;&#x4EE3;&#x7801;&#x751F;&#x4EA7;&#x5305;&#xFF0C;&#x5E95;&#x5C42;&#x662F;&#x4F9D;&#x9760;ASM&#x64CD;&#x4F5C;&#x5B57;&#x8282;&#x7801;&#x5B9E;&#x73B0;&#x7684;&#xFF0C;&#x6027;&#x80FD;&#x6BD4;JDK&#x5F3A;&#x3002;</li>
<li>&#x76F8;&#x5173;&#x6807;&#x7B7E;</li>
<li><aop:aspectj-autoproxy proxy-target-class="&#x201D;true&#x201D;/"> </aop:aspectj-autoproxy></li>
<li><p>true&#x8868;&#x793A;&#x4F7F;&#x7528;CGLIB&#x4EE3;&#x7406;&#x3002;</p>
</li>
<li></li>
<li><p>&#x89E3;&#x6790;AOP&#x6807;&#x7B7E;</p>
</li>
<li><aop:aspectj-autoproxy></aop:aspectj-autoproxy></li>
<li>&#x89E3;&#x6790;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x65F6;&#xFF0C;&#x4E00;&#x65E6;&#x9047;&#x5230;aspectj-autoproxy&#x6CE8;&#x89E3;&#x65F6;&#x5C31;&#x4F1A;&#x4F7F;&#x7528;&#x89E3;&#x6790;&#x5668;</li>
<li>AspectJAutoProxyBeanDefinitionParser&#x8FDB;&#x884C;&#x89E3;&#x6790;&#x3002;</li>
<li><p>&#x89E3;&#x6790;&#x7ED3;&#x679C;&#x662F;&#x6CE8;&#x518C;&#x4E86;&#x4E00;&#x4E2A;bean&#xFF1A;AnnotationAwareAspectJAutoProxyCreator&#x3002;</p>
</li>
<li><p>&#x4E0E;IOC&#x7684;&#x8854;&#x63A5;</p>
</li>
<li>&#x5904;&#x7406;&#x81EA;&#x5B9A;&#x4E49;&#x6807;&#x7B7E;</li>
</ul>
<pre><code>public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {
   String namespaceUri = getNamespaceURI(ele);
</code></pre><ul>
<li>// AopNamespaceHandler
 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
 if (handler == null) {<pre><code>error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);
return null;
</code></pre> }
 return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));
}</li>
<li>NamespaceHandler#parse</li>
<li>NamespaceHandler&#x662F;&#x4E00;&#x4E2A;&#x63A5;&#x53E3;&#xFF0C;&#x5B83;&#x6709;&#x4E00;&#x4E2A;&#x5B9E;&#x73B0;&#x662F;NamespaceHandlerSupport&#xFF0C;&#x5B9E;&#x73B0;&#x4E86;&#x5B83;&#x7684;parse&#x65B9;&#x6CD5;&#xFF0C;&#x800C;AopNamespaceHandler&#x76F4;&#x63A5;&#x7EE7;&#x627F;&#x4E86;parse&#x65B9;&#x6CD5;&#x3002;</li>
</ul>
<ul>
<li>&#x5B83;&#x7EE7;&#x627F;&#x81EA;NamespaceHandlerSupport&#xFF0C;&#x5B9E;&#x73B0;&#x4E86;NamespaceHandler&#x63A5;&#x53E3;&#x7684;parse&#x65B9;&#x6CD5;&#xFF0C;&#x800C;AopNamespaceHandler&#x76F4;&#x63A5;&#x7EE7;&#x627F;&#x8BE5;parse&#x65B9;&#x6CD5;&#x3002;</li>
<li>NamespaceHandlerSupport#parse</li>
</ul>
<pre><code>public BeanDefinition parse(Element element, ParserContext parserContext) {
   return findParserForElement(element, parserContext).parse(element, parserContext);
}
</code></pre><pre><code>private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {
   String localName = parserContext.getDelegate().getLocalName(element);
   BeanDefinitionParser parser = this.parsers.get(localName);
   if (parser == null) {
      parserContext.getReaderContext().fatal(
            &quot;Cannot locate BeanDefinitionParser for element [&quot; + localName + &quot;]&quot;, element);
   }
   return parser;
}
</code></pre><ul>
<li>&#x8FD9;&#x91CC;&#x8FD4;&#x56DE;&#x7684;parser&#x5373;&#x4E3A;AspectJAutoProxyBeanDefinitionParser&#x3002;</li>
<li>AspectJAutoProxyBeanDefinitionParser#parse</li>
</ul>
<pre><code>public BeanDefinition parse(Element element, ParserContext parserContext) {
   AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);
   extendBeanDefinition(element, parserContext);
   return null;
}
</code></pre><ul>
<li>AopNamespaceUtils#registerAspectJAnnotationAutoProxyCreatorIfNecessary</li>
<li>&#x6CE8;&#x518C;&#x8FD9;&#x4E2A;creator</li>
</ul>
<pre><code>public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(
      ParserContext parserContext, Element sourceElement) {
   // &#x6CE8;&#x518C;&#x6216;&#x5347;&#x7EA7;AutoProxyCreator&#x5B9A;&#x4E49;beanName&#x4E3A;internalAutoProxyCreator&#x7684;BeanDefinition
   BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(
         parserContext.getRegistry(), parserContext.extractSource(sourceElement));
</code></pre><ul>
<li>// &#x5BF9;&#x4E8E;proxy-target-class&#x4EE5;&#x53CA;expose-proxy&#x5C5E;&#x6027;&#x7684;&#x589E;&#x5F3A;
 useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</li>
<li>// &#x6CE8;&#x518C;&#x7EC4;&#x4EF6;&#x5E76;&#x901A;&#x77E5;&#xFF0C;&#x4FBF;&#x4E8E;&#x76D1;&#x542C;&#x5668;&#x505A;&#x8FDB;&#x4E00;&#x6B65;&#x5904;&#x7406;</li>
<li>// &#x5176;&#x4E2D;beanDefinition&#x7684;className&#x4E3A;AnnotationAwareAspectJAutoProxyCreator
 registerComponentIfNecessary(beanDefinition, parserContext);
}<ul>
<li>1) AopConfigUtils#registerAspectJAnnotationAutoProxyCreatorIfNecessary</li>
</ul>
</li>
</ul>
<pre><code>public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object source) {
   return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);
}
</code></pre><ul>
<li>registerOrEscalateApcAsRequired</li>
</ul>
<pre><code>private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) {
   Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
</code></pre><ul>
<li>// &#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#x81EA;&#x52A8;&#x4EE3;&#x7406;&#x521B;&#x5EFA;&#x5668;&#xFF0C;&#x4E14;&#x5B58;&#x5728;&#x7684;&#x5728;&#x81EA;&#x52A8;&#x4EE3;&#x7406;&#x521B;&#x5EFA;&#x5668;&#x4E0E;&#x73B0;&#x5728;&#x7684;&#x4E0D;&#x4E00;&#x81F4;&#xFF0C;&#x90A3;&#x4E48;&#x9700;&#x8981;&#x6839;&#x636E;&#x4F18;&#x5148;&#x7EA7;&#x6765;&#x5224;&#x65AD;&#x5230;&#x5E95;&#x9700;&#x8981;&#x4F7F;&#x7528;&#x54EA;&#x4E2A;
 if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {<pre><code>BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
if (!cls.getName().equals(apcDefinition.getBeanClassName())) {
   int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());
   int requiredPriority = findPriorityForClass(cls);
   if (currentPriority &lt; requiredPriority) {
</code></pre></li>
<li>// &#x6539;&#x53D8;bean&#x6700;&#x91CD;&#x8981;&#x7684;&#x662F;&#x6539;&#x53D8;bean&#x6240;&#x5BF9;&#x5E94;&#x7684;className&#x5C5E;&#x6027;<pre><code>      apcDefinition.setBeanClassName(cls.getName());
   }
}
</code></pre></li>
<li>// &#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#x81EA;&#x52A8;&#x4EE3;&#x7406;&#x521B;&#x5EFA;&#x5668;&#xFF0C;&#x4E14;&#x4E0E;&#x5C06;&#x8981;&#x521B;&#x5EFA;&#x7684;&#x4E00;&#x81F4;&#xFF0C;&#x90A3;&#x4E48;&#x65E0;&#x9700;&#x518D;&#x6B21;&#x521B;&#x5EFA;<pre><code>return null;
</code></pre> }
 RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);
 beanDefinition.setSource(source);
 beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);
 beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
 registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
 return beanDefinition;
}</li>
</ul>
<pre><code>public static final String AUTO_PROXY_CREATOR_BEAN_NAME =
      &quot;org.springframework.aop.config.internalAutoProxyCreator&quot;;
</code></pre><ul>
<li>&#x8FD9;&#x91CC;&#x7684;registery.registerBeanDefinition&#x5373;&#x4E3A;</li>
<li>DefaultListableBeanFactory.registerBeanDefinition&#x3002;<ul>
<li>2) useClassProxyingIfNecessary</li>
</ul>
</li>
<li>&#x5904;&#x7406;proxy-target-class&#x5C5E;&#x6027;&#x548C;expose-proxy&#x5C5E;&#x6027;</li>
</ul>
<pre><code>private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, Element sourceElement) {
   if (sourceElement != null) {
      boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));
      if (proxyTargetClass) {
         AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
      }
      boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));
      if (exposeProxy) {
         AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
      }
   }
}
</code></pre><pre><code>public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) {
   if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
      BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
      definition.getPropertyValues().add(&quot;proxyTargetClass&quot;, Boolean.TRUE);
   }
}
</code></pre><pre><code>public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) {
   if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
      BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
      definition.getPropertyValues().add(&quot;exposeProxy&quot;, Boolean.TRUE);
   }
}
</code></pre><ul>
<li><p>&#x521B;&#x5EFA;AOP&#x4EE3;&#x7406;</p>
</li>
<li><p>&#x4E0A;&#x6587;&#x662F;&#x901A;&#x8FC7;&#x81EA;&#x5B9A;&#x4E49;&#x914D;&#x7F6E;&#x5B8C;&#x6210;&#x4E86;&#x8BFB;AnnotationAwareAspectJAutoProxyCreator&#x7C7B;&#x7684;&#x81EA;&#x52A8;&#x6CE8;&#x518C;&#x3002;</p>
</li>
<li><p>&#x53EF;&#x89C1;&#x8FD9;&#x4E2A;&#x7C7B;&#x5B9E;&#x73B0;&#x4E86;BeanPostProcessor&#x63A5;&#x53E3;&#xFF0C;&#x800C;&#x5B9E;&#x73B0;&#x8BE5;&#x63A5;&#x53E3;&#x540E;&#xFF0C;&#x5F53;Spring&#x52A0;&#x8F7D;&#x8FD9;&#x4E2A;Bean&#x65F6;&#x4F1A;&#x5728;&#x5B9E;&#x4F8B;&#x5316;&#x524D; &#x8C03;&#x7528;&#x5176;postProcessAfterInitialization&#x65B9;&#x6CD5;&#x3002;</p>
</li>
<li>&#x4E0E;IOC&#x7684;&#x8854;&#x63A5;</li>
<li><p>beanPostProcessor&#x5728;&#x4E24;&#x4E2A;&#x5730;&#x65B9;&#x88AB;&#x8C03;&#x7528;&#xFF0C;&#x4E00;&#x4E2A;&#x662F;</p>
</li>
<li><p>&#x53E6;&#x4E00;&#x4E2A;&#x662F;&#xFF1A;</p>
</li>
</ul>
<ul>
<li>&#x524D;&#x4E00;&#x4E2A;&#x5730;&#x65B9;&#x662F;&#x9488;&#x5BF9;&#x4E8E;&#x5B9E;&#x73B0;&#x4E86;InstantiationAwareBeanPostProcessor&#x63A5;&#x53E3;&#x7684;BeanPostProcessor&#xFF0C;&#x524D;&#x4E00;&#x4E2A;&#x5730;&#x65B9;&#x521B;&#x5EFA;&#x4EE3;&#x7406;&#x6210;&#x529F;&#x540E;&#x4F1A;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x3002;&#x5176;&#x4ED6;&#x7684;BeanPostProcessor&#x4F1A;&#x5728;&#x7B2C;&#x4E8C;&#x4E2A;&#x5730;&#x65B9;&#x88AB;&#x8C03;&#x7528;&#x3002;</li>
</ul>
<pre><code>public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
      throws BeansException {

   Object result = existingBean;
   for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
      result = beanProcessor.postProcessAfterInitialization(result, beanName);
      if (result == null) {
         return result;
      }
   }
   return result;
}
</code></pre><ul>
<li><p>&#x5728;&#x89E3;&#x6790;AOP&#x6807;&#x7B7E;&#x4E2D;&#x6CE8;&#x518C;&#x7684;AnnotationAwareAspectJAutoProxyCreator&#x5B9E;&#x73B0;&#x4E86;BeanPostProcessor&#x63A5;&#x53E3;&#xFF0C;&#x6240;&#x4EE5;&#x5728;&#x8FD9;&#x91CC;&#x4F1A;&#x88AB;&#x8C03;&#x7528;&#x5176;postProcessAfterInstantiation&#x65B9;&#x6CD5;&#x3002;</p>
</li>
<li></li>
<li><p>AbstractAutoProxyCreator#postProcessAfterInitialization</p>
</li>
</ul>
<pre><code>public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
   if (bean != null) {
      Object cacheKey = getCacheKey(bean.getClass(), beanName);
      if (!this.earlyProxyReferences.contains(cacheKey)) {
         return wrapIfNecessary(bean, beanName, cacheKey);
      }
   }
   return bean;
}
</code></pre><ul>
<li>wrapIfNecessary</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x83B7;&#x53D6;&#x53EF;&#x4EE5;&#x5E94;&#x7528;&#x5230;&#x8BE5;bean&#x7684;&#x6240;&#x6709;advisor</li>
<li>2)&#x521B;&#x5EFA;&#x4EE3;&#x7406;</li>
</ul>
</li>
<li>protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {</li>
<li>// &#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x5904;&#x7406;&#x8FC7;
 if (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) {<pre><code>return bean;
</code></pre> }</li>
<li>// &#x65E0;&#x9700;&#x589E;&#x5F3A;
 if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {<pre><code>return bean;
</code></pre> }</li>
<li>// &#x7ED9;&#x5B9A;&#x7684;bean&#x7C7B;&#x662F;&#x5426;&#x4EE3;&#x8868;&#x4E00;&#x4E2A;&#x57FA;&#x7840;&#x8BBE;&#x65BD;&#x7C7B;&#xFF0C;&#x57FA;&#x7840;&#x8BBE;&#x65BD;&#x7C7B;&#x4E0D;&#x5E94;&#x4EE3;&#x7406;&#xFF0C;&#x6216;&#x8005;&#x914D;&#x7F6E;&#x4E86;&#x6307;&#x5B9A;bean&#x4E0D;&#x9700;&#x8981;&#x81EA;&#x52A8;&#x4EE3;&#x7406;
 if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {<pre><code>this.advisedBeans.put(cacheKey, Boolean.FALSE);
return bean;
</code></pre> }
 // &#x83B7;&#x53D6;&#x9002;&#x5408;&#x5E94;&#x7528;&#x5230;&#x8BE5;bean&#x7684;&#x6240;&#x6709;advisor
 // Create proxy if we have advice.
 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</li>
<li>// &#x5982;&#x679C;&#x83B7;&#x53D6;&#x5230;&#x4E86;&#x589E;&#x5F3A;&#x5219;&#x9700;&#x8981;&#x589E;&#x5F3A;&#x521B;&#x5EFA;&#x4EE3;&#x7406;
 if (specificInterceptors != DO_NOT_PROXY) {<pre><code>this.advisedBeans.put(cacheKey, Boolean.TRUE);
</code></pre></li>
<li><p>// &#x521B;&#x5EFA;&#x4EE3;&#x7406;</p>
<pre><code>Object proxy = createProxy(
      bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
this.proxyTypes.put(cacheKey, proxy.getClass());
return proxy;
</code></pre><p> }</p>
<p> this.advisedBeans.put(cacheKey, Boolean.FALSE);
 return bean;
}</p>
</li>
<li><p>&#x521B;&#x5EFA;&#x4EE3;&#x7406;&#x4E3B;&#x8981;&#x5305;&#x542B;&#x4E86;&#x4E24;&#x4E2A;&#x6B65;&#x9AA4;&#xFF1A;</p>
<ul>
<li>1)&#x83B7;&#x53D6;&#x589E;&#x5F3A;&#x65B9;&#x6CD5;&#x6216;&#x8005;&#x589E;&#x5F3A;&#x5668;</li>
<li><p>2)&#x6839;&#x636E;&#x83B7;&#x53D6;&#x7684;&#x589E;&#x5F3A;&#x8FDB;&#x884C;&#x4EE3;&#x7406;</p>
</li>
<li><p>1) getAdvicesAndAdvisorsForBean&#xFF08;&#x83B7;&#x53D6;&#x53EF;&#x4EE5;&#x5E94;&#x7528;&#x5230;&#x8BE5;bean&#x7684;&#x6240;&#x6709;advisor)</p>
</li>
</ul>
</li>
<li>AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean</li>
<li><p>protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) {
 List<advisor> advisors = findEligibleAdvisors(beanClass, beanName);
 if (advisors.isEmpty()) {</advisor></p>
<pre><code>return DO_NOT_PROXY;
</code></pre><p> }
 return advisors.toArray();
}</p>
</li>
<li><p>findEligibleAdvisors&#xFF08;&#x5408;&#x683C;&#x7684;)</p>
</li>
<li>&#x5BF9;&#x4E8E;&#x6307;&#x5B9A;bean&#x7684;&#x589E;&#x5F3A;&#x65B9;&#x6CD5;&#x7684;&#x83B7;&#x53D6;&#x5305;&#x542B;&#x4E24;&#x4E2A;&#x6B65;&#x9AA4;&#xFF1A;<ul>
<li>1)&#x83B7;&#x53D6;&#x6240;&#x6709;&#x7684;&#x589E;&#x5F3A;</li>
<li>2)&#x5BFB;&#x627E;&#x6240;&#x6709;&#x7684;&#x589E;&#x5F3A;&#x4E2D;&#x9002;&#x7528;&#x4E8E;bean&#x7684;&#x589E;&#x5F3A;&#x5E76;&#x5E94;&#x7528;</li>
</ul>
</li>
<li>protected List<advisor> findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {
 List<advisor> candidateAdvisors = findCandidateAdvisors();
 List<advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
 extendAdvisors(eligibleAdvisors);
 if (!eligibleAdvisors.isEmpty()) {<pre><code>eligibleAdvisors = sortAdvisors(eligibleAdvisors);
</code></pre> }
 return eligibleAdvisors;
}<ul>
<li>1.1) findCandidateAdvisors&#xFF08;&#x83B7;&#x53D6;&#x6240;&#x6709;&#x7684;&#x589E;&#x5F3A;)</li>
</ul>
</advisor></advisor></advisor></li>
<li>AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors</li>
<li>protected List<advisor> findCandidateAdvisors() {
 // Add all the Spring advisors found according to superclass rules.</advisor></li>
<li>// &#x5F53;&#x4F7F;&#x7528;&#x6CE8;&#x89E3;&#x65B9;&#x5F0F;&#x914D;&#x7F6E;AOP&#x7684;&#x65B9;&#x5F0F;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5E76;&#x4E0D;&#x662F;&#x4E22;&#x5F03;&#x4E86;&#x5BF9;XML&#x914D;&#x7F6E;&#x7684;&#x652F;&#x6301;</li>
<li>// &#x5728;&#x8FD9;&#x91CC;&#x8C03;&#x7528;&#x7236;&#x7C7B;&#x65B9;&#x6CD5;&#x52A0;&#x8F7D;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#x7684;AOP&#x58F0;&#x660E;
 List<advisor> advisors = super.findCandidateAdvisors();
 // Build Advisors for all AspectJ aspects in the bean factory.
 advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());
 return advisors;
}<ul>
<li>1.1.1) AbstractAdvisorAutoProxyCreator#findCandidateAdvisors&#xFF08;&#x83B7;&#x53D6;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#x7684;&#x589E;&#x5F3A;)</li>
</ul>
</advisor></li>
<li>protected List<advisor> findCandidateAdvisors() {
 return this.advisorRetrievalHelper.findAdvisorBeans();
}<ul>
<li>1.1.1.1) BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans</li>
</ul>
</advisor></li>
</ul>
<pre><code>public List&lt;Advisor&gt; findAdvisorBeans() {
   // Determine list of advisor bean names, if not cached already.
   String[] advisorNames = null;
   synchronized (this) {
      advisorNames = this.cachedAdvisorBeanNames;
      if (advisorNames == null) {
         // Do not initialize FactoryBeans here: We need to leave all regular beans
         // uninitialized to let the auto-proxy creator apply to them!
</code></pre><ul>
<li>// &#x4ECE;BeanFactory&#x4E2D;&#x83B7;&#x53D6;&#x6240;&#x6709;&#x5BF9;&#x5E94;Advisor&#x7684;&#x7C7B;</li>
<li><p>advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</p>
<pre><code>        this.beanFactory, Advisor.class, true, false);
  this.cachedAdvisorBeanNames = advisorNames;
</code></pre><p>   }
}
if (advisorNames.length == 0) {
   return new LinkedList<advisor>();
}</advisor></p>
<p>List<advisor> advisors = new LinkedList<advisor>();
for (String name : advisorNames) {
   if (isEligibleBean(name)) {</advisor></advisor></p>
<pre><code>  if (this.beanFactory.isCurrentlyInCreation(name)) {
     if (logger.isDebugEnabled()) {
        logger.debug(&quot;Skipping currently created advisor &apos;&quot; + name + &quot;&apos;&quot;);
     }
  }
  else {
     try {
</code></pre></li>
<li>// getBean&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x83B7;&#x53D6;Advisor</li>
<li>advisors.add(this.beanFactory.getBean(name, Advisor.class));
}
catch (BeanCreationException ex) {
Throwable rootCause = ex.getMostSpecificCause();
if (rootCause instanceof BeanCurrentlyInCreationException) {
BeanCreationException bce = (BeanCreationException) rootCause;
if (this.beanFactory.isCurrentlyInCreation(bce.getBeanName())) {
   if (logger.isDebugEnabled()) {<pre><code>  logger.debug(&quot;Skipping advisor &apos;&quot; + name +
        &quot;&apos; with dependency on currently created bean: &quot; + ex.getMessage());
</code></pre>   }
   // Ignore: indicates a reference back to the bean we&apos;re trying to advise.
   // We want to find advisors other than the currently created bean itself.
   continue;
}
}
throw ex;
}
}
}
}
return advisors;
}</li>
<li>advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</li>
<li>this.beanFactory, Advisor.class, true, false);<ul>
<li>1.1.1.1.1) BeanFactoryUtils.beanNamesForTypeIncludingAncestors</li>
</ul>
</li>
</ul>
<pre><code>public static String[] beanNamesForTypeIncludingAncestors(
      ListableBeanFactory lbf, Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit) {

   Assert.notNull(lbf, &quot;ListableBeanFactory must not be null&quot;);
</code></pre><ul>
<li>//&#x83B7;&#x53D6;Class&#x4E3A;Advisor&#x7684;&#x6240;&#x6709;bean&#x7684;&#x540D;&#x5B57;
 String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);
 if (lbf instanceof HierarchicalBeanFactory) {<pre><code>HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf;
if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {
   String[] parentResult = beanNamesForTypeIncludingAncestors(
         (ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit);
   List&lt;String&gt; resultList = new ArrayList&lt;String&gt;();
   resultList.addAll(Arrays.asList(result));
   for (String beanName : parentResult) {
      if (!resultList.contains(beanName) &amp;&amp; !hbf.containsLocalBean(beanName)) {
         resultList.add(beanName);
      }
   }
   result = StringUtils.toStringArray(resultList);
}
</code></pre> }
 return result;
}</li>
</ul>
<pre><code>- 1.1.2) BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors&#xFF08;&#x83B7;&#x53D6;&#x6807;&#x8BB0;@Aspect&#x6CE8;&#x89E3;&#x7684;&#x7C7B;&#x4E2D;&#x7684;&#x589E;&#x5F3A;)
</code></pre><ul>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x904D;&#x5386;&#x6240;&#x6709;beanName&#xFF0C;&#x6240;&#x6709;&#x5728;beanFactory&#x4E2D;&#x6CE8;&#x518C;&#x7684;bean&#x90FD;&#x4F1A;&#x88AB;&#x63D0;&#x53D6;&#x51FA;&#x6765;</li>
<li>2)&#x904D;&#x5386;&#x6240;&#x6709;beanName&#xFF0C;&#x627E;&#x51FA;&#x58F0;&#x660E;@Aspect&#x6CE8;&#x89E3;&#x7684;&#x7C7B;&#xFF0C;&#x8FDB;&#x884C;&#x8FDB;&#x4E00;&#x6B65;&#x7684;&#x5904;&#x7406;</li>
<li>3)&#x5BF9;&#x6807;&#x8BB0;&#x4E3A;AspectJ&#x6CE8;&#x89E3;&#x7684;&#x7C7B;&#x8FDB;&#x884C;&#x589E;&#x5F3A;&#x7684;&#x63D0;&#x53D6;</li>
<li>4)&#x5C06;&#x63D0;&#x53D6;&#x7ED3;&#x679C;&#x52A0;&#x5165;&#x7F13;&#x5B58;</li>
</ul>
</li>
</ul>
<pre><code>public List&lt;Advisor&gt; buildAspectJAdvisors() {
   List&lt;String&gt; aspectNames = this.aspectBeanNames;

   if (aspectNames == null) {
      synchronized (this) {
         aspectNames = this.aspectBeanNames;
         if (aspectNames == null) {
            List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;();
            aspectNames = new LinkedList&lt;String&gt;();
</code></pre><ul>
<li>// &#x83B7;&#x53D6;&#x6240;&#x6709;&#x7684;beanName<pre><code>  String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
        this.beanFactory, Object.class, true, false);
</code></pre></li>
<li>// &#x904D;&#x5386;&#x6240;&#x6709;&#x7684;beanName&#x627E;&#x51FA;&#x5BF9;&#x5E94;&#x7684;&#x589E;&#x5F3A;&#x65B9;&#x6CD5;<pre><code>      for (String beanName : beanNames) {
</code></pre></li>
<li>// &#x4E0D;&#x5408;&#x6CD5;&#x7684;bean&#x5219;&#x7565;&#x8FC7;<pre><code>         if (!isEligibleBean(beanName)) {
            continue;
         }
         // We must be careful not to instantiate beans eagerly as in this case they
         // would be cached by the Spring container but would not have been weaved.
</code></pre></li>
<li>// &#x83B7;&#x53D6;&#x5BF9;&#x5E94;&#x7684;bean&#x7684;&#x7C7B;&#x578B;<pre><code>     Class&lt;?&gt; beanType = this.beanFactory.getType(beanName);
     if (beanType == null) {
        continue;
     }
</code></pre></li>
<li>// &#x5982;&#x679C;&#x5B58;&#x5728;@Aspect&#x6CE8;&#x89E3;<pre><code>         if (this.advisorFactory.isAspect(beanType)) {
            aspectNames.add(beanName);
            AspectMetadata amd = new AspectMetadata(beanType, beanName);
            if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
               MetadataAwareAspectInstanceFactory factory =
                     new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);
</code></pre></li>
<li><p>// &#x89E3;&#x6790;&#x6807;&#x8BB0;@Aspect&#x4E2D;&#x7684;&#x589E;&#x5F3A;&#x65B9;&#x6CD5;</p>
<pre><code>           List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);
           if (this.beanFactory.isSingleton(beanName)) {
              this.advisorsCache.put(beanName, classAdvisors);
           }
           else {
              this.aspectFactoryCache.put(beanName, factory);
           }
           advisors.addAll(classAdvisors);
        }
        else {
           // Per target or per this.
           if (this.beanFactory.isSingleton(beanName)) {
              throw new IllegalArgumentException(&quot;Bean with name &apos;&quot; + beanName +
                    &quot;&apos; is a singleton, but aspect instantiation model is not singleton&quot;);
           }
           MetadataAwareAspectInstanceFactory factory =
                 new PrototypeAspectInstanceFactory(this.beanFactory, beanName);
           this.aspectFactoryCache.put(beanName, factory);    advisors.addAll(this.advisorFactory.getAdvisors(factory));
        }
     }
  }
  this.aspectBeanNames = aspectNames;
  return advisors;
</code></pre><p>   }
}
}</p>
<p>if (aspectNames.isEmpty()) {
return Collections.emptyList();
}
// &#x8BB0;&#x5F55;&#x5728;&#x7F13;&#x5B58;&#x4E2D;</p>
</li>
<li>List<advisor> advisors = new LinkedList<advisor>();
 for (String aspectName : aspectNames) {<pre><code>List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName);
if (cachedAdvisors != null) {
   advisors.addAll(cachedAdvisors);
}
else {
   MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);
   advisors.addAll(this.advisorFactory.getAdvisors(factory));
}
</code></pre> }
 return advisors;
}</advisor></advisor></li>
<li>&#x83B7;&#x53D6;</li>
<li>this.advisorFactory.getAdvisors(factory)<ul>
<li>1.1.2.1) getAdvisors&#xFF08;&#x589E;&#x5F3A;&#x5668;&#x7684;&#x83B7;&#x53D6;)</li>
</ul>
</li>
<li>ReflectiveAspectJAdvisorFactory.getAdvisors</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x5BF9;&#x589E;&#x5F3A;&#x5668;&#x7684;&#x83B7;&#x53D6;</li>
<li>2)&#x52A0;&#x5165;&#x540C;&#x6B65;&#x5B9E;&#x4F8B;&#x5316;&#x589E;&#x5F3A;&#x5668;&#x4EE5;&#x4FDD;&#x8BC1;&#x589E;&#x5F3A;&#x4F7F;&#x7528;&#x524D;&#x7684;&#x5B9E;&#x4F8B;&#x5316;</li>
<li>3)&#x5BF9;DeclareParents&#x6CE8;&#x89E3;&#x7684;&#x83B7;&#x53D6;</li>
</ul>
</li>
</ul>
<pre><code>public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {
</code></pre><ul>
<li>// &#x83B7;&#x53D6;&#x6807;&#x8BB0;&#x4E3A;@Aspect&#x7684;&#x7C7B;
 Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
 String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</li>
<li><p>// &#x9A8C;&#x8BC1;
 validate(aspectClass);</p>
<p> // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator
 // so that it will only instantiate once.
 MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</p>
<pre><code>   new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);
</code></pre><p> List<advisor> advisors = new LinkedList<advisor>();
 for (Method method : getAdvisorMethods(aspectClass)) {</advisor></advisor></p>
</li>
<li><p>// &#x83B7;&#x53D6;&#x666E;&#x901A;&#x7684;advisor</p>
<pre><code>Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);
if (advisor != null) {
   advisors.add(advisor);
}
</code></pre><p> }</p>
<p> // If it&apos;s a per target aspect, emit the dummy instantiating aspect.
 if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {</p>
</li>
<li><p>// &#x5982;&#x679C;&#x5BFB;&#x627E;&#x7684;&#x589E;&#x5F3A;&#x5668;&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x800C;&#x4E14;&#x53C8;&#x914D;&#x7F6E;&#x4E86;&#x589E;&#x5F3A;&#x5EF6;&#x8FDF;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x90A3;&#x4E48;&#x9700;&#x8981;&#x5728;advisors&#x5F00;&#x5934;&#x52A0;&#x5165;&#x540C;&#x6B65;&#x5B9E;&#x4F8B;&#x5316;&#x589E;&#x5F3A;&#x5668;</p>
<pre><code>Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);
advisors.add(0, instantiationAdvisor);
</code></pre><p> }
 // &#x83B7;&#x53D6;DeclareParents&#x6CE8;&#x89E3;&#xFF08;&#x5F15;&#x4ECB;&#x589E;&#x5F3A;IntroductionAdvisor)
 // Find introduction fields.
 for (Field field : aspectClass.getDeclaredFields()) {</p>
<pre><code>Advisor advisor = getDeclareParentsAdvisor(field);
if (advisor != null) {
   advisors.add(advisor);
}
</code></pre><p> }</p>
<p> return advisors;
}</p>
<ul>
<li>1.1.2.1.1) getAdvisor&#xFF08;&#x666E;&#x901A;&#x589E;&#x5F3A;&#x5668;&#x7684;&#x83B7;&#x53D6;)</li>
</ul>
</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x5207;&#x70B9;&#x4FE1;&#x606F;&#x7684;&#x83B7;&#x53D6;</li>
<li>2)&#x6839;&#x636E;&#x5207;&#x70B9;&#x4FE1;&#x606F;&#x751F;&#x6210;&#x589E;&#x5F3A;</li>
</ul>
</li>
</ul>
<pre><code>public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
      int declarationOrderInAspect, String aspectName) {

   validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());
   //&#x5207;&#x70B9;&#x4FE1;&#x606F;&#x7684;&#x83B7;&#x53D6;
   AspectJExpressionPointcut expressionPointcut = getPointcut(
         candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());
   if (expressionPointcut == null) {
      return null;
   }
   // &#x6839;&#x636E;&#x5207;&#x70B9;&#x4FE1;&#x606F;&#x751F;&#x6210;&#x589E;&#x5F3A;&#x5668;
   return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,
         this, aspectInstanceFactory, declarationOrderInAspect, aspectName);
}
</code></pre><ul>
<li><ul>
<li>1.1.2.1.1.1) getPointcut&#xFF08;&#x65B9;&#x6CD5;&#x4E0A;&#x5207;&#x70B9;&#x4FE1;&#x606F;&#x7684;&#x83B7;&#x53D6;)</li>
</ul>
</li>
</ul>
<pre><code> private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) {
</code></pre><ul>
<li>// &#x83B7;&#x53D6;&#x65B9;&#x6CD5;&#x4E0A;&#x7684;&#x6CE8;&#x89E3;
 AspectJAnnotation&lt;?&gt; aspectJAnnotation =
AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
 if (aspectJAnnotation == null) {<pre><code>return null;
</code></pre> }
 // &#x4F7F;&#x7528;AspectJExpressionPointcut&#x5B9E;&#x4F8B;&#x5C01;&#x88C5;&#x83B7;&#x53D6;&#x7684;&#x4FE1;&#x606F;</li>
<li>AspectJExpressionPointcut ajexp =<pre><code>   new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]);
</code></pre></li>
<li><p>// &#x63D0;&#x53D6;&#x5F97;&#x5230;&#x7684;&#x6CE8;&#x89E3;&#x4E2D;&#x7684;&#x8868;&#x8FBE;&#x5F0F;&#xFF0C;&#x5982;@Pointcut(&#x201C;execution(<em> </em>....)&#x201D;)
 ajexp.setExpression(aspectJAnnotation.getPointcutExpression());
 ajexp.setBeanFactory(this.beanFactory);
 return ajexp;
}</p>
<ul>
<li>1.1.2.1.1.1.1) findAspectJAnnotationOnMethod</li>
</ul>
</li>
<li>protected static AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) {</li>
<li><p>// &#x5BFB;&#x627E;&#x7279;&#x5B9A;&#x7684;&#x6CE8;&#x89E3;&#x7C7B;
 Class&lt;?&gt;[] classesToLookFor = new Class&lt;?&gt;[] {</p>
<pre><code>   Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class};
</code></pre><p> for (Class&lt;?&gt; c : classesToLookFor) {</p>
<pre><code>AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);
if (foundAnnotation != null) {
   return foundAnnotation;
}
</code></pre><p> }
 return null;
}</p>
</li>
<li><p>&#x83B7;&#x53D6;&#x6307;&#x5B9A;&#x65B9;&#x6CD5;&#x4E0A;&#x7684;&#x6CE8;&#x89E3;&#x5E76;&#x4F7F;&#x7528;AspectJAnnotation&#x5C01;&#x88C5;</p>
</li>
</ul>
<pre><code>private static &lt;A extends Annotation&gt; AspectJAnnotation&lt;A&gt; findAnnotation(Method method, Class&lt;A&gt; toLookFor) {
   A result = AnnotationUtils.findAnnotation(method, toLookFor);
   if (result != null) {
      return new AspectJAnnotation&lt;A&gt;(result);
   }
   else {
      return null;
   }
}
</code></pre><ul>
<li><ul>
<li>1.1.2.1.1.2) InstantiationModelAwarePointcutAdvisorImpl&#xFF08;&#x6839;&#x636E;&#x5207;&#x70B9;&#x4FE1;&#x606F;&#x751F;&#x6210;&#x589E;&#x5F3A;&#x5668;)</li>
</ul>
</li>
<li><p>&#x6240;&#x6709;&#x7684;&#x589E;&#x5F3A;&#x90FD;&#x7531;Advisor&#x7684;&#x5B9E;&#x73B0;&#x7C7B;InstantiationModelAwarePointcutAdvisorImpl&#x7EDF;&#x4E00;&#x5C01;&#x88C5;&#x7684;&#x3002;</p>
</li>
<li>&#x5728;&#x5B9E;&#x4F8B;&#x521D;&#x59CB;&#x5316;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#x8FD8;&#x5B8C;&#x6210;&#x4E86;&#x5BF9;&#x4E8E;&#x589E;&#x5F3A;&#x5668;&#x7684;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x6839;&#x636E;&#x6CE8;&#x89E3;&#x4E2D;&#x7684;&#x4FE1;&#x606F;&#x521D;&#x59CB;&#x5316;&#x5BF9;&#x5E94;&#x7684;&#x589E;&#x5F3A;&#x5668;&#x662F;&#x5728;instantiateAdvice&#x51FD;&#x6570;&#x4E2D;&#x5B9E;&#x73B0;&#x7684;&#x3002;</li>
</ul>
<pre><code>public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,
      Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,
      MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

   this.declaredPointcut = declaredPointcut;
   this.declaringClass = aspectJAdviceMethod.getDeclaringClass();
   this.methodName = aspectJAdviceMethod.getName();
   this.parameterTypes = aspectJAdviceMethod.getParameterTypes();
   this.aspectJAdviceMethod = aspectJAdviceMethod;
   this.aspectJAdvisorFactory = aspectJAdvisorFactory;
   this.aspectInstanceFactory = aspectInstanceFactory;
   this.declarationOrder = declarationOrder;
   this.aspectName = aspectName;

   if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
      // Static part of the pointcut is a lazy type.
      Pointcut preInstantiationPointcut = Pointcuts.union(
            aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);

      // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.
      // If it&apos;s not a dynamic pointcut, it may be optimized out
      // by the Spring AOP infrastructure after the first evaluation.
      this.pointcut = new PerTargetInstantiationModelPointcut(
            this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);
      this.lazy = true;
   }
   else {
      // A singleton aspect.
      this.pointcut = this.declaredPointcut;
      this.lazy = false;
      this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);
   }
}
</code></pre><pre><code>private Advice instantiateAdvice(AspectJExpressionPointcut pcut) {
   return this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pcut,
         this.aspectInstanceFactory, this.declarationOrder, this.aspectName);
}
</code></pre><pre><code>public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,
      MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

   Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
   validate(candidateAspectClass);

   AspectJAnnotation&lt;?&gt; aspectJAnnotation =
         AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
   if (aspectJAnnotation == null) {
      return null;
   }

   // If we get here, we know we have an AspectJ method.
   // Check that it&apos;s an AspectJ-annotated class
   if (!isAspect(candidateAspectClass)) {
      throw new AopConfigException(&quot;Advice must be declared inside an aspect type: &quot; +
            &quot;Offending method &apos;&quot; + candidateAdviceMethod + &quot;&apos; in class [&quot; +
            candidateAspectClass.getName() + &quot;]&quot;);
   }

   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Found AspectJ method: &quot; + candidateAdviceMethod);
   }

   AbstractAspectJAdvice springAdvice;
   // &#x6839;&#x636E;&#x4E0D;&#x540C;&#x7684;&#x6CE8;&#x89E3;&#x7C7B;&#x578B;&#x5C01;&#x88C5;&#x4E0D;&#x540C;&#x7684;&#x589E;&#x5F3A;&#x5668;
   switch (aspectJAnnotation.getAnnotationType()) {
      case AtBefore:
         springAdvice = new AspectJMethodBeforeAdvice(
               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
         break;
      case AtAfter:
         springAdvice = new AspectJAfterAdvice(
               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
         break;
      case AtAfterReturning:
         springAdvice = new AspectJAfterReturningAdvice(
               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
         AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();
         if (StringUtils.hasText(afterReturningAnnotation.returning())) {
            springAdvice.setReturningName(afterReturningAnnotation.returning());
         }
         break;
      case AtAfterThrowing:
         springAdvice = new AspectJAfterThrowingAdvice(
               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
         AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();
         if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {
            springAdvice.setThrowingName(afterThrowingAnnotation.throwing());
         }
         break;
      case AtAround:
         springAdvice = new AspectJAroundAdvice(
               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
         break;
      case AtPointcut:
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Processing pointcut &apos;&quot; + candidateAdviceMethod.getName() + &quot;&apos;&quot;);
         }
         return null;
      default:
         throw new UnsupportedOperationException(
               &quot;Unsupported advice type on method: &quot; + candidateAdviceMethod);
   }

   // Now to configure the advice...
   springAdvice.setAspectName(aspectName);
   springAdvice.setDeclarationOrder(declarationOrder);
   String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);
   if (argNames != null) {
      springAdvice.setArgumentNamesFromStringArray(argNames);
   }
   springAdvice.calculateArgumentBindings();
   return springAdvice;
}
</code></pre><ul>
<li>&#x4EE5;AspectJMethodBeforeAdvice &#x4E3A;&#x4F8B;&#xFF0C;&#x8FD9;&#x4E2A;&#x7C7B;&#x662F;&#x88AB;MethodBeforeAdviceInterceptor&#x6301;&#x6709;&#x7684;&#x3002;</li>
<li>MethodBeforeAdviceInterceptor&#x4F1A;&#x5728;createProxy&#x4E2D;&#x88AB;&#x7EC7;&#x5165;&#x5230;&#x4EE3;&#x7406;&#x5BF9;&#x8C61;&#x4E2D;&#x3002;</li>
</ul>
<pre><code>public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {

   private MethodBeforeAdvice advice;


   /**
    * Create a new MethodBeforeAdviceInterceptor for the given advice.
    * @param advice the MethodBeforeAdvice to wrap
    */
   public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {
      Assert.notNull(advice, &quot;Advice must not be null&quot;);
      this.advice = advice;
   }

   @Override
   public Object invoke(MethodInvocation mi) throws Throwable {
      this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );
      return mi.proceed();
   }

}
</code></pre><ul>
<li>AspectJMethodBeforeAdvice</li>
</ul>
<pre><code>public class AspectJMethodBeforeAdvice extends AbstractAspectJAdvice implements MethodBeforeAdvice, Serializable {

   public AspectJMethodBeforeAdvice(
         Method aspectJBeforeAdviceMethod, AspectJExpressionPointcut pointcut, AspectInstanceFactory aif) {

      super(aspectJBeforeAdviceMethod, pointcut, aif);
   }


   @Override
   public void before(Method method, Object[] args, Object target) throws Throwable {
      invokeAdviceMethod(getJoinPointMatch(), null, null);
   }

   @Override
   public boolean isBeforeAdvice() {
      return true;
   }

   @Override
   public boolean isAfterAdvice() {
      return false;
   }

}
</code></pre><ul>
<li>invokeAdviceMethod</li>
<li>protected Object invokeAdviceMethod(JoinPointMatch jpMatch, Object returnValue, Throwable ex) throws Throwable {
 return invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex));
}</li>
<li></li>
<li>invokeAdviceMethodWithGivenArgs</li>
<li>protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {
 Object[] actualArgs = args;
 if (this.aspectJAdviceMethod.getParameterTypes().length == 0) {<pre><code>actualArgs = null;
</code></pre> }
 try {<pre><code>ReflectionUtils.makeAccessible(this.aspectJAdviceMethod);
// TODO AopUtils.invokeJoinpointUsingReflection
</code></pre></li>
<li>// &#x6FC0;&#x6D3B;&#x589E;&#x5F3A;&#x65B9;&#x6CD5; method.invoke()<pre><code>return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);
</code></pre> }
 catch (IllegalArgumentException ex) {<pre><code>throw new AopInvocationException(&quot;Mismatch on arguments to advice method [&quot; +
      this.aspectJAdviceMethod + &quot;]; pointcut expression [&quot; +
      this.pointcut.getPointcutExpression() + &quot;]&quot;, ex);
</code></pre> }
 catch (InvocationTargetException ex) {<pre><code>throw ex.getTargetException();
</code></pre> }
}</li>
<li><ul>
<li>1.1.2.1.2) SyntheticInstantiationAdvisor&#xFF08;&#x540C;&#x6B65;&#x5B9E;&#x4F8B;&#x5316;&#x589E;&#x5F3A;&#x5668;)</li>
</ul>
</li>
<li>Advisor instantiationAdvisor = new </li>
<li>SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);
advisors.add(0, instantiationAdvisor);</li>
</ul>
<pre><code>protected static class SyntheticInstantiationAdvisor extends DefaultPointcutAdvisor {

   public SyntheticInstantiationAdvisor(final MetadataAwareAspectInstanceFactory aif) {
      super(aif.getAspectMetadata().getPerClausePointcut(), new MethodBeforeAdvice() {
</code></pre><pre><code>// &#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x524D;&#x8C03;&#x7528;&#xFF0C;&#x7C7B;&#x4F3C;@Before
         @Override
         public void before(Method method, Object[] args, Object target) {
            // Simply instantiate the aspect
</code></pre><ul>
<li><p>// &#x7B80;&#x5355;&#x521D;&#x59CB;&#x5316;aspect</p>
<pre><code>      aif.getAspectInstance();
   }
});
</code></pre><p> }
}</p>
<ul>
<li>1.1.2.1.3) getDeclareParentsAdvisor&#xFF08;&#x83B7;&#x53D6;DeclareParents)</li>
</ul>
</li>
<li>DeclareParents&#x4E3B;&#x8981;&#x7528;&#x4E8E;&#x5F15;&#x4ECB;&#x589E;&#x5F3A;&#x7684;&#x6CE8;&#x89E3;&#x5F62;&#x5F0F;&#x7684;&#x5B9E;&#x73B0;&#xFF0C;&#x800C;&#x5176;&#x5B9E;&#x73B0;&#x65B9;&#x5F0F;&#x548C;&#x666E;&#x901A;&#x589E;&#x5F3A;&#x5F88;&#x7C7B;&#x4F3C;&#xFF0C;&#x53EA;&#x4E0D;&#x8FC7;&#x53EA;&#x7528;DeclareParentsAdvisor&#x5BF9;&#x529F;&#x80FD;&#x8FDB;&#x884C;&#x5C01;&#x88C5;&#x3002;</li>
</ul>
<pre><code>private Advisor getDeclareParentsAdvisor(Field introductionField) {
   DeclareParents declareParents = introductionField.getAnnotation(DeclareParents.class);
   if (declareParents == null) {
      // Not an introduction field
      return null;
   }

   if (DeclareParents.class == declareParents.defaultImpl()) {
      throw new IllegalStateException(&quot;&apos;defaultImpl&apos; attribute must be set on DeclareParents&quot;);
   }

   return new DeclareParentsAdvisor(
         introductionField.getType(), declareParents.value(), declareParents.defaultImpl());
}
</code></pre><ul>
<li><ul>
<li>1.2) findAdvisorsThatCanApply&#xFF08;&#x83B7;&#x53D6;&#x5339;&#x914D;&#x7684;&#x589E;&#x5F3A;&#x5E76;&#x5E94;&#x7528;)</li>
</ul>
</li>
<li><p>protected List<advisor> findAdvisorsThatCanApply(</advisor></p>
<pre><code>List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) {
</code></pre><p> ProxyCreationContext.setCurrentProxiedBeanName(beanName);
 try {</p>
</li>
<li><p>// &#x8FC7;&#x6EE4;&#x5DF2;&#x7ECF;&#x5F97;&#x5230;&#x7684;advisor</p>
<pre><code>return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
</code></pre><p> }
 finally {</p>
<pre><code>ProxyCreationContext.setCurrentProxiedBeanName(null);
</code></pre><p> }
}</p>
</li>
<li><p>AopUtils.findAdvisorsThatCanApply</p>
</li>
</ul>
<pre><code>public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) {
   if (candidateAdvisors.isEmpty()) {
      return candidateAdvisors;
   }
   List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;Advisor&gt;();
   for (Advisor candidate : candidateAdvisors) {
</code></pre><ul>
<li>// &#x9996;&#x5148;&#x5904;&#x7406;&#x5F15;&#x4ECB;&#x589E;&#x5F3A;<pre><code>if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) {
   eligibleAdvisors.add(candidate);
}
</code></pre> }
 boolean hasIntroductions = !eligibleAdvisors.isEmpty();
 for (Advisor candidate : candidateAdvisors) {<pre><code>if (candidate instanceof IntroductionAdvisor) {
   // already processed
   continue;
}
</code></pre></li>
<li>// &#x5BF9;&#x4E8E;&#x666E;&#x901A;bean&#x7684;&#x5904;&#x7406;<pre><code>if (canApply(candidate, clazz, hasIntroductions)) {
   eligibleAdvisors.add(candidate);
}
</code></pre> }
 return eligibleAdvisors;
}<ul>
<li>1.2.1) canApply&#xFF08;&#x771F;&#x6B63;&#x7684;&#x5339;&#x914D;)</li>
</ul>
</li>
</ul>
<pre><code>public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) {
</code></pre><ul>
<li>// &#x5904;&#x7406;&#x5F15;&#x5165;&#x589E;&#x5F3A;
 if (advisor instanceof IntroductionAdvisor) {<pre><code>return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
</code></pre> }</li>
<li>// &#x5904;&#x7406;PointcutAdvisor&#xFF0C;&#x662F;&#x6307;&#x6709;&#x5207;&#x5165;&#x70B9;&#x7684;Advisor
 else if (advisor instanceof PointcutAdvisor) {<pre><code>PointcutAdvisor pca = (PointcutAdvisor) advisor;
return canApply(pca.getPointcut(), targetClass, hasIntroductions);
</code></pre> }
 else {</li>
<li>// &#x6CA1;&#x6709;&#x5207;&#x5165;&#x70B9;&#x7684;&#x59CB;&#x7EC8;&#x5339;&#x914D;<pre><code>// It doesn&apos;t have a pointcut so we assume it applies.
return true;
</code></pre> }
}</li>
</ul>
<pre><code>public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) {
   Assert.notNull(pc, &quot;Pointcut must not be null&quot;);
   if (!pc.getClassFilter().matches(targetClass)) {
      return false;
   }

   MethodMatcher methodMatcher = pc.getMethodMatcher();
   if (methodMatcher == MethodMatcher.TRUE) {
      // No need to iterate the methods if we&apos;re matching any method anyway...
      return true;
   }

   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
   if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
   }
   // &#x83B7;&#x53D6;bean&#x76EE;&#x6807;&#x7C7B;&#x548C;&#x6240;&#x6709;&#x63A5;&#x53E3;&#xFF0C;&#x653E;&#x5230;&#x96C6;&#x5408;&#x4E2D;
   Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));
   classes.add(targetClass);
</code></pre><ul>
<li><p>// &#x904D;&#x5386;&#x96C6;&#x5408;&#xFF0C;&#x83B7;&#x53D6;&#x6BCF;&#x4E2A;&#x7C7B;/&#x63A5;&#x53E3;&#x7684;&#x6240;&#x6709;&#x65B9;&#x6CD5;&#xFF0C;&#x5E76;&#x5BF9;&#x65B9;&#x6CD5;&#x8FDB;&#x884C;&#x9010;&#x4E2A;&#x5339;&#x914D;
 for (Class&lt;?&gt; clazz : classes) {</p>
<pre><code>Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
for (Method method : methods) {
   if ((introductionAwareMethodMatcher != null &amp;&amp;
         introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||
         methodMatcher.matches(method, targetClass)) {
      return true;
   }
}
</code></pre><p> }
 return false;
}</p>
</li>
<li><ul>
<li>2) createProxy&#xFF08;&#x521B;&#x5EFA;&#x4EE3;&#x7406;)</li>
</ul>
</li>
<li><p>AbstractAutoProxyCreator#createProxy</p>
</li>
<li><p>&#x5728;&#x83B7;&#x53D6;&#x4E86;&#x6240;&#x6709;&#x5BF9;&#x5E94;&#x7684;bean&#x7684;&#x589E;&#x5F3A;&#x540E;&#xFF0C;&#x4FBF;&#x53EF;&#x4EE5;&#x8FDB;&#x884C;&#x4EE3;&#x7406;&#x7684;&#x521B;&#x5EFA;&#x4E86;&#x3002;</p>
</li>
<li><p>&#x903B;&#x8F91;&#xFF1A;</p>
<ul>
<li>1)&#x83B7;&#x53D6;&#x5F53;&#x524D;&#x7C7B;&#x4E2D;&#x7684;&#x5C5E;&#x6027;</li>
<li>2)&#x6DFB;&#x52A0;&#x4EE3;&#x7406;&#x63A5;&#x53E3;</li>
<li>3)&#x5C01;&#x88C5;Advisor&#x5E76;&#x52A0;&#x5165;&#x5230;ProxyFactory&#x4E2D;</li>
<li>4)&#x8BBE;&#x7F6E;&#x8981;&#x4EE3;&#x7406;&#x7684;&#x7C7B;</li>
<li>5)&#x5B50;&#x7C7B;&#x53EF;&#x4EE5;&#x5728;&#x6B64;&#x51FD;&#x6570;&#x4E2D;&#x8FDB;&#x884C;&#x5BF9;ProxyFactory&#x7684;&#x8FDB;&#x4E00;&#x6B65;&#x5C01;&#x88C5;</li>
<li>6)&#x8FDB;&#x884C;&#x83B7;&#x53D6;&#x4EE3;&#x7406;&#x64CD;&#x4F5C;</li>
</ul>
</li>
<li><p>specificInterceptors&#x5C31;&#x662F;&#x589E;&#x5F3A;&#x4EEC;&#xFF08;advisors)</p>
</li>
<li>targetSource &#x662F;new SingletonTargetSource(bean)</li>
<li><p>protected Object createProxy(</p>
<pre><code>Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {
</code></pre><p> if (this.beanFactory instanceof ConfigurableListableBeanFactory) {</p>
<pre><code>AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
</code></pre><p> }</p>
<p> ProxyFactory proxyFactory = new ProxyFactory();</p>
</li>
<li><p>// &#x83B7;&#x53D6;&#x5F53;&#x524D;&#x7C7B;&#x4E2D;&#x7684;&#x76F8;&#x5173;&#x5C5E;&#x6027;
 proxyFactory.copyFrom(this);</p>
<p> if (!proxyFactory.isProxyTargetClass()) {</p>
<pre><code>if (shouldProxyTargetClass(beanClass, beanName)) {
   proxyFactory.setProxyTargetClass(true);
}
else {
</code></pre></li>
<li><p>// &#x6DFB;&#x52A0;&#x4EE3;&#x7406;&#x63A5;&#x53E3;</p>
<pre><code>   evaluateProxyInterfaces(beanClass, proxyFactory);
}
</code></pre><p> }   </p>
<p> Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
 for (Advisor advisor : advisors) {</p>
</li>
<li>// &#x52A0;&#x5165;&#x589E;&#x5F3A;<pre><code>proxyFactory.addAdvisor(advisor);
</code></pre> }
 // &#x8BBE;&#x7F6E;&#x8981;&#x4EE3;&#x7406;&#x7684;&#x7C7B;
 proxyFactory.setTargetSource(targetSource);</li>
<li><p>// &#x5B9A;&#x5236;&#x4EE3;&#x7406;
 customizeProxyFactory(proxyFactory);
 // &#x7528;&#x6765;&#x63A7;&#x5236;proxyFactory&#x88AB;&#x914D;&#x7F6E;&#x540E;&#xFF0C;&#x662F;&#x5426;&#x8FD8;&#x5141;&#x8BB8;&#x4FEE;&#x6539;&#x589E;&#x5F3A;&#xFF0C;&#x7F3A;&#x7701;&#x503C;&#x4E3A;false
 proxyFactory.setFrozen(this.freezeProxy);
 if (advisorsPreFiltered()) {</p>
<pre><code>proxyFactory.setPreFiltered(true);
</code></pre><p> }</p>
<p> return proxyFactory.getProxy(getProxyClassLoader());
}</p>
<ul>
<li>2.1) buildAdvisors&#xFF08;&#x5C01;&#x88C5;&#x62E6;&#x622A;&#x5668;&#x4E3A;Advisor)</li>
</ul>
</li>
<li><p>protected Advisor[] buildAdvisors(String beanName, Object[] specificInterceptors) {
 // Handle prototypes correctly...
 Advisor[] commonInterceptors = resolveInterceptorNames();</p>
<p> List<object> allInterceptors = new ArrayList<object>();
 if (specificInterceptors != null) {</object></object></p>
<pre><code>allInterceptors.addAll(Arrays.asList(specificInterceptors));
if (commonInterceptors.length &gt; 0) {
   if (this.applyCommonInterceptorsFirst) {
      allInterceptors.addAll(0, Arrays.asList(commonInterceptors));
   }
   else {
      allInterceptors.addAll(Arrays.asList(commonInterceptors));
   }
}
</code></pre><p> }
 if (logger.isDebugEnabled()) {</p>
<pre><code>int nrOfCommonInterceptors = commonInterceptors.length;
int nrOfSpecificInterceptors = (specificInterceptors != null ? specificInterceptors.length : 0);
logger.debug(&quot;Creating implicit proxy for bean &apos;&quot; + beanName + &quot;&apos; with &quot; + nrOfCommonInterceptors +
      &quot; common interceptors and &quot; + nrOfSpecificInterceptors + &quot; specific interceptors&quot;);
</code></pre><p> }</p>
<p> Advisor[] advisors = new Advisor[allInterceptors.size()];
 for (int i = 0; i &lt; allInterceptors.size(); i++) {</p>
</li>
<li>// &#x62E6;&#x622A;&#x5668;&#x8FDB;&#x884C;&#x5C01;&#x88C5;&#x8F6C;&#x5316;&#x4E3A;advisor<pre><code>advisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i));
</code></pre> }
 return advisors;
}<ul>
<li>2.1.1) DefaultAdvisorAdapterRegistery#wrap</li>
</ul>
</li>
</ul>
<pre><code>public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException {
</code></pre><ul>
<li>// &#x5982;&#x679C;&#x8981;&#x5C01;&#x88C5;&#x7684;&#x5BF9;&#x8C61;&#x672C;&#x8EAB;&#x5C31;&#x662F;Advisor&#x7C7B;&#x578B;&#x7684;&#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;
 if (adviceObject instanceof Advisor) {<pre><code>return (Advisor) adviceObject;
</code></pre> }</li>
<li>// &#x56E0;&#x4E3A;&#x6B64;&#x5C01;&#x88C5;&#x65B9;&#x6CD5;&#x53EA;&#x5BF9;Advisor&#x548C;Advice&#x6709;&#x6548;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x662F;&#x5219;&#x4E0D;&#x80FD;&#x5C01;&#x88C5;
 if (!(adviceObject instanceof Advice)) {<pre><code>throw new UnknownAdviceTypeException(adviceObject);
</code></pre> }
 Advice advice = (Advice) adviceObject;
 if (advice instanceof MethodInterceptor) {<pre><code>// So well-known it doesn&apos;t even need an adapter.
</code></pre></li>
<li>// &#x5982;&#x679C;&#x662F;MethodInterceptor&#x7C7B;&#x578B;&#x5219;&#x4F7F;&#x7528;DefaultPointcutAdvisor&#x5C01;&#x88C5;<pre><code>return new DefaultPointcutAdvisor(advice);
</code></pre> }</li>
<li><p>// &#x5982;&#x679C;&#x5B58;&#x5728;Advisor&#x7684;Adapter&#xFF0C;&#x90A3;&#x4E48;&#x4E5F;&#x540C;&#x6837;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x5C01;&#x88C5;
 for (AdvisorAdapter adapter : this.adapters) {</p>
<pre><code>// Check that it is supported.
if (adapter.supportsAdvice(advice)) {
   return new DefaultPointcutAdvisor(advice);
}
</code></pre><p> }
 throw new UnknownAdviceTypeException(advice);
}</p>
</li>
<li><ul>
<li>2.2) getProxy</li>
</ul>
</li>
</ul>
<pre><code>public Object getProxy(ClassLoader classLoader) {
   return createAopProxy().getProxy(classLoader);
}
</code></pre><pre><code>- 2.2.1) createAopProxy&#xFF08;&#x521B;&#x5EFA;&#x4EE3;&#x7406;)
</code></pre><ul>
<li><p>protected final synchronized AopProxy createAopProxy() {
 if (!this.active) {</p>
<pre><code>activate();
</code></pre><p> }
 return getAopProxyFactory().createAopProxy(this);
}</p>
<ul>
<li>2.2.1.1) DefaultAopProxyFactory#createAopProxy</li>
</ul>
</li>
<li>&#x903B;&#x8F91;&#xFF1A;</li>
<li>&#x5982;&#x679C;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x5B9E;&#x73B0;&#x4E86;&#x63A5;&#x53E3;&#xFF0C;&#x9ED8;&#x8BA4;&#x60C5;&#x51B5;&#x4E0B;&#x4F1A;&#x4F7F;&#x7528;JDK&#x7684;&#x52A8;&#x6001;&#x4EE3;&#x7406;</li>
<li>&#x5982;&#x679C;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x5B9E;&#x73B0;&#x4E86;&#x63A5;&#x53E3;&#xFF0C;&#x53EF;&#x4EE5;&#x5F3A;&#x5236;&#x4F7F;&#x7528;CGLIB&#xFF08;proxy-target-class=false)</li>
<li>&#x5982;&#x679C;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x6CA1;&#x6709;&#x5B9E;&#x73B0;&#x63A5;&#x53E3;&#xFF0C;&#x5FC5;&#x987B;&#x91C7;&#x7528;CGLIB</li>
</ul>
<pre><code>public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
   if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
      Class&lt;?&gt; targetClass = config.getTargetClass();
      if (targetClass == null) {
         throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
               &quot;Either an interface or a target is required for proxy creation.&quot;);
      }
      if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
         return new JdkDynamicAopProxy(config);
      }
      return new ObjenesisCglibAopProxy(config);
   }
   else {
      return new JdkDynamicAopProxy(config);
   }
}
</code></pre><pre><code>- 2.2.2) getProxy&#xFF08;&#x83B7;&#x53D6;&#x4EE3;&#x7406;)
</code></pre><ul>
<li>1&gt;JdkDynamicAopProxy#getProxy</li>
<li>&#x8BE5;AopProxy&#x5B9E;&#x73B0;&#x4E86;InvocationHandler&#x63A5;&#x53E3;&#xFF0C;&#x91CD;&#x5199;&#x4E86;invoke&#x65B9;&#x6CD5;&#x3002;</li>
</ul>
<pre><code>public Object getProxy(ClassLoader classLoader) {
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());
   }
   Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
   findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
   return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
}
</code></pre><ul>
<li>invoke&#x65B9;&#x6CD5;&#xFF1A;</li>
</ul>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
   MethodInvocation invocation;
   Object oldProxy = null;
   boolean setProxyContext = false;

   TargetSource targetSource = this.advised.targetSource;
   Class&lt;?&gt; targetClass = null;
   Object target = null;

   try {
</code></pre><ul>
<li>// &#x5904;&#x7406;equals<pre><code>if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {
   // The target does not implement the equals(Object) method itself.
   return equals(args[0]);
}
</code></pre></li>
<li><p>// &#x5904;&#x7406;hashcode</p>
<pre><code>else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) {
   // The target does not implement the hashCode() method itself.
   return hashCode();
}
else if (method.getDeclaringClass() == DecoratingProxy.class) {
   // There is only getDecoratedClass() declared -&gt; dispatch to proxy config.
   return AopProxyUtils.ultimateTargetClass(this.advised);
}
else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;
      method.getDeclaringClass().isAssignableFrom(Advised.class)) {
   // Service invocations on ProxyConfig with the proxy config...
   return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
}

Object retVal;
// &#x6709;&#x65F6;&#x5019;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x5185;&#x90E8;&#x7684;&#x81EA;&#x6211;&#x8C03;&#x7528;&#x5C06;&#x65E0;&#x6CD5;&#x5B9E;&#x65BD;&#x5207;&#x9762;&#x4E2D;&#x7684;&#x589E;&#x5F3A;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x901A;&#x8FC7;&#x6B64;&#x5C5E;&#x6027;&#x66B4;&#x9732;&#x4EE3;&#x7406;
if (this.advised.exposeProxy) {
   // Make invocation available if necessary.
   oldProxy = AopContext.setCurrentProxy(proxy);
   setProxyContext = true;
}

// May be null. Get as late as possible to minimize the time we &quot;own&quot; the target,
// in case it comes from a pool.
target = targetSource.getTarget();
if (target != null) {
   targetClass = target.getClass();
}
// &#x83B7;&#x53D6;&#x5F53;&#x524D;&#x65B9;&#x6CD5;&#x7684;&#x62E6;&#x622A;&#x5668;&#x94FE;
// Get the interception chain for this method.
List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

// Check whether we have any advice. If we don&apos;t, we can fallback on direct
// reflective invocation of the target, and avoid creating a MethodInvocation.
if (chain.isEmpty()) {
   // We can skip creating a MethodInvocation: just invoke the target directly
   // Note that the final invoker must be an InvokerInterceptor so we know it does
   // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
   Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
</code></pre></li>
<li>// &#x5982;&#x679C;&#x6CA1;&#x6709;&#x53D1;&#x73B0;&#x4EFB;&#x4F55;&#x62E6;&#x622A;&#x5668;&#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;&#x8C03;&#x7528;&#x5207;&#x70B9;&#x65B9;&#x6CD5;&#xFF08;method.invoke())<pre><code>   retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
}
else {
</code></pre></li>
<li>// &#x5C06;&#x62E6;&#x622A;&#x5668;&#x5C01;&#x88C5;&#x5728;ReflectiveMethodInvocation<pre><code>   // We need to create a method invocation...
   invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
   // Proceed to the joinpoint through the interceptor chain.
</code></pre></li>
<li><p>// proceed&#x4E2D;&#x5B9E;&#x73B0;&#x4E86;&#x62E6;&#x622A;&#x5668;&#x65B9;&#x6CD5;&#x7684;&#x9010;&#x4E00;&#x8C03;&#x7528;</p>
<pre><code>   retVal = invocation.proceed();
}

// Massage return value if necessary.
Class&lt;?&gt; returnType = method.getReturnType();
</code></pre></li>
<li>// &#x8FD4;&#x56DE;&#x7ED3;&#x679C;<pre><code>if (retVal != null &amp;&amp; retVal == target &amp;&amp;
      returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;
      !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
   // Special case: it returned &quot;this&quot; and the return type of the method
   // is type-compatible. Note that we can&apos;t help if the target sets
   // a reference to itself in another returned object.
   retVal = proxy;
}
else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) {
   throw new AopInvocationException(
         &quot;Null return value from advice does not match primitive return type for: &quot; + method);
}
return retVal;
</code></pre> }
 finally {<pre><code>if (target != null &amp;&amp; !targetSource.isStatic()) {
   // Must have come from TargetSource.
   targetSource.releaseTarget(target);
}
if (setProxyContext) {
   // Restore old proxy.
   AopContext.setCurrentProxy(oldProxy);
}
</code></pre> }
}<ul>
<li>2.2.2.1) ReflectiveMethodInvocation#proceed&#xFF08;&#x6267;&#x884C;&#x62E6;&#x622A;&#x5668;&#x94FE;&#x7684;&#x65B9;&#x6CD5;)</li>
</ul>
</li>
</ul>
<pre><code>public Object proceed() throws Throwable {
</code></pre><pre><code>- // &#x6267;&#x884C;&#x5B8C;&#x6240;&#x6709;&#x589E;&#x5F3A;&#x540E;&#xFF0C;&#x6267;&#x884C;&#x5207;&#x70B9;&#x65B9;&#x6CD5;(method.invoke())
</code></pre><p>   // We start with an index of -1 and increment early.
   if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
      return invokeJoinpoint();
   }
   // &#x83B7;&#x53D6;&#x4E0B;&#x4E00;&#x4E2A;&#x8981;&#x6267;&#x884C;&#x7684;&#x62E6;&#x622A;&#x5668;
   Object interceptorOrInterceptionAdvice =         this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
   if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {</p>
<ul>
<li>// &#x52A8;&#x6001;&#x5339;&#x914D;<pre><code>// Evaluate dynamic method matcher here: static part will already have
// been evaluated and found to match.
InterceptorAndDynamicMethodMatcher dm =
      (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
   return dm.interceptor.invoke(this);
}
else {
</code></pre></li>
<li>// &#x4E0D;&#x5339;&#x914D;&#x5219;&#x4E0D;&#x6267;&#x884C;&#x62E6;&#x622A;&#x5668;&#xFF0C;&#x9012;&#x5F52;&#x8C03;&#x7528;&#x81EA;&#x5DF1;&#xFF0C;&#x6267;&#x884C;&#x4E0B;&#x4E00;&#x4E2A;&#x62E6;&#x622A;&#x5668;<pre><code>   // Dynamic matching failed.
   // Skip this interceptor and invoke the next in the chain.
   return proceed();
}
</code></pre> }
 else {</li>
<li><p>// &#x82E5;&#x4E3A;&#x666E;&#x901A;&#x62E6;&#x622A;&#x5668;&#x5219;&#x76F4;&#x63A5;&#x8C03;&#x7528;&#x62E6;&#x622A;&#x5668;</p>
<pre><code>// It&apos;s an interceptor, so we just invoke it: The pointcut will have
// been evaluated statically before this object was constructed.
return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
</code></pre><p> }
}</p>
<ul>
<li>2.2.2.1.1) invokeJoinpoint&#xFF08;&#x6267;&#x884C;&#x5207;&#x70B9;&#x65B9;&#x6CD5;) </li>
</ul>
</li>
<li>protected Object invokeJoinpoint() throws Throwable {
 return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);
}</li>
</ul>
<pre><code>public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)
      throws Throwable {

   // Use reflection to invoke the method.
   try {
      ReflectionUtils.makeAccessible(method);
      return method.invoke(target, args);
   }
   catch (InvocationTargetException ex) {
      // Invoked method threw a checked exception.
      // We must rethrow it. The client won&apos;t see the interceptor.
      throw ex.getTargetException();
   }
   catch (IllegalArgumentException ex) {
      throw new AopInvocationException(&quot;AOP configuration seems to be invalid: tried calling method [&quot; +
            method + &quot;] on target [&quot; + target + &quot;]&quot;, ex);
   }
   catch (IllegalAccessException ex) {
      throw new AopInvocationException(&quot;Could not access method [&quot; + method + &quot;]&quot;, ex);
   }
}
</code></pre><pre><code>- 2.2.2.1.2) invoke &#xFF08;&#x6267;&#x884C;&#x62E6;&#x622A;&#x5668;&#x65B9;&#x6CD5;)
</code></pre><pre><code>public interface MethodInterceptor extends Interceptor {
   Object invoke(MethodInvocation invocation) throws Throwable;
}
</code></pre><ul>
<li></li>
<li><p>2&gt;CglibAopProxy#getProxy</p>
</li>
<li>&#x867D;&#x7136;&#x8FD4;&#x56DE;&#x7684;Proxy&#x662F;ObjenesisCglibAopProxy&#xFF0C;&#x4F46;&#x5B83;&#x7EE7;&#x627F;&#x4E86;CglibAopProxy &#x7684;getProxy&#x65B9;&#x6CD5;&#x3002;</li>
<li>&#x5B9E;&#x73B0;&#x4E86;Enhancer&#x7684;&#x521B;&#x5EFA;&#x53CA;&#x63A5;&#x53E3;&#x5C01;&#x88C5;&#x3002;</li>
</ul>
<pre><code>public Object getProxy(ClassLoader classLoader) {
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Creating CGLIB proxy: target source is &quot; + this.advised.getTargetSource());
   }

   try {
      Class&lt;?&gt; rootClass = this.advised.getTargetClass();
      Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;);

      Class&lt;?&gt; proxySuperClass = rootClass;
      if (ClassUtils.isCglibProxyClass(rootClass)) {
         proxySuperClass = rootClass.getSuperclass();
         Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();
         for (Class&lt;?&gt; additionalInterface : additionalInterfaces) {
            this.advised.addInterface(additionalInterface);
         }
      }
      // &#x9A8C;&#x8BC1;class
      // Validate the class, writing log messages as necessary.
      validateClassIfNecessary(proxySuperClass, classLoader);
      // &#x521B;&#x5EFA;&#x53CA;&#x914D;&#x7F6E;Enhancer
      // Configure CGLIB Enhancer...
      Enhancer enhancer = createEnhancer();
      if (classLoader != null) {
         enhancer.setClassLoader(classLoader);
         if (classLoader instanceof SmartClassLoader &amp;&amp;
               ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
            enhancer.setUseCache(false);
         }
      }
      enhancer.setSuperclass(proxySuperClass);
      enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
      enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));
      // &#x8BBE;&#x7F6E;&#x62E6;&#x622A;&#x5668;
      Callback[] callbacks = getCallbacks(rootClass);
      Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length];
      for (int x = 0; x &lt; types.length; x++) {
         types[x] = callbacks[x].getClass();
      }
      // fixedInterceptorMap only populated at this point, after getCallbacks call above
      enhancer.setCallbackFilter(new ProxyCallbackFilter(
            this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
      enhancer.setCallbackTypes(types);
      // &#x751F;&#x6210;&#x4EE3;&#x7406;&#x7C7B;&#x4EE5;&#x53CA;&#x521B;&#x5EFA;&#x4EE3;&#x7406;
      // Generate the proxy class and create a proxy instance.
      return createProxyClassAndInstance(enhancer, callbacks);
   }
   catch (CodeGenerationException ex) {
      throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; +
            this.advised.getTargetClass() + &quot;]: &quot; +
            &quot;Common causes of this problem include using a final class or a non-visible class&quot;,
            ex);
   }
   catch (IllegalArgumentException ex) {
      throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; +
            this.advised.getTargetClass() + &quot;]: &quot; +
            &quot;Common causes of this problem include using a final class or a non-visible class&quot;,
            ex);
   }
   catch (Throwable ex) {
      // TargetSource.getTarget() failed
      throw new AopConfigException(&quot;Unexpected AOP exception&quot;, ex);
   }
}
</code></pre><ul>
<li><ul>
<li>2.2.2.1) getCallbacks</li>
</ul>
</li>
</ul>
<pre><code>private Callback[] getCallbacks(Class&lt;?&gt; rootClass) throws Exception {
   // Parameters used for optimisation choices...
   boolean exposeProxy = this.advised.isExposeProxy();
   boolean isFrozen = this.advised.isFrozen();
   boolean isStatic = this.advised.getTargetSource().isStatic();

   // Choose an &quot;aop&quot; interceptor (used for AOP calls).
</code></pre><ul>
<li><p>// &#x5C06;&#x62E6;&#x622A;&#x5668;&#x5C01;&#x88C5;&#x5728;DynamicAdvisedInterceptor&#x4E2D;
 Callback aopInterceptor = new DynamicAdvisedInterceptor(this.advised);</p>
<p> // Choose a &quot;straight to target&quot; interceptor. (used for calls that are
 // unadvised but can return this). May be required to expose the proxy.
 Callback targetInterceptor;
 if (exposeProxy) {</p>
<pre><code>targetInterceptor = isStatic ?
      new StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) :
      new DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource());
</code></pre><p> }
 else {</p>
<pre><code>targetInterceptor = isStatic ?
      new StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) :
      new DynamicUnadvisedInterceptor(this.advised.getTargetSource());
</code></pre><p> }</p>
<p> // Choose a &quot;direct to target&quot; dispatcher (used for
 // unadvised calls to static targets that cannot return this).
 Callback targetDispatcher = isStatic ?</p>
<pre><code>   new StaticDispatcher(this.advised.getTargetSource().getTarget()) : new SerializableNoOp();
</code></pre><p> Callback[] mainCallbacks = new Callback[] {</p>
</li>
<li><p>// &#x5C06;&#x62E6;&#x622A;&#x5668;&#x94FE;&#x52A0;&#x5165;&#x5230;Callback&#x4E2D;</p>
<pre><code>   aopInterceptor,  // for normal advice
   targetInterceptor,  // invoke target without considering advice, if optimized
   new SerializableNoOp(),  // no override for methods mapped to this
   targetDispatcher, this.advisedDispatcher,
   new EqualsInterceptor(this.advised),
   new HashCodeInterceptor(this.advised)
</code></pre><p> };</p>
<p> Callback[] callbacks;</p>
<p> // If the target is a static one and the advice chain is frozen,
 // then we can make some optimisations by sending the AOP calls
 // direct to the target using the fixed chain for that method.
 if (isStatic &amp;&amp; isFrozen) {</p>
<pre><code>Method[] methods = rootClass.getMethods();
Callback[] fixedCallbacks = new Callback[methods.length];
this.fixedInterceptorMap = new HashMap&lt;String, Integer&gt;(methods.length);

// TODO: small memory optimisation here (can skip creation for methods with no advice)
for (int x = 0; x &lt; methods.length; x++) {
   List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);
   fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(
         chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass());
   this.fixedInterceptorMap.put(methods[x].toString(), x);
}

// Now copy both the callbacks from mainCallbacks
// and fixedCallbacks into the callbacks array.
callbacks = new Callback[mainCallbacks.length + fixedCallbacks.length];
System.arraycopy(mainCallbacks, 0, callbacks, 0, mainCallbacks.length);
System.arraycopy(fixedCallbacks, 0, callbacks, mainCallbacks.length, fixedCallbacks.length);
this.fixedInterceptorOffset = mainCallbacks.length;
</code></pre><p> }
 else {</p>
<pre><code>callbacks = mainCallbacks;
</code></pre><p> }
 return callbacks;
}</p>
</li>
<li></li>
<li><p>CGLIB&#x5BF9;&#x4E8E;&#x65B9;&#x6CD5;&#x7684;&#x62E6;&#x622A;&#x662F;&#x901A;&#x8FC7;&#x5C06;&#x81EA;&#x5B9A;&#x4E49;&#x7684;&#x62E6;&#x622A;&#x5668;&#xFF08;&#x5B9E;&#x73B0;&#x4E86;MethodInterceptor&#x63A5;&#x53E3;)&#x52A0;&#x5165;Callback&#x4E2D;&#x5E76;&#x5728;&#x8C03;&#x7528;&#x4EE3;&#x7406;&#x65F6;&#x76F4;&#x63A5;&#x6FC0;&#x6D3B;&#x62E6;&#x622A;&#x5668;&#x7684;intercept&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#x7684;&#xFF0C;&#x90A3;&#x4E48;&#x5728;getCallback&#x4E2D;&#x5B9E;&#x73B0;&#x4E86;&#x8FD9;&#x6837;&#x4E00;&#x4E2A;&#x76EE;&#x7684;&#xFF1A;DynamicAdvisedInterceptor&#x7EE7;&#x627F;&#x81EA;MethodInterceptor&#xFF0C;&#x52A0;&#x5165;&#x5230;Callback&#x4E2D;&#x540E;&#xFF0C;&#x5728;&#x518D;&#x6B21;&#x8C03;&#x7528;&#x4EE3;&#x7406;&#x65F6;&#x4F1A;&#x76F4;&#x63A5;&#x8C03;&#x7528;DynamicAdvisedInterceptor&#x4E2D;&#x7684;intercept&#x65B9;&#x6CD5;&#x3002;</p>
</li>
<li>CGLIB&#x65B9;&#x5F0F;&#x5B9E;&#x73B0;&#x7684;&#x4EE3;&#x7406;&#xFF0C;&#x5176;&#x6838;&#x5FC3;&#x903B;&#x8F91;&#x5728;DynamicAdvisedInterceptor&#x4E2D;&#x7684;intercept&#x65B9;&#x6CD5;&#x4E2D;&#xFF08;JDK&#x52A8;&#x6001;&#x4EE3;&#x7406;&#x7684;&#x6838;&#x5FC3;&#x903B;&#x8F91;&#x662F;&#x5728;invoke&#x65B9;&#x6CD5;&#x4E2D;)&#x3002;</li>
</ul>
<pre><code>private static class DynamicAdvisedInterceptor implements MethodInterceptor, Serializable {

   private final AdvisedSupport advised;

   public DynamicAdvisedInterceptor(AdvisedSupport advised) {
      this.advised = advised;
   }

   @Override
   public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
      Object oldProxy = null;
      boolean setProxyContext = false;
      Class&lt;?&gt; targetClass = null;
      Object target = null;
      try {
         if (this.advised.exposeProxy) {
            // Make invocation available if necessary.
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
         }
         // May be null. Get as late as possible to minimize the time we
         // &quot;own&quot; the target, in case it comes from a pool...
         target = getTarget();
         if (target != null) {
            targetClass = target.getClass();
         }
</code></pre><ul>
<li>// &#x83B7;&#x53D6;&#x62E6;&#x622A;&#x5668;&#x94FE;<pre><code>   List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
   Object retVal;
   // Check whether we only have one InvokerInterceptor: that is,
   // no real advice, but just reflective invocation of the target.
   if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) {
      // We can skip creating a MethodInvocation: just invoke the target directly.
      // Note that the final invoker must be an InvokerInterceptor, so we know
      // it does nothing but a reflective operation on the target, and no hot
      // swapping or fancy proxying.
      Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
</code></pre></li>
<li>// &#x5982;&#x679C;&#x62E6;&#x622A;&#x5668;&#x4E3A;&#x7A7A;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x6FC0;&#x6D3B;&#x539F;&#x65B9;&#x6CD5;<pre><code>      retVal = methodProxy.invoke(target, argsToUse);
   }
   else {
</code></pre></li>
</ul>
<pre><code>// &#x8FDB;&#x5165;&#x62E6;&#x622A;&#x5668;&#x94FE;
            // We need to create a method invocation...
            retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
         }
         retVal = processReturnType(proxy, target, method, retVal);
         return retVal;
      }
      finally {
         if (target != null) {
            releaseTarget(target);
         }
         if (setProxyContext) {
            // Restore old proxy.
            AopContext.setCurrentProxy(oldProxy);
         }
      }
   }

   @Override
   public boolean equals(Object other) {
      return (this == other ||
            (other instanceof DynamicAdvisedInterceptor &amp;&amp;
                  this.advised.equals(((DynamicAdvisedInterceptor) other).advised)));
   }

   /**
    * CGLIB uses this to drive proxy creation.
    */
   @Override
   public int hashCode() {
      return this.advised.hashCode();
   }

   protected Object getTarget() throws Exception {
      return this.advised.getTargetSource().getTarget();
   }

   protected void releaseTarget(Object target) throws Exception {
      this.advised.getTargetSource().releaseTarget(target);
   }
}
</code></pre><pre><code>- 2.2.2.2) createProxyClassAndInstance
</code></pre><ul>
<li><p>protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {
 Class&lt;?&gt; proxyClass = enhancer.createClass();
 Object proxyInstance = null;</p>
<p> if (objenesis.isWorthTrying()) {</p>
<pre><code>try {
   proxyInstance = objenesis.newInstance(proxyClass, enhancer.getUseCache());
}
catch (Throwable ex) {
   logger.debug(&quot;Unable to instantiate proxy using Objenesis, &quot; +
         &quot;falling back to regular proxy construction&quot;, ex);
}
</code></pre><p> }</p>
<p> if (proxyInstance == null) {</p>
<pre><code>// Regular instantiation via default constructor...
try {
   proxyInstance = (this.constructorArgs != null ?
         proxyClass.getConstructor(this.constructorArgTypes).newInstance(this.constructorArgs) :
         proxyClass.newInstance());
}
catch (Throwable ex) {
   throw new AopConfigException(&quot;Unable to instantiate proxy using Objenesis, &quot; +
         &quot;and regular proxy instantiation via default constructor fails as well&quot;, ex);
}
</code></pre><p> }</p>
<p> ((Factory) proxyInstance).setCallbacks(callbacks);
 return proxyInstance;
}</p>
</li>
<li></li>
<li><p>&#x5B9E;&#x4F8B;</p>
</li>
</ul>
<pre><code>public class LoggingAspect {
    @Pointcut(&quot;@annotation(org.springframework.web.bind.annotation.RequestMapping)&quot;)
    public void declareJoinPointExpression() {
    }

    @Before(&quot;declareJoinPointExpression()&quot;)
    public void beforeMethod(JoinPoint joinPoint) {// &#x8FDE;&#x63A5;&#x70B9;
        Object[] args = joinPoint.getArgs();// &#x53D6;&#x5F97;&#x65B9;&#x6CD5;&#x53C2;&#x6570;
        log.info(&quot;The method [ {} ] begins with Parameters: {}&quot;, joinPoint.getSignature(), Arrays.toString(args));
    }

    @AfterReturning(value = &quot;declareJoinPointExpression()&quot;, returning = &quot;result&quot;)
    public void afterMethodReturn(JoinPoint joinPoint, Object result) {
        log.info(&quot;The method [ {} ] ends with Result: {}&quot;, joinPoint.getSignature(), result);
    }

    @AfterThrowing(value = &quot;declareJoinPointExpression()&quot;, throwing = &quot;e&quot;)
    public void doAfterThrowing(JoinPoint joinPoint, Exception e) {
        log.error(&quot;Error happened in method: [ {} ]&quot;, joinPoint.getSignature());
        log.error(&quot;Parameters: {}&quot;, Arrays.toString(joinPoint.getArgs()));
        log.error(&quot;Exception StackTrace: {}&quot;, e);
    }
}
</code></pre><pre><code>@Controller
public class HelloController {

    @RequestMapping(&quot;/hello&quot;)
    public ModelAndView hello(ModelAndView modelAndView){
        modelAndView.addObject(&quot;user&quot;,new RegisterDTO(&quot;admin&quot;));
        modelAndView.setViewName(&quot;hello&quot;);
        return modelAndView;
    }
}
</code></pre><ul>
<li>&#x6765;&#x770B;&#x4E00;&#x4E0B;&#x8FD9;&#x4E2A;HelloController&#x662F;&#x600E;&#x4E48;&#x88AB;AOP&#x4EE3;&#x7406;&#x7684;&#x3002;</li>
<li><p>&#x4ECE;AbstractAutoProxyCreator.postProcessAfterInitialization&#x5F00;&#x59CB;&#x770B;&#x8D77;&#x3002;</p>
</li>
<li><p>&#x5728;findCandidateAdvisors&#x4E2D;</p>
</li>
<li><p>super.findCandidateAdvisors()&#x8FD4;&#x56DE;&#x4E86;&#x4E09;&#x4E2A;Advisor</p>
</li>
<li><p>&#x5728;buildAdvisors&#x4E2D;&#xFF0C;&#x53C8;&#x6DFB;&#x52A0;&#x4E86;LoggingAspect&#x5BF9;&#x5E94;&#x7684;&#x4E09;&#x4E2A;Advisor&#xFF0C;&#x7C7B;&#x578B;&#x662F;InstantiationModelAwarePointcutAdvisorImpl&#x3002;</p>
</li>
<li><p>&#x5B83;getPointcut&#x8FD4;&#x56DE;&#x7684;&#x662F;AspectJExpressionPointcut</p>
</li>
<li><p>&#x7136;&#x540E;&#x4E0B;&#x9762;&#x4F1A;&#x627E;&#x5230;&#x6240;&#x6709;Controller&#xFF0C;&#x5F97;&#x5230;Controller&#x7684;&#x6240;&#x6709;&#x65B9;&#x6CD5;&#xFF0C;&#x67E5;&#x770B;&#x662F;&#x5426;&#x5339;&#x914D;&#x3002;</p>
</li>
<li><p>&#x6700;&#x540E;&#x8FD4;&#x56DE;&#x7684;interceptors&#x6709;5&#x4E2A;&#xFF0C;</p>
</li>
<li><p>&#x4E4B;&#x540E;&#x8C03;&#x7528;createProxy&#xFF0C;&#x6700;&#x540E;&#x8C03;&#x7528;&#x4E86;DefaultAopProxyFactory.createAopProxy&#x65B9;&#x6CD5;&#xFF0C;&#x8FD4;&#x56DE;&#x4E86;CglibAopProxy&#x3002;</p>
</li>
<li><p>&#x5B83;&#x518D;&#x8C03;&#x7528;getProxy&#x65B9;&#x6CD5;&#xFF0C;&#x5C06;5&#x4E2A;advisor&#x5C01;&#x88C5;&#x4E3A;Callback&#x3002;</p>
</li>
<li><p>&#x6700;&#x540E;&#x751F;&#x6210;cglib&#x4EE3;&#x7406;&#x5B9E;&#x4F8B;&#x3002;</p>
</li>
<li><p>Spring Transaction&#xFF08;&#x58F0;&#x660E;&#x5F0F;&#x4E8B;&#x52A1;)</p>
</li>
<li></li>
<li><p>&#x4E8B;&#x52A1;&#x4ECB;&#x7ECD;&#xFF08;&#x4E24;&#x7C7B;&#x4E8B;&#x52A1;)</p>
</li>
<li>&#x7F16;&#x7A0B;&#x5F0F;&#x4E8B;&#x52A1;&#xFF1A;&#x6240;&#x8C13;&#x7F16;&#x7A0B;&#x5F0F;&#x4E8B;&#x52A1;&#x6307;&#x7684;&#x662F;&#x901A;&#x8FC7;&#x7F16;&#x7801;&#x65B9;&#x5F0F;&#x5B9E;&#x73B0;&#x4E8B;&#x52A1;&#xFF0C;&#x5373;&#x7C7B;&#x4F3C;&#x4E8E;JDBC&#x7F16;&#x7A0B;&#x5B9E;&#x73B0;&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x3002;&#x7BA1;&#x7406;&#x4F7F;&#x7528;TransactionTemplate&#x6216;&#x8005;&#x76F4;&#x63A5;&#x4F7F;&#x7528;&#x5E95;&#x5C42;&#x7684;PlatformTransactionManager&#x3002;&#x5BF9;&#x4E8E;&#x7F16;&#x7A0B;&#x5F0F;&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#xFF0C;Spring&#x63A8;&#x8350;&#x4F7F;&#x7528;TransactionTemplate&#x3002;</li>
<li>&#x58F0;&#x660E;&#x5F0F;&#x4E8B;&#x52A1;&#xFF1A;&#x7BA1;&#x7406;&#x5EFA;&#x7ACB;&#x5728;AOP&#x4E4B;&#x4E0A;&#x7684;&#x3002;&#x5176;&#x672C;&#x8D28;&#x662F;&#x5BF9;&#x65B9;&#x6CD5;&#x524D;&#x540E;&#x8FDB;&#x884C;&#x62E6;&#x622A;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x5F00;&#x59CB;&#x4E4B;&#x524D;&#x521B;&#x5EFA;&#x6216;&#x8005;&#x52A0;&#x5165;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#xFF0C;&#x5728;&#x6267;&#x884C;&#x5B8C;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x4E4B;&#x540E;&#x6839;&#x636E;&#x6267;&#x884C;&#x60C5;&#x51B5;&#x63D0;&#x4EA4;&#x6216;&#x8005;&#x56DE;&#x6EDA;&#x4E8B;&#x52A1;&#x3002;&#x58F0;&#x660E;&#x5F0F;&#x4E8B;&#x52A1;&#x6700;&#x5927;&#x7684;&#x4F18;&#x70B9;&#x5C31;&#x662F;&#x4E0D;&#x9700;&#x8981;&#x901A;&#x8FC7;&#x7F16;&#x7A0B;&#x7684;&#x65B9;&#x5F0F;&#x7BA1;&#x7406;&#x4E8B;&#x52A1;&#xFF0C;&#x8FD9;&#x6837;&#x5C31;&#x4E0D;&#x9700;&#x8981;&#x5728;&#x4E1A;&#x52A1;&#x903B;&#x8F91;&#x4EE3;&#x7801;&#x4E2D;&#x63BA;&#x6742;&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x7684;&#x4EE3;&#x7801;&#xFF0C;&#x53EA;&#x9700;&#x5728;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#x505A;&#x76F8;&#x5173;&#x7684;&#x4E8B;&#x52A1;&#x89C4;&#x5219;&#x58F0;&#x660E;(&#x6216;&#x901A;&#x8FC7;&#x57FA;&#x4E8E;@Transactional&#x6CE8;&#x89E3;&#x7684;&#x65B9;&#x5F0F;)&#xFF0C;&#x4FBF;&#x53EF;&#x4EE5;&#x5C06;&#x4E8B;&#x52A1;&#x89C4;&#x5219;&#x5E94;&#x7528;&#x5230;&#x4E1A;&#x52A1;&#x903B;&#x8F91;&#x4E2D;&#x3002;</li>
<li>&#x663E;&#x7136;&#x58F0;&#x660E;&#x5F0F;&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x8981;&#x4F18;&#x4E8E;&#x7F16;&#x7A0B;&#x5F0F;&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#xFF0C;&#x8FD9;&#x6B63;&#x662F;spring&#x5021;&#x5BFC;&#x7684;&#x975E;&#x4FB5;&#x5165;&#x5F0F;&#x7684;&#x5F00;&#x53D1;&#x65B9;&#x5F0F;&#x3002;</li>
<li>&#x58F0;&#x660E;&#x5F0F;&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x4F7F;&#x4E1A;&#x52A1;&#x4EE3;&#x7801;&#x4E0D;&#x53D7;&#x6C61;&#x67D3;&#xFF0C;&#x4E00;&#x4E2A;&#x666E;&#x901A;&#x7684;POJO&#x5BF9;&#x8C61;&#xFF0C;&#x53EA;&#x8981;&#x52A0;&#x4E0A;&#x6CE8;&#x89E3;&#x5C31;&#x53EF;&#x4EE5;&#x83B7;&#x5F97;&#x5B8C;&#x5168;&#x7684;&#x4E8B;&#x52A1;&#x652F;&#x6301;&#x3002;&#x548C;&#x7F16;&#x7A0B;&#x5F0F;&#x4E8B;&#x52A1;&#x76F8;&#x6BD4;&#xFF0C;&#x58F0;&#x660E;&#x5F0F;&#x4E8B;&#x52A1;&#x552F;&#x4E00;&#x4E0D;&#x8DB3;&#x5730;&#x65B9;&#x662F;&#xFF0C;&#x540E;&#x8005;&#x7684;&#x6700;&#x7EC6;&#x7C92;&#x5EA6;&#x53EA;&#x80FD;&#x4F5C;&#x7528;&#x5230;&#x65B9;&#x6CD5;&#x7EA7;&#x522B;&#xFF0C;&#x65E0;&#x6CD5;&#x505A;&#x5230;&#x50CF;&#x7F16;&#x7A0B;&#x5F0F;&#x4E8B;&#x52A1;&#x90A3;&#x6837;&#x53EF;&#x4EE5;&#x4F5C;&#x7528;&#x5230;&#x4EE3;&#x7801;&#x5757;&#x7EA7;&#x522B;&#x3002;&#x4F46;&#x662F;&#x5373;&#x4FBF;&#x6709;&#x8FD9;&#x6837;&#x7684;&#x9700;&#x6C42;&#xFF0C;&#x4E5F;&#x5B58;&#x5728;&#x5F88;&#x591A;&#x53D8;&#x901A;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x6BD4;&#x5982;&#xFF0C;&#x53EF;&#x4EE5;&#x5C06;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x4E8B;&#x52A1;&#x7BA1;&#x7406;&#x7684;&#x4EE3;&#x7801;&#x5757;&#x72EC;&#x7ACB;&#x4E3A;&#x65B9;&#x6CD5;&#x7B49;&#x7B49;&#x3002;</li>
<li>&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;</li>
<li>PROPAGATION_REQUIRED</li>
<li><p>&#x5982;&#x679C;&#x5F53;&#x524D;&#x5B58;&#x5728;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x52A0;&#x5165;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#xFF1B;&#x5982;&#x679C;&#x4E0D;&#x5B58;&#x5728;&#x4EFB;&#x4F55;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x4E8B;&#x52A1;&#x3002;&#x603B;&#x4E4B;&#xFF0C;&#x8981;&#x81F3;&#x5C11;&#x4FDD;&#x8BC1;&#x5728;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#x4E2D;&#x8FD0;&#x884C;&#x3002;PROPAGATION_REQUIRED&#x901A;&#x5E38;&#x4F5C;&#x4E3A;&#x9ED8;&#x8BA4;&#x7684;&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#x3002;</p>
</li>
<li><p>PROPAGATION_SUPPORTS</p>
</li>
<li>&#x5982;&#x679C;&#x5F53;&#x524D;&#x5B58;&#x5728;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x52A0;&#x5165;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#xFF1B;&#x5982;&#x679C;&#x5F53;&#x524D;&#x4E0D;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x6267;&#x884C;&#x3002; &#x5BF9;&#x4E8E;&#x4E00;&#x4E9B;&#x67E5;&#x8BE2;&#x65B9;&#x6CD5;&#x6765;&#x8BF4;&#xFF0C;PROPAGATION_SUPPORTS&#x901A;&#x5E38;&#x662F;&#x6BD4;&#x8F83;&#x5408;&#x9002;&#x7684;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#x9009;&#x62E9;&#x3002; &#x5982;&#x679C;&#x5F53;&#x524D;&#x65B9;&#x6CD5;&#x76F4;&#x63A5;&#x6267;&#x884C;&#xFF0C;&#x90A3;&#x4E48;&#x4E0D;&#x9700;&#x8981;&#x4E8B;&#x52A1;&#x7684;&#x652F;&#x6301;&#xFF1B;&#x5982;&#x679C;&#x5F53;&#x524D;&#x65B9;&#x6CD5;&#x88AB;&#x5176;&#x4ED6;&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#xFF0C;&#x800C;&#x5176;&#x4ED6;&#x65B9;&#x6CD5;&#x542F;&#x52A8;&#x4E86;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x4F7F;&#x7528;PROPAGATION_SUPPORTS&#x53EF;&#x4EE5;&#x4FDD;&#x8BC1;&#x5F53;&#x524D;&#x65B9;&#x6CD5;&#x80FD;&#x591F;&#x52A0;&#x5165;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x5E76;&#x6D1E;&#x5BDF;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x5BF9;&#x6570;&#x636E;&#x8D44;&#x6E90;&#x6240;&#x505A;&#x7684;&#x66F4;&#x65B0;&#x3002; &#x6BD4;&#x5982;&#x8BF4;&#xFF0C;A.service()&#x4F1A;&#x9996;&#x5148;&#x66F4;&#x65B0;&#x6570;&#x636E;&#x5E93;&#xFF0C;&#x7136;&#x540E;&#x8C03;&#x7528;B.service()&#x8FDB;&#x884C;&#x67E5;&#x8BE2;&#xFF0C;&#x90A3;&#x4E48;&#xFF0C;B.service()&#x5982;&#x679C;&#x662F;PROPAGATION_SUPPORTS&#x7684;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#xFF0C; &#x5C31;&#x53EF;&#x4EE5;&#x8BFB;&#x53D6;A.service()&#x4E4B;&#x524D;&#x6240;&#x505A;&#x7684;&#x6700;&#x65B0;&#x66F4;&#x65B0;&#x7ED3;&#x679C;&#xFF0C;&#x800C;&#x5982;&#x679C;&#x4F7F;&#x7528;&#x7A0D;&#x540E;&#x6240;&#x63D0;&#x5230;&#x7684;PROPAGATION_NOT_SUPPORTED&#xFF0C;&#x5219;B.service()&#x5C06;&#x65E0;&#x6CD5;&#x8BFB;&#x53D6;&#x6700;&#x65B0;&#x7684;&#x66F4;&#x65B0;&#x7ED3;&#x679C;&#xFF0C;&#x56E0;&#x4E3A;A.service()&#x7684;&#x4E8B;&#x52A1;&#x5728;&#x8FD9;&#x4E2A;&#x65F6;&#x5019;&#x8FD8;&#x6CA1;&#x6709;&#x63D0;&#x4EA4;(&#x9664;&#x975E;&#x9694;&#x79BB;&#x7EA7;&#x522B;&#x662F;read uncommitted)&#x3002;</li>
<li>PROPAGATION_MANDATORY</li>
<li>PROPAGATION_MANDATORY&#x5F3A;&#x5236;&#x8981;&#x6C42;&#x5F53;&#x524D;&#x5B58;&#x5728;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x5219;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002; &#x5982;&#x679C;&#x67D0;&#x4E2A;&#x65B9;&#x6CD5;&#x9700;&#x8981;&#x4E8B;&#x52A1;&#x652F;&#x6301;&#xFF0C;&#x4F46;&#x81EA;&#x8EAB;&#x53C8;&#x4E0D;&#x7BA1;&#x7406;&#x4E8B;&#x52A1;&#x63D0;&#x4EA4;&#x6216;&#x8005;&#x56DE;&#x6EDA;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x6BD4;&#x8F83;&#x9002;&#x5408;&#x4F7F;&#x7528;</li>
<li>PROPAGATION_MANDATORY&#x3002;</li>
<li>PROPAGATION_REQUIRES_NEW</li>
<li><p>&#x4E0D;&#x7BA1;&#x5F53;&#x524D;&#x662F;&#x5426;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#xFF0C;&#x90FD;&#x4F1A;&#x521B;&#x5EFA;&#x65B0;&#x7684;&#x4E8B;&#x52A1;&#x3002;&#x5982;&#x679C;&#x5F53;&#x524D;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#x7684;&#x8BDD;&#xFF0C;&#x4F1A;&#x5C06;&#x5F53;&#x524D;&#x7684;&#x4E8B;&#x52A1;&#x6302;&#x8D77;(suspend)&#x3002; &#x5982;&#x679C;&#x67D0;&#x4E2A;&#x4E1A;&#x52A1;&#x5BF9;&#x8C61;&#x6240;&#x505A;&#x7684;&#x4E8B;&#x60C5;&#x4E0D;&#x60F3;&#x5F71;&#x54CD;&#x5230;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x7684;&#x8BDD;&#xFF0C;PROPAGATION_REQUIRES_NEW&#x5E94;&#x8BE5;&#x662F;&#x5408;&#x9002;&#x7684;&#x9009;&#x62E9;&#xFF0C;&#x6BD4;&#x5982;&#xFF0C;&#x5047;&#x8BBE;&#x5F53;&#x524D;&#x7684;&#x4E1A;&#x52A1;&#x65B9;&#x6CD5;&#x9700;&#x8981;&#x5411;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x66F4;&#x65B0;&#x67D0;&#x4E9B;&#x65E5;&#x5FD7;&#x4FE1;&#x606F;&#xFF0C; &#x4F46;&#x5373;&#x4F7F;&#x8FD9;&#x4E9B;&#x65E5;&#x5FD7;&#x4FE1;&#x606F;&#x66F4;&#x65B0;&#x5931;&#x8D25;&#xFF0C;&#x6211;&#x4EEC;&#x4E5F;&#x4E0D;&#x60F3;&#x56E0;&#x4E3A;&#x8BE5;&#x4E1A;&#x52A1;&#x65B9;&#x6CD5;&#x7684;&#x4E8B;&#x52A1;&#x56DE;&#x6EDA;&#x800C;&#x5F71;&#x54CD;&#x5230;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x7684;&#x6210;&#x529F;&#x63D0;&#x4EA4;&#xFF0C;&#x56E0;&#x4E3A;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x5F53;&#x524D;&#x4E1A;&#x52A1;&#x65B9;&#x6CD5;&#x7684;&#x4E8B;&#x52A1;&#x6210;&#x529F;&#x4E0E;&#x5426;&#x5BF9;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x6765;&#x8BF4;&#x662F;&#x65E0;&#x5173;&#x7D27;&#x8981;&#x7684;&#x3002;</p>
</li>
<li><p>PROPAGATION_NOT_SUPPORTED</p>
</li>
<li>&#x4E0D;&#x652F;&#x6301;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#xFF0C;&#x800C;&#x662F;&#x5728;&#x6CA1;&#x6709;&#x4E8B;&#x52A1;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x6267;&#x884C;&#x3002;&#x5982;&#x679C;&#x5F53;&#x524D;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#x7684;&#x8BDD;&#xFF0C;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x539F;&#x5219;&#x4E0A;&#x5C06;&#x88AB;&#x6302;&#x8D77;(suspend)&#xFF0C;&#x4F46;&#x8981;&#x4F9D;&#x8D56;&#x4E8E;&#x5BF9;&#x5E94;&#x7684;PlatformTransactionManager&#x5B9E;&#x73B0;&#x7C7B;&#x662F;&#x5426;&#x652F;&#x6301;&#x4E8B;&#x52A1;&#x7684;&#x6302;&#x8D77;(suspend)&#xFF0C;&#x66F4;&#x591A;&#x60C5;&#x51B5;&#x8BF7;&#x53C2;&#x7167;TransactionDefinition&#x7684;javadoc&#x6587;&#x6863;&#x3002; PROPAGATION_NOT_SUPPORTED&#x4E0E;PROPAGATION_SUPPORTS&#x4E4B;&#x95F4;&#x7684;&#x533A;&#x522B;&#xFF0C;&#x53EF;&#x4EE5;&#x53C2;&#x7167;PROPAGATION_SUPPORTS&#x90E8;&#x5206;&#x7684;&#x5B9E;&#x4F8B;&#x5185;&#x5BB9;&#x3002;</li>
<li>PROPAGATION_NEVER</li>
<li><p>&#x6C38;&#x8FDC;&#x4E0D;&#x9700;&#x8981;&#x5F53;&#x524D;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#xFF0C;&#x5982;&#x679C;&#x5B58;&#x5728;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002;</p>
</li>
<li><p>PROPAGATION_NESTED</p>
</li>
<li>&#x5982;&#x679C;&#x5B58;&#x5728;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x5728;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x7684;&#x4E00;&#x4E2A;&#x5D4C;&#x5957;&#x4E8B;&#x52A1;&#x4E2D;&#x6267;&#x884C;&#xFF0C;&#x5426;&#x5219;&#x4E0E;PROPAGATION_REQUIRED&#x7684;&#x884C;&#x4E3A;&#x7C7B;&#x4F3C;&#xFF0C;&#x5373;&#x521B;&#x5EFA;&#x65B0;&#x7684;&#x4E8B;&#x52A1;&#xFF0C;&#x5728;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#x4E8B;&#x52A1;&#x4E2D;&#x6267;&#x884C;&#x3002; PROPAGATION_NESTED&#x7C97;&#x770B;&#x8D77;&#x6765;&#x597D;&#x50CF;&#x4E0E;PROPAGATION_REQUIRES_NEW&#x7684;&#x884C;&#x4E3A;&#x7C7B;&#x4F3C;&#xFF0C;&#x5B9E;&#x9645;&#x4E0A;&#x4E8C;&#x8005;&#x662F;&#x6709;&#x5DEE;&#x522B;&#x7684;&#x3002; PROPAGATION_REQUIRES_NEW&#x521B;&#x5EFA;&#x7684;&#x65B0;&#x4E8B;&#x52A1;&#x4E0E;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x5C5E;&#x4E8E;&#x540C;&#x4E00;&#x4E2A;&#x201C;&#x6863;&#x6B21;&#x201D;&#xFF0C;&#x5373;&#x4E8C;&#x8005;&#x7684;&#x5730;&#x4F4D;&#x662F;&#x76F8;&#x540C;&#x7684;&#xFF0C;&#x5F53;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#x4E8B;&#x52A1;&#x8FD0;&#x884C;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x5C06;&#x88AB;&#x6682;&#x65F6;&#x6302;&#x8D77;(suspend)&#xFF1B; &#x800C;PROPAGATION_NESTED&#x521B;&#x5EFA;&#x7684;&#x5D4C;&#x5957;&#x4E8B;&#x52A1;&#x5219;&#x4E0D;&#x7136;&#xFF0C;&#x5B83;&#x662F;&#x5BC4;&#x751F;&#x4E8E;&#x5F53;&#x524D;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x7684;&#xFF0C;&#x5B83;&#x7684;&#x5730;&#x4F4D;&#x6BD4;&#x5F53;&#x524D;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x7684;&#x5730;&#x4F4D;&#x8981;&#x5C0F;&#x4E00;&#x53F7;&#xFF0C;&#x5F53;&#x5185;&#x90E8;&#x5D4C;&#x5957;&#x4E8B;&#x52A1;&#x8FD0;&#x884C;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x4E5F;&#x662F;&#x5904;&#x4E8E;active&#x72B6;&#x6001;&#x3002;&#x662F;&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#x7684;&#x4E00;&#x4E2A;&#x771F;&#x6B63;&#x7684;&#x5B50;&#x4E8B;&#x52A1;. &#x5D4C;&#x5957;&#x4E8B;&#x52A1;&#x5F00;&#x59CB;&#x6267;&#x884C;&#x65F6;,  &#x5B83;&#x5C06;&#x53D6;&#x5F97;&#x4E00;&#x4E2A; savepoint. &#x5982;&#x679C;&#x8FD9;&#x4E2A;&#x5D4C;&#x5957;&#x4E8B;&#x52A1;&#x5931;&#x8D25;, &#x6211;&#x4EEC;&#x5C06;&#x56DE;&#x6EDA;&#x5230;&#x6B64; savepoint. &#x5D4C;&#x5957;&#x4E8B;&#x52A1;&#x662F;&#x5916;&#x90E8;&#x4E8B;&#x52A1;&#x7684;&#x4E00;&#x90E8;&#x5206;, &#x53EA;&#x6709;&#x5916;&#x90E8;&#x4E8B;&#x52A1;&#x7ED3;&#x675F;&#x540E;&#x5B83;&#x624D;&#x4F1A;&#x88AB;&#x63D0;&#x4EA4;&#xFF0C;&#x5916;&#x90E8;&#x4E8B;&#x52A1;&#x56DE;&#x6EDA;&#xFF0C;&#x5B83;&#x4E5F;&#x4F1A;&#x88AB;&#x56DE;&#x6EDA;&#x3002;</li>
<li>&#x89E3;&#x6790;&#x4E8B;&#x52A1;&#x6807;&#x7B7E;</li>
<li><tx:annotation-driven></tx:annotation-driven></li>
<li>&#x540C;AOP&#x6807;&#x7B7E;&#xFF0C;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x5BF9;&#x5E94;&#x7684;BeanDefinitionParser&#x3002;</li>
<li>AnnotationDrivenBeanDefinitionParser#parse</li>
</ul>
<pre><code>public BeanDefinition parse(Element element, ParserContext parserContext) {
   registerTransactionalEventListenerFactory(parserContext);
   String mode = element.getAttribute(&quot;mode&quot;);
   if (&quot;aspectj&quot;.equals(mode)) {
      // mode=&quot;aspectj&quot;
      registerTransactionAspect(element, parserContext);
   }
   else {
      // mode=&quot;proxy&quot;
      AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);
   }
   return null;
}
</code></pre><ul>
<li>AopAutoProxyConfigurer#configureAutoProxyCreator</li>
<li>&#x903B;&#x8F91;&#xFF1A;</li>
<li>&#x6CE8;&#x518C;&#x4E86;&#x4E00;&#x4E2A;creator&#x548C;&#x4E09;&#x4E2A;bean&#x3002;&#x8FD9;&#x4E09;&#x4E2A;bean&#x652F;&#x6491;&#x8D77;&#x4E86;&#x6574;&#x4E2A;&#x7684;&#x4E8B;&#x52A1;&#x529F;&#x80FD;&#x3002;</li>
<li>&#x5176;&#x4E2D;&#x7684;&#x4E24;&#x4E2A;bean&#xFF08;TransactionInterceptor&#x548C;AnnotationTransactionAttributeSource)&#x88AB;&#x6CE8;&#x5165;&#x5230;&#x4E86;&#x4E00;&#x4E2A;&#x540D;&#x4E3A;BeanFactoryTransactionAttributeSourceAdvisor&#x8FD9;&#x4E2A;bean&#x4E2D;&#x3002;</li>
</ul>
<pre><code>public static void configureAutoProxyCreator(Element element, ParserContext parserContext) {
</code></pre><ul>
<li><p>// &#x6CE8;&#x518C;InfrastructureAdvisorAutoProxyCreator&#x8FD9;&#x4E2A;&#x7C7B;
 AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);</p>
<p> String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;
 if (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) {</p>
<pre><code>Object eleSource = parserContext.extractSource(element);
// Create the TransactionAttributeSource definition.
</code></pre></li>
<li>//&#x521B;&#x5EFA;TransactionAttributeSource&#x7684;bean</li>
<li>RootBeanDefinition sourceDef = new RootBeanDefinition(<pre><code>      &quot;org.springframework.transaction.annotation.AnnotationTransactionAttributeSource&quot;);
sourceDef.setSource(eleSource);
sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
</code></pre></li>
<li>// &#x6CE8;&#x518C;bean&#xFF0C;&#x5E76;&#x4F7F;&#x7528;Spring&#x4E2D;&#x7684;&#x5B9A;&#x4E49;&#x89C4;&#x5219;&#x751F;&#x6210;beanName<pre><code>String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);
// &#x521B;&#x5EFA;TransactionInterceptor&#x7684;bean
RootBeanDefinition interceptorDef = new RootBeanDefinition(TransactionInterceptor.class);
interceptorDef.setSource(eleSource);
interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
registerTransactionManager(element, interceptorDef);
interceptorDef.getPropertyValues().add(&quot;transactionAttributeSource&quot;, new RuntimeBeanReference(sourceName));
</code></pre></li>
<li><p>// &#x6CE8;&#x518C;bean&#xFF0C;&#x5E76;&#x4F7F;&#x7528;Spring&#x4E2D;&#x7684;&#x5B9A;&#x4E49;&#x89C4;&#x5219;&#x751F;&#x6210;beanName</p>
<pre><code>String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);

// Create the TransactionAttributeSourceAdvisor definition.
// &#x521B;&#x5EFA;TransactionAttributeSourceAdvisor&#x7684;bean
</code></pre></li>
<li>RootBeanDefinition advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);<pre><code>advisorDef.setSource(eleSource);
advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
</code></pre></li>
<li>// &#x5C06;sourceName&#x7684;bean&#x6CE8;&#x5165;advisorDef&#x7684;transactionAttributeSource<pre><code>advisorDef.getPropertyValues().add(&quot;transactionAttributeSource&quot;, new RuntimeBeanReference(sourceName));
</code></pre></li>
<li><p>// &#x5C06;interceptorName&#x7684;bean&#x6CE8;&#x5165;advisorDef&#x7684;adviceBeanName</p>
<pre><code>advisorDef.getPropertyValues().add(&quot;adviceBeanName&quot;, interceptorName);
if (element.hasAttribute(&quot;order&quot;)) {
   advisorDef.getPropertyValues().add(&quot;order&quot;, element.getAttribute(&quot;order&quot;));
}
parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);

CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), eleSource);
compositeDef.addNestedComponent(new BeanComponentDefinition(sourceDef, sourceName));
compositeDef.addNestedComponent(new BeanComponentDefinition(interceptorDef, interceptorName));
compositeDef.addNestedComponent(new BeanComponentDefinition(advisorDef, txAdvisorBeanName));
parserContext.registerComponent(compositeDef);
</code></pre><p> }
}</p>
</li>
<li>AopNamespaceUtils#registerAutoProxyCreatorIfNecessary</li>
</ul>
<pre><code>public static void registerAutoProxyCreatorIfNecessary(
      ParserContext parserContext, Element sourceElement) {
   BeanDefinition beanDefinition = AopConfigUtils.registerAutoProxyCreatorIfNecessary(
         parserContext.getRegistry(), parserContext.extractSource(sourceElement));
   useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
   registerComponentIfNecessary(beanDefinition, parserContext);
}
</code></pre><ul>
<li>AopConfigUtils#registerAutoProxyCreatorIfNecessary</li>
</ul>
<pre><code>public static BeanDefinition registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object source) {
   return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);
}
</code></pre><ul>
<li>&#x8FD9;&#x91CC;&#x6CE8;&#x518C;&#x4E86;InfrastructureAdvisorAutoProxyCreator&#xFF08;&#x57FA;&#x7840;&#x8BBE;&#x65BD;)&#x8FD9;&#x4E2A;&#x7C7B;&#x3002;</li>
<li></li>
<li><p>BeanFactoryTransactionAttributeSourceAdvisor&#xFF08;&#x7528;&#x4E8E;&#x5BF9;&#x4E8B;&#x52A1;&#x65B9;&#x6CD5;&#x8FDB;&#x884C;&#x589E;&#x5F3A;)</p>
</li>
<li><p>&#x5728;AOP&#x7684;BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans&#x4E2D;&#x83B7;&#x53D6;&#x4E86;&#x6240;&#x6709;&#x7C7B;&#x578B;&#x4E3A;Advisor&#x7684;bean&#xFF0C;&#x5305;&#x62EC;BeanFactoryTransactionAttributeSourceAdvisor&#x8FD9;&#x4E2A;&#x7C7B;&#xFF0C;&#x5E76;&#x968F;&#x7740;&#x5176;&#x4ED6;&#x7684;Advisor&#x4E00;&#x8D77;&#x5728;&#x540E;&#x7EED;&#x7684;&#x6B65;&#x9AA4;&#x4E2D;&#x88AB;&#x7EC7;&#x5165;&#x4EE3;&#x7406;&#x3002;</p>
</li>
</ul>
<pre><code>public class BeanFactoryTransactionAttributeSourceAdvisor extends AbstractBeanFactoryPointcutAdvisor {

   private TransactionAttributeSource transactionAttributeSource;

   private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() {
      @Override
      protected TransactionAttributeSource getTransactionAttributeSource() {
         return transactionAttributeSource;
      }
   };


   /**
    * Set the transaction attribute source which is used to find transaction
    * attributes. This should usually be identical to the source reference
    * set on the transaction interceptor itself.
    * @see TransactionInterceptor#setTransactionAttributeSource
    */
   public void setTransactionAttributeSource(TransactionAttributeSource transactionAttributeSource) {
      this.transactionAttributeSource = transactionAttributeSource;
   }

   /**
    * Set the {@link ClassFilter} to use for this pointcut.
    * Default is {@link ClassFilter#TRUE}.
    */
   public void setClassFilter(ClassFilter classFilter) {
      this.pointcut.setClassFilter(classFilter);
   }

   @Override
   public Pointcut getPointcut() {
      return this.pointcut;
   }

}
</code></pre><ul>
<li></li>
<li><p>&#x4E0E;IOC&#x7684;&#x8854;&#x63A5;</p>
</li>
<li>InfrastructureAdvisorAutoProxyCreator&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;AbstractAutoProxyCreator&#xFF0C;&#x4F1A;&#x5728;getBean&#x65F6;&#x8C03;&#x7528;&#x5176;postProcessAfterInstantiation&#x65B9;&#x6CD5;&#xFF0C;&#x8BE5;&#x65B9;&#x6CD5;&#x4F1A;&#x521B;&#x5EFA;&#x4E8B;&#x52A1;&#x4EE3;&#x7406;&#x3002;</li>
<li>InfrastructureAdvisorAutoProxyCreator#postProcessAfterInstantiation</li>
</ul>
<pre><code>public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException {
   Object cacheKey = getCacheKey(beanClass, beanName);

   if (beanName == null || !this.targetSourcedBeans.contains(beanName)) {
      if (this.advisedBeans.containsKey(cacheKey)) {
         return null;
      }
      if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
         this.advisedBeans.put(cacheKey, Boolean.FALSE);
         return null;
      }
   }

   // Create proxy here if we have a custom TargetSource.
   // Suppresses unnecessary default instantiation of the target bean:
   // The TargetSource will handle target instances in a custom fashion.
   if (beanName != null) {
      TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
      if (targetSource != null) {
         this.targetSourcedBeans.add(beanName);
         Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
         Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
         this.proxyTypes.put(cacheKey, proxy.getClass());
         return proxy;
      }
   }

   return null;
}
</code></pre><ul>
<li>getAdvicesAndAdvisorsForBean&#x4F1A;&#x5BFB;&#x627E;&#x6240;&#x6709;&#x5B9E;&#x73B0;Advisor&#x63A5;&#x53E3;&#x7684;&#x7C7B;&#x3002;</li>
<li>&#x6211;&#x4EEC;&#x4E4B;&#x524D;&#x6CE8;&#x518C;&#x4E86;BeanFactoryTransactionAttributeSourceAdvisor&#x8FD9;&#x4E2A;&#x7C7B;&#xFF0C;&#x8FD9;&#x4E2A;&#x7C7B;&#x5B9E;&#x73B0;&#x4E86;Advisor&#x63A5;&#x53E3;&#x3002;BeanFactoryTransactionAttributeSourceAdvisor&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;advisor&#xFF0C;&#x7528;&#x4E8E;&#x5BF9;&#x4E8B;&#x52A1;&#x65B9;&#x6CD5;&#x8FDB;&#x884C;&#x589E;&#x5F3A;&#x3002;&#x53EA;&#x8981;&#x7C7B;&#x6216;&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#x4E86;@Transactional&#x63A5;&#x53E3;&#xFF0C;&#x8BE5;Advisor&#x4E00;&#x5B9A;&#x4F1A;&#x88AB;&#x52A0;&#x5230;&#x62E6;&#x622A;&#x5668;&#x94FE;&#x4E2D;&#xFF0C;&#x5BF9;&#x539F;&#x65B9;&#x6CD5;&#x8FDB;&#x884C;&#x4E8B;&#x52A1;&#x589E;&#x5F3A;&#x3002;</li>
<li><p>&#x8FD4;&#x56DE;&#x7684;Advisor&#x7C7B;&#x578B;&#x662F;BeanFactoryTransactionAttributeSourceAdvisor&#xFF0C;&#x800C;&#x5176;beanName&#x662F;TransactionInterceptor&#x3002;</p>
</li>
<li><p>&#x4E4B;&#x540E;&#x8C03;&#x7528;&#x4E86;findAdvisorsThatCanApply &#x65B9;&#x6CD5;&#xFF0C;&#x53C8;&#x8C03;&#x7528;canApply&#x65B9;&#x6CD5;&#x3002;</p>
<ul>
<li>1) canApply&#xFF08;&#x5224;&#x65AD;bean&#x662F;&#x5426;&#x9700;&#x8981;&#x6DFB;&#x52A0;&#x4E8B;&#x52A1;&#x589E;&#x5F3A;)</li>
</ul>
</li>
<li>canApply(BeanFactoryTransactionAttributeSourceAdvisor,targetClass)</li>
<li>&#x5173;&#x952E;&#x5728;&#x4E8E;&#x662F;&#x5426;&#x4ECE;&#x6307;&#x5B9A;&#x7684;&#x7C7B;&#x6216;&#x7C7B;&#x4E2D;&#x7684;&#x65B9;&#x6CD5;&#x627E;&#x5230;&#x5BF9;&#x5E94;&#x7684;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;</li>
</ul>
<pre><code>public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) {
</code></pre><ul>
<li>// &#x5904;&#x7406;&#x5F15;&#x5165;&#x589E;&#x5F3A;
 if (advisor instanceof IntroductionAdvisor) {<pre><code>return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
</code></pre> }</li>
<li>// &#x5904;&#x7406;PointcutAdvisor&#xFF0C;&#x662F;&#x6307;&#x6709;&#x5207;&#x5165;&#x70B9;&#x7684;Advisor
 else if (advisor instanceof PointcutAdvisor) {<pre><code>PointcutAdvisor pca = (PointcutAdvisor) advisor;
return canApply(pca.getPointcut(), targetClass, hasIntroductions);
</code></pre> }
 else {</li>
<li><p>// &#x6CA1;&#x6709;&#x5207;&#x5165;&#x70B9;&#x7684;&#x59CB;&#x7EC8;&#x5339;&#x914D;</p>
<pre><code>// It doesn&apos;t have a pointcut so we assume it applies.
return true;
</code></pre><p> }
}</p>
</li>
<li><p>pca.getPointcut()&#x5BF9;&#x4E8E;BeanFactoryTransactionAttributeSourceAdvisor&#x800C;&#x8A00;&#xFF0C;&#x662F;TransactionAttributeSourcePointcut&#x3002;</p>
</li>
</ul>
<pre><code>private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() {
   @Override
   protected TransactionAttributeSource getTransactionAttributeSource() {
      return transactionAttributeSource;
   }
};
</code></pre><ul>
<li>pc.getMethodMatcher()&#x5BF9;&#x4E8E;TransactionAttributeSourcePointcut&#x800C;&#x8A00;&#xFF0C;&#x5C31;&#x662F;this&#x3002;</li>
</ul>
<pre><code>public final MethodMatcher getMethodMatcher() {
   return this;
}
</code></pre><pre><code>public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) {
   Assert.notNull(pc, &quot;Pointcut must not be null&quot;);
   if (!pc.getClassFilter().matches(targetClass)) {
      return false;
   }
   MethodMatcher methodMatcher = pc.getMethodMatcher();
   if (methodMatcher == MethodMatcher.TRUE) {
      // No need to iterate the methods if we&apos;re matching any method anyway...
      return true;
   }

   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
   if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
   }
   // &#x83B7;&#x53D6;bean&#x76EE;&#x6807;&#x7C7B;&#x548C;&#x6240;&#x6709;&#x63A5;&#x53E3;&#xFF0C;&#x653E;&#x5230;&#x96C6;&#x5408;&#x4E2D;
   Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));
   classes.add(targetClass);
</code></pre><ul>
<li>// &#x904D;&#x5386;&#x96C6;&#x5408;&#xFF0C;&#x83B7;&#x53D6;&#x6BCF;&#x4E2A;&#x7C7B;/&#x63A5;&#x53E3;&#x7684;&#x6240;&#x6709;&#x65B9;&#x6CD5;&#xFF0C;&#x5E76;&#x5BF9;&#x65B9;&#x6CD5;&#x8FDB;&#x884C;&#x9010;&#x4E2A;&#x5339;&#x914D;
 for (Class&lt;?&gt; clazz : classes) {<pre><code>Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
for (Method method : methods) {
   if ((introductionAwareMethodMatcher != null &amp;&amp;
         introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||
</code></pre></li>
<li><p>// &#x5B9E;&#x9645;&#x7684;&#x5339;&#x914D;&#x65B9;&#x6CD5;</p>
<pre><code> methodMatcher.matches(method, targetClass)) {
</code></pre><p>  return true;
}
}
}
return false;
}</p>
</li>
<li><p>methodMatcher.matches(method, targetClass)&#x4F1A;&#x4F7F;&#x7528;</p>
</li>
<li>TransactionAttributeSourcePointcut&#x7C7B;&#x7684;matches&#x65B9;&#x6CD5;&#x3002;<ul>
<li>1.1) matches&#xFF08;&#x5339;&#x914D;&#x65B9;&#x6CD5;)</li>
</ul>
</li>
<li>&#x8FD9;&#x91CC;&#x7684;tas&#x5C31;&#x662F;TransactionAttributeSource&#x3002;</li>
<li>&#x5982;&#x679C;&#x8BE5;bean&#x7684;&#x8BE5;&#x65B9;&#x6CD5;&#x4E2D;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;&#xFF0C;&#x90A3;&#x4E48;&#x8BE5;&#x7C7B;/&#x65B9;&#x6CD5;&#x9700;&#x8981;&#x7EE7;&#x7EED;&#x4E8B;&#x52A1;&#x589E;&#x5F3A;&#x3002;</li>
</ul>
<pre><code>public boolean matches(Method method, Class&lt;?&gt; targetClass) {
   if (TransactionalProxy.class.isAssignableFrom(targetClass)) {
      return false;
   }
   TransactionAttributeSource tas = getTransactionAttributeSource();
   return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);
}
</code></pre><pre><code>- 1.1.1) AnnotationTransactionAttributeSource#getTransactionAttribute&#xFF08;&#x83B7;&#x53D6;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;&#xFF0C;&#x5C01;&#x88C5;&#x4E86;@Transactional&#x4E2D;&#x7684;&#x914D;&#x7F6E;&#x4FE1;&#x606F;)
</code></pre><ul>
<li>&#x5148;&#x5C1D;&#x8BD5;&#x4ECE;&#x7F13;&#x5B58;&#x52A0;&#x8F7D;&#xFF0C;&#x5982;&#x679C;&#x5BF9;&#x5E94;&#x4FE1;&#x606F;&#x6CA1;&#x6709;&#x88AB;&#x7F13;&#x5B58;&#x7684;&#x8BDD;&#xFF0C;&#x5DE5;&#x4F5C;&#x53C8;&#x59D4;&#x6258;&#x7ED9;&#x4E86;computeTransactionAttribute&#x65B9;&#x6CD5;&#x3002;</li>
</ul>
<pre><code>public TransactionAttribute getTransactionAttribute(Method method, Class&lt;?&gt; targetClass) {
   if (method.getDeclaringClass() == Object.class) {
      return null;
   }

   // First, see if we have a cached value.
   Object cacheKey = getCacheKey(method, targetClass);
   Object cached = this.attributeCache.get(cacheKey);
   if (cached != null) {
      // Value will either be canonical value indicating there is no transaction attribute,
      // or an actual transaction attribute.
      if (cached == NULL_TRANSACTION_ATTRIBUTE) {
         return null;
      }
      else {
         return (TransactionAttribute) cached;
      }
   }
   else {
      // We need to work it out.
      TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);
      // Put it in the cache.
      if (txAttr == null) {
         this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
      }
      else {
         String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);
         if (txAttr instanceof DefaultTransactionAttribute) {
            ((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);
         }
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Adding transactional method &apos;&quot; + methodIdentification + &quot;&apos; with attribute: &quot; + txAttr);
         }
         this.attributeCache.put(cacheKey, txAttr);
      }
      return txAttr;
   }
}
</code></pre><pre><code>- 1.1.1.1) computeTransactionAttribute&#xFF08;&#x63D0;&#x53D6;&#x4E8B;&#x52A1;&#x6CE8;&#x89E3;)
</code></pre><ul>
<li>&#x903B;&#x8F91;&#xFF1A;&#x5982;&#x679C;&#x65B9;&#x6CD5;&#x4E2D;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;&#xFF0C;&#x5219;&#x4F7F;&#x7528;&#x65B9;&#x6CD5;&#x4E0A;&#x7684;&#x5C5E;&#x6027;&#xFF0C;&#x5426;&#x5219;&#x4F7F;&#x7528;&#x65B9;&#x6CD5;&#x6240;&#x5728;&#x7684;&#x7C7B;&#x4E0A;&#x7684;&#x5C5E;&#x6027;&#x3002;&#x5982;&#x679C;&#x65B9;&#x6CD5;&#x6240;&#x5728;&#x7C7B;&#x7684;&#x5C5E;&#x6027;&#x4E0A;&#x8FD8;&#x662F;&#x6CA1;&#x6709;&#x641C;&#x5BFB;&#x5230;&#x5BF9;&#x5E94;&#x7684;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;&#xFF0C;&#x90A3;&#x4E48;&#x518D;&#x641C;&#x5BFB;&#x63A5;&#x53E3;&#x4E2D;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x518D;&#x6CA1;&#x6709;&#x7684;&#x8BDD;&#xFF0C;&#x6700;&#x540E;&#x5C1D;&#x8BD5;&#x641C;&#x5BFB;&#x63A5;&#x53E3;&#x7684;&#x7C7B;&#x4E0A;&#x9762;&#x7684;&#x58F0;&#x660E;&#x3002;</li>
</ul>
<pre><code>protected TransactionAttribute computeTransactionAttribute(Method method, Class&lt;?&gt; targetClass) {
   // Don&apos;t allow no-public methods as required.
   if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {
      return null;
   }

   // Ignore CGLIB subclasses - introspect the actual user class.
   Class&lt;?&gt; userClass = ClassUtils.getUserClass(targetClass);
   // The method may be on an interface, but we need attributes from the target class.
   // If the target class is null, the method will be unchanged.
</code></pre><ul>
<li>// method &#x4EE3;&#x8868;&#x63A5;&#x53E3;&#x4E2D;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;specificMethod&#x4EE3;&#x8868;&#x5B9E;&#x73B0;&#x7C7B;&#x4E2D;&#x7684;&#x65B9;&#x6CD5;
 Method specificMethod = ClassUtils.getMostSpecificMethod(method, userClass);
 // If we are dealing with method with generic parameters, find the original method.
 specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
 // &#x67E5;&#x770B;&#x65B9;&#x6CD5;&#x4E2D;&#x662F;&#x5426;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#x58F0;&#x660E;
 // First try is the method in the target class.
 TransactionAttribute txAttr = findTransactionAttribute(specificMethod);
 if (txAttr != null) {<pre><code>return txAttr;
</code></pre> }
 // &#x67E5;&#x770B;&#x65B9;&#x6CD5;&#x6240;&#x5728;&#x7C7B;&#x4E2D;&#x662F;&#x5426;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#x58F0;&#x660E;
 // Second try is the transaction attribute on the target class.
 txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());
 if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {<pre><code>return txAttr;
</code></pre> }
 // &#x5982;&#x679C;&#x5B58;&#x5728;&#x63A5;&#x53E3;&#xFF0C;&#x5219;&#x5230;&#x63A5;&#x53E3;&#x4E2D;&#x5BFB;&#x627E;
 if (specificMethod != method) {<pre><code>// Fallback is to look at the original method.
</code></pre></li>
<li>// &#x67E5;&#x770B;&#x63A5;&#x53E3;&#x65B9;&#x6CD5;<pre><code>txAttr = findTransactionAttribute(method);
if (txAttr != null) {
   return txAttr;
}
// Last fallback is the class of the original method.
</code></pre></li>
<li><p>// &#x5230;&#x63A5;&#x53E3;&#x4E2D;&#x7684;&#x7C7B;&#x4E2D;&#x53BB;&#x5BFB;&#x627E;</p>
<pre><code>txAttr = findTransactionAttribute(method.getDeclaringClass());
if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {
   return txAttr;
}
</code></pre><p> }</p>
<p> return null;
}</p>
</li>
<li><p>protected TransactionAttribute findTransactionAttribute(Method method) {
 return determineTransactionAttribute(method);
}</p>
</li>
<li><p>protected TransactionAttribute determineTransactionAttribute(AnnotatedElement ae) {
 if (ae.getAnnotations().length &gt; 0) {</p>
<pre><code>for (TransactionAnnotationParser annotationParser : this.annotationParsers) {
   TransactionAttribute attr = annotationParser.parseTransactionAnnotation(ae);
   if (attr != null) {
      return attr;
   }
}
</code></pre><p> }
 return null;
}</p>
<ul>
<li>1.1.1.1.1) TransactionAnnotationParser#parseTransactionAnnotation&#xFF08;&#x89E3;&#x6790;&#x6CE8;&#x89E3;)</li>
</ul>
</li>
<li>&#x4EE5;SpringTransactionAnnotationParser&#x4E3A;&#x4F8B;&#xFF1A;</li>
</ul>
<pre><code>public TransactionAttribute parseTransactionAnnotation(AnnotatedElement ae) {
</code></pre><ul>
<li><p>//&#x5BFB;&#x627E;@Transactional&#x6CE8;&#x89E3;&#xFF0C;&#x6709;&#x5219;&#x89E3;&#x6790;&#x8BE5;&#x6CE8;&#x89E3;
 AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ae, Transactional.class);
 if (attributes != null) {</p>
<pre><code>return parseTransactionAnnotation(attributes);
</code></pre><p> }
 else {</p>
<pre><code>return null;
</code></pre><p> }
}</p>
</li>
<li><p>&#x89E3;&#x6790;@Transactional&#x4E2D;&#x7684;&#x5404;&#x4E2A;&#x5C5E;&#x6027;&#xFF0C;&#x5E76;&#x5C01;&#x88C5;&#x5230;TransactionAttribute&#x4E2D;&#x8FD4;&#x56DE;&#x3002;</p>
</li>
<li>protected TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) {
 RuleBasedTransactionAttribute rbta = new RuleBasedTransactionAttribute();
 Propagation propagation = attributes.getEnum(&quot;propagation&quot;);
 rbta.setPropagationBehavior(propagation.value());
 Isolation isolation = attributes.getEnum(&quot;isolation&quot;);
 rbta.setIsolationLevel(isolation.value());
 rbta.setTimeout(attributes.getNumber(&quot;timeout&quot;).intValue());
 rbta.setReadOnly(attributes.getBoolean(&quot;readOnly&quot;));
 rbta.setQualifier(attributes.getString(&quot;value&quot;));
 ArrayList<rollbackruleattribute> rollBackRules = new ArrayList<rollbackruleattribute>();
 Class&lt;?&gt;[] rbf = attributes.getClassArray(&quot;rollbackFor&quot;);
 for (Class&lt;?&gt; rbRule : rbf) {<pre><code>RollbackRuleAttribute rule = new RollbackRuleAttribute(rbRule);
rollBackRules.add(rule);
</code></pre> }
 String[] rbfc = attributes.getStringArray(&quot;rollbackForClassName&quot;);
 for (String rbRule : rbfc) {<pre><code>RollbackRuleAttribute rule = new RollbackRuleAttribute(rbRule);
rollBackRules.add(rule);
</code></pre> }
 Class&lt;?&gt;[] nrbf = attributes.getClassArray(&quot;noRollbackFor&quot;);
 for (Class&lt;?&gt; rbRule : nrbf) {<pre><code>NoRollbackRuleAttribute rule = new NoRollbackRuleAttribute(rbRule);
rollBackRules.add(rule);
</code></pre> }
 String[] nrbfc = attributes.getStringArray(&quot;noRollbackForClassName&quot;);
 for (String rbRule : nrbfc) {<pre><code>NoRollbackRuleAttribute rule = new NoRollbackRuleAttribute(rbRule);
rollBackRules.add(rule);
</code></pre> }
 rbta.getRollbackRules().addAll(rollBackRules);
 return rbta;
}</rollbackruleattribute></rollbackruleattribute></li>
<li></li>
<li><p>&#x521B;&#x5EFA;&#x4E8B;&#x52A1;&#x4EE3;&#x7406;</p>
</li>
<li>&#x91CD;&#x8981;&#x7C7B;/&#x63A5;&#x53E3;&#x4ECB;&#x7ECD;</li>
<li>PlatformTransactionManager</li>
</ul>
<pre><code>public interface PlatformTransactionManager {
   TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
   void commit(TransactionStatus status) throws TransactionException;
   void rollback(TransactionStatus status) throws TransactionException;

}
</code></pre><ul>
<li>getTransaction()&#xFF1A;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x5DF2;&#x7ECF;&#x6FC0;&#x6D3B;&#x7684;&#x4E8B;&#x52A1;&#x6216;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x4E8B;&#x52A1;&#xFF08;&#x6839;&#x636E;&#x7ED9;&#x5B9A;&#x7684;TransactionDefinition&#x7C7B;&#x578B;&#x53C2;&#x6570;&#x5B9A;&#x4E49;&#x7684;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;)&#xFF0C;&#x8FD4;&#x56DE;&#x7684;&#x662F;TransactionStatus&#x5BF9;&#x8C61;&#x4EE3;&#x8868;&#x4E86;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x7684;&#x72B6;&#x6001;&#xFF0C;&#x5176;&#x4E2D;&#x8BE5;&#x65B9;&#x6CD5;&#x629B;&#x51FA;TransactionException&#xFF08;&#x672A;&#x68C0;&#x67E5;&#x5F02;&#x5E38;)&#x8868;&#x793A;&#x4E8B;&#x52A1;&#x7531;&#x4E8E;&#x67D0;&#x79CD;&#x539F;&#x56E0;&#x5931;&#x8D25;&#x3002;</li>
<li>commit()&#xFF1A;&#x7528;&#x4E8E;&#x63D0;&#x4EA4;TransactionStatus&#x53C2;&#x6570;&#x4EE3;&#x8868;&#x7684;&#x4E8B;&#x52A1;</li>
<li><p>rollback()&#xFF1A;&#x7528;&#x4E8E;&#x56DE;&#x6EDA;TransactionStatus&#x53C2;&#x6570;&#x4EE3;&#x8868;&#x7684;&#x4E8B;&#x52A1;</p>
</li>
<li></li>
<li><p>TransactionSynchronizationManager&#xFF08;&#x6301;&#x6709;&#x4E00;&#x7CFB;&#x5217;&#x4E8B;&#x52A1;&#x76F8;&#x5173;&#x7684;ThreadLocal&#x5BF9;&#x8C61;)</p>
</li>
</ul>
<pre><code>public abstract class TransactionSynchronizationManager {

   private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =
         new NamedThreadLocal&lt;Map&lt;Object, Object&gt;&gt;(&quot;Transactional resources&quot;);

   private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =
         new NamedThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt;(&quot;Transaction synchronizations&quot;);

   private static final ThreadLocal&lt;String&gt; currentTransactionName =
         new NamedThreadLocal&lt;String&gt;(&quot;Current transaction name&quot;);

   private static final ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =
         new NamedThreadLocal&lt;Boolean&gt;(&quot;Current transaction read-only status&quot;);

   private static final ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =
         new NamedThreadLocal&lt;Integer&gt;(&quot;Current transaction isolation level&quot;);

   private static final ThreadLocal&lt;Boolean&gt; actualTransactionActive =
         new NamedThreadLocal&lt;Boolean&gt;(&quot;Actual transaction active&quot;);
</code></pre><ul>
<li>}</li>
</ul>
<ul>
<li>getResource&#xFF08;&#x83B7;&#x53D6;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7ED1;&#x5B9A;&#x7684;&#x8FDE;&#x63A5;)</li>
</ul>
<pre><code>public static Object getResource(Object key) {
   Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);
   Object value = doGetResource(actualKey);
   if (value != null &amp;&amp; logger.isTraceEnabled()) {
      logger.trace(&quot;Retrieved value [&quot; + value + &quot;] for key [&quot; + actualKey + &quot;] bound to thread [&quot; +
            Thread.currentThread().getName() + &quot;]&quot;);
   }
   return value;
}
</code></pre><pre><code>private static Object doGetResource(Object actualKey) {
   Map&lt;Object, Object&gt; map = resources.get();
   if (map == null) {
      return null;
   }
   Object value = map.get(actualKey);
   // Transparently remove ResourceHolder that was marked as void...
   if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) {
      map.remove(actualKey);
      // Remove entire ThreadLocal if empty...
      if (map.isEmpty()) {
         resources.remove();
      }
      value = null;
   }
   return value;
}
</code></pre><ul>
<li>bindResouce&#xFF08;&#x5C06;&#x65B0;&#x8FDE;&#x63A5;&#x7ED1;&#x5B9A;&#x5230;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;)</li>
</ul>
<pre><code>public static void bindResource(Object key, Object value) throws IllegalStateException {
   Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);
   Assert.notNull(value, &quot;Value must not be null&quot;);
   Map&lt;Object, Object&gt; map = resources.get();
   // set ThreadLocal Map if none found
   if (map == null) {
      map = new HashMap&lt;Object, Object&gt;();
      resources.set(map);
   }
   Object oldValue = map.put(actualKey, value);
   // Transparently suppress a ResourceHolder that was marked as void...
   if (oldValue instanceof ResourceHolder &amp;&amp; ((ResourceHolder) oldValue).isVoid()) {
      oldValue = null;
   }
   if (oldValue != null) {
      throw new IllegalStateException(&quot;Already value [&quot; + oldValue + &quot;] for key [&quot; +
            actualKey + &quot;] bound to thread [&quot; + Thread.currentThread().getName() + &quot;]&quot;);
   }
   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Bound value [&quot; + value + &quot;] for key [&quot; + actualKey + &quot;] to thread [&quot; +
            Thread.currentThread().getName() + &quot;]&quot;);
   }
}
</code></pre><ul>
<li>unbindResource&#xFF08;&#x91CA;&#x653E;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7ED1;&#x5B9A;&#x7684;&#x8FDE;&#x63A5;)</li>
</ul>
<pre><code>public static Object unbindResource(Object key) throws IllegalStateException {
   Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);
   Object value = doUnbindResource(actualKey);
   if (value == null) {
      throw new IllegalStateException(
            &quot;No value for key [&quot; + actualKey + &quot;] bound to thread [&quot; + Thread.currentThread().getName() + &quot;]&quot;);
   }
   return value;
}
</code></pre><ul>
<li>setActualTransactionActive&#xFF08;&#x8BBE;&#x7F6E;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x662F;&#x5426;&#x5B58;&#x5728;&#x4E8B;&#x52A1;)</li>
</ul>
<pre><code>public static void setActualTransactionActive(boolean active) {
   actualTransactionActive.set(active ? Boolean.TRUE : null);
}
</code></pre><ul>
<li>setCurrentTransactionIsolationLevel&#xFF08;&#x8BBE;&#x7F6E;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5BF9;&#x5E94;&#x4E8B;&#x52A1;&#x7684;&#x9694;&#x79BB;&#x7EA7;&#x522B;)</li>
</ul>
<pre><code>public static void setCurrentTransactionIsolationLevel(Integer isolationLevel) {
   currentTransactionIsolationLevel.set(isolationLevel);
}
</code></pre><ul>
<li>isSynchronizationActive&#xFF08;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5BF9;&#x5E94;&#x7684;&#x4E8B;&#x52A1;synchronization&#x4E0D;&#x4E3A;&#x7A7A;)</li>
</ul>
<pre><code>public static boolean isSynchronizationActive() {
   return (synchronizations.get() != null);
}
</code></pre><ul>
<li>initSynchronization&#xFF08;&#x521D;&#x59CB;&#x5316;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7684;synchronization)</li>
</ul>
<pre><code>public static void initSynchronization() throws IllegalStateException {
   if (isSynchronizationActive()) {
      throw new IllegalStateException(&quot;Cannot activate transaction synchronization - already active&quot;);
   }
   logger.trace(&quot;Initializing transaction synchronization&quot;);
   synchronizations.set(new LinkedHashSet&lt;TransactionSynchronization&gt;());
}
</code></pre><ul>
<li>clearSynchronization&#xFF08;&#x6E05;&#x7A7A;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7684;synchronization)</li>
</ul>
<pre><code>public static void clearSynchronization() throws IllegalStateException {
   if (!isSynchronizationActive()) {
      throw new IllegalStateException(&quot;Cannot deactivate transaction synchronization - not active&quot;);
   }
   logger.trace(&quot;Clearing transaction synchronization&quot;);
   synchronizations.remove();
}
</code></pre><ul>
<li></li>
<li><p>TransactionSynchronization&#xFF08;&#x81EA;&#x5B9A;&#x4E49;&#x89E6;&#x53D1;&#x5668;)</p>
</li>
<li>TransactionStatus&#xFF08;&#x4E8B;&#x52A1;&#x72B6;&#x6001;)</li>
</ul>
<pre><code>public interface TransactionStatus extends SavepointManager, Flushable {

   boolean isNewTransaction();

   boolean hasSavepoint();

   void setRollbackOnly();

   boolean isRollbackOnly();

   @Override
   void flush();
   boolean isCompleted();

}
</code></pre><ul>
<li>DefaultTransactionStatus&#x662F;&#x5176;&#x5B9E;&#x73B0;&#x7C7B;</li>
<li>isNewTransaction&#xFF08;&#x662F;&#x5426;&#x662F;&#x65B0;&#x4E8B;&#x52A1;)</li>
</ul>
<pre><code>public boolean isNewTransaction() {
   return (hasTransaction() &amp;&amp; this.newTransaction);
}
</code></pre><ul>
<li>hasTransaction&#xFF08;&#x662F;&#x5426;&#x6709;&#x4E8B;&#x52A1;)</li>
</ul>
<pre><code>public boolean hasTransaction() {
   return (this.transaction != null);
}
</code></pre><ul>
<li>isReadOnly&#xFF08;&#x662F;&#x5426;&#x662F;&#x53EA;&#x8BFB;&#x4E8B;&#x52A1;)</li>
</ul>
<pre><code>public boolean isReadOnly() {
   return this.readOnly;
}
</code></pre><ul>
<li>isGlobalRollbackOnly&#xFF08;&#x662F;&#x5426;&#x662F;rollback-only)</li>
</ul>
<pre><code>public boolean isGlobalRollbackOnly() {
   return ((this.transaction instanceof SmartTransactionObject) &amp;&amp;
         ((SmartTransactionObject) this.transaction).isRollbackOnly());
}
</code></pre><ul>
<li></li>
<li><p>&#x4E0E;AOP&#x7684;&#x8854;&#x63A5;</p>
</li>
<li>ReflectiveMethodInvocation#proceed&#xFF08;&#x6267;&#x884C;&#x62E6;&#x622A;&#x5668;&#x94FE;&#x7684;&#x65B9;&#x6CD5;)</li>
<li>&#x5176;&#x4E2D;&#x8C03;&#x7528;&#x4E86;MethodInterceptor.invoke()&#x62E6;&#x622A;&#x5668;&#x65B9;&#x6CD5;&#x3002;</li>
<li>&#x5BF9;&#x4E8E;&#x6807;&#x8BB0;&#x4E86;@Transactional&#x7684;&#x65B9;&#x6CD5;&#x800C;&#x8A00;&#xFF0C;&#x4F1A;&#x88AB;&#x4EE3;&#x7406;&#xFF0C;&#x589E;&#x5F3A;&#x4E8B;&#x52A1;&#x529F;&#x80FD;&#x3002;</li>
<li>&#x8FD9;&#x4E9B;&#x65B9;&#x6CD5;&#x7684;Advisor&#x589E;&#x5F3A;&#x4E2D;&#x5305;&#x62EC;&#x4E86;TransactionInterceptor</li>
<li>&#xFF08;BeanFactoryTransactionAttributeSourceAdvisor&#x5BF9;&#x5E94;&#x7684;bean)&#x3002;</li>
<li>TransactionInterceptor&#x652F;&#x6491;&#x7740;&#x6574;&#x4E2A;&#x4E8B;&#x52A1;&#x529F;&#x80FD;&#x7684;&#x67B6;&#x6784;&#xFF0C;&#x5B83;&#x7EE7;&#x627F;&#x4E86;MethodInterceptor&#x3002;</li>
</ul>
<pre><code>public Object proceed() throws Throwable {
</code></pre><pre><code>- // &#x6267;&#x884C;&#x5B8C;&#x6240;&#x6709;&#x589E;&#x5F3A;&#x540E;&#xFF0C;&#x6267;&#x884C;&#x5207;&#x70B9;&#x65B9;&#x6CD5;(method.invoke())
</code></pre><p>   // We start with an index of -1 and increment early.
   if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
      return invokeJoinpoint();
   }
   // &#x83B7;&#x53D6;&#x4E0B;&#x4E00;&#x4E2A;&#x8981;&#x6267;&#x884C;&#x7684;&#x62E6;&#x622A;&#x5668;
   Object interceptorOrInterceptionAdvice =         this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
   if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {</p>
<ul>
<li>// &#x52A8;&#x6001;&#x5339;&#x914D;<pre><code>// Evaluate dynamic method matcher here: static part will already have
// been evaluated and found to match.
InterceptorAndDynamicMethodMatcher dm =
      (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
   return dm.interceptor.invoke(this);
}
else {
</code></pre></li>
<li>// &#x4E0D;&#x5339;&#x914D;&#x5219;&#x4E0D;&#x6267;&#x884C;&#x62E6;&#x622A;&#x5668;&#xFF0C;&#x9012;&#x5F52;&#x8C03;&#x7528;&#x81EA;&#x5DF1;&#xFF0C;&#x6267;&#x884C;&#x4E0B;&#x4E00;&#x4E2A;&#x62E6;&#x622A;&#x5668;<pre><code>   // Dynamic matching failed.
   // Skip this interceptor and invoke the next in the chain.
   return proceed();
}
</code></pre> }
 else {</li>
<li><p>// &#x82E5;&#x4E3A;&#x666E;&#x901A;&#x62E6;&#x622A;&#x5668;&#x5219;&#x76F4;&#x63A5;&#x8C03;&#x7528;&#x62E6;&#x622A;&#x5668;</p>
<pre><code>// It&apos;s an interceptor, so we just invoke it: The pointcut will have
// been evaluated statically before this object was constructed.
return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
</code></pre><p> }
}</p>
</li>
<li></li>
<li><p>TransactionInterceptor#invoke&#xFF08;&#x4E8B;&#x52A1;&#x589E;&#x5F3A;)</p>
</li>
</ul>
<pre><code>public Object invoke(final MethodInvocation invocation) throws Throwable {
   // Work out the target class: may be {@code null}.
   // The TransactionAttributeSource should be passed the target class
   // as well as the method, which may be from an interface.
   Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);

   // Adapt to TransactionAspectSupport&apos;s invokeWithinTransaction...
   return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {
      @Override
      public Object proceedWithInvocation() throws Throwable {
         return invocation.proceed();
      }
   });
}
</code></pre><ul>
<li>TransactionAspectSupport#invokeWithinTransaction</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x83B7;&#x53D6;&#x4E8B;&#x52A1;&#x5C5E;&#x6027; TransactionAttribute</li>
<li>2)&#x52A0;&#x8F7D;&#x914D;&#x7F6E;&#x4E2D;&#x7684;TransactionManager</li>
<li>3)&#x4E0D;&#x540C;&#x7684;&#x4E8B;&#x52A1;&#x5904;&#x7406;&#x65B9;&#x5F0F;&#x4F7F;&#x7528;&#x4E0D;&#x540C;&#x7684;&#x903B;&#x8F91;&#xFF0C;&#x5C31;&#x58F0;&#x660E;&#x5F0F;&#x4E8B;&#x52A1;&#x800C;&#x8A00;&#xFF0C;&#x4F1A;&#x83B7;&#x53D6;&#x65B9;&#x6CD5;&#x4FE1;&#x606F;&#x5E76;&#x521B;&#x5EFA;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;TransactionInfo&#xFF08;&#x6B64;&#x65F6;&#x5DF2;&#x7ECF;&#x521B;&#x5EFA;&#x4E86;&#x4E8B;&#x52A1;)</li>
</ul>
</li>
<li>&#x4E8B;&#x52A1;&#x4FE1;&#x606F;&#xFF08;TransactionInfo)&#x4E0E;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;&#xFF08;TransactionAttribute)&#x5E76;&#x4E0D;&#x76F8;&#x540C;&#x3002;</li>
<li>&#x524D;&#x8005;&#x5305;&#x542B;&#x4E86;&#x540E;&#x8005;&#xFF0C;&#x4E14;&#x5305;&#x542B;&#x4E86;&#x5176;&#x4ED6;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;&#xFF0C;&#x6BD4;&#x5982;PlatformTransactionManager&#x4EE5;&#x53CA;TransactionStatus&#x76F8;&#x5173;&#x4FE1;&#x606F;&#x3002;<ul>
<li>4)try:&#x6267;&#x884C;&#x539F;&#x59CB;&#x65B9;&#x6CD5;</li>
<li>5)catch:&#x5F02;&#x5E38;&#xFF0C;&#x56DE;&#x6EDA;&#x4E8B;&#x52A1;&#xFF0C;&#x518D;&#x6B21;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#xFF0C;7)&#x53CA;&#x4EE5;&#x540E;&#x7684;&#x4E0D;&#x4F1A;&#x6267;&#x884C;</li>
<li>6)finally:&#x6E05;&#x9664;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;</li>
<li>7)&#x63D0;&#x4EA4;&#x4E8B;&#x52A1;</li>
<li>8)&#x8FD4;&#x56DE;&#x539F;&#x59CB;&#x65B9;&#x6CD5;&#x7684;&#x8FD4;&#x56DE;&#x503C;</li>
</ul>
</li>
<li><p>protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation)</p>
<pre><code>throws Throwable {
</code></pre><p> // If the transaction attribute is null, the method is non-transactional.</p>
</li>
<li>// &#x83B7;&#x53D6;&#x5BF9;&#x5E94;&#x7684;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;
 final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</li>
<li>// &#x83B7;&#x53D6;BeanFactory&#x4E2D;&#x7684;transactionManager
 final PlatformTransactionManager tm = determineTransactionManager(txAttr);</li>
<li>// &#x83B7;&#x53D6;&#x65B9;&#x6CD5;&#x552F;&#x4E00;&#x6807;&#x8BC6;&#xFF08;&#x7C7B;&#x3001;&#x65B9;&#x6CD5;)
 final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);
 // &#x58F0;&#x660E;&#x5F0F;&#x4E8B;&#x52A1;&#x5904;&#x7406;
 if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {<pre><code>// Standard transaction demarcation with getTransaction and commit/rollback calls.
</code></pre></li>
<li>// &#x521B;&#x5EFA;TransactionInfo&#xFF08;&#x521B;&#x5EFA;&#x4E8B;&#x52A1;)<pre><code>TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
Object retVal = null;
try {
   // This is an around advice: Invoke the next interceptor in the chain.
   // This will normally result in a target object being invoked.
</code></pre></li>
<li>// &#x6267;&#x884C;&#x539F;&#x59CB;&#x65B9;&#x6CD5;<pre><code>   retVal = invocation.proceedWithInvocation();
}
catch (Throwable ex) {
   // target invocation exception
</code></pre></li>
<li>// &#x5F02;&#x5E38;&#x56DE;&#x6EDA;<pre><code>   completeTransactionAfterThrowing(txInfo, ex);
</code></pre></li>
<li>// &#x56DE;&#x6EDA;&#x540E;&#x53C8;&#x5C06;&#x5F02;&#x5E38;&#x629B;&#x4E86;&#x51FA;&#x6765;<pre><code>   throw ex;
}
finally {
</code></pre></li>
<li>// &#x6E05;&#x9664;&#x6D88;&#x606F;<pre><code>   cleanupTransactionInfo(txInfo);
}
</code></pre></li>
<li><p>// &#x63D0;&#x4EA4;&#x4E8B;&#x52A1;</p>
<pre><code>commitTransactionAfterReturning(txInfo);
return retVal;
</code></pre><p> }</p>
<p> else {</p>
</li>
</ul>
<pre><code>// &#x7F16;&#x7A0B;&#x5F0F;&#x4E8B;&#x52A1;&#xFF0C;&#x7565;&#x8FC7;
      // It&apos;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
      try {
         Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,
               new TransactionCallback&lt;Object&gt;() {
                  @Override
                  public Object doInTransaction(TransactionStatus status) {
                     TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
                     try {
                        return invocation.proceedWithInvocation();
                     }
                     catch (Throwable ex) {
                        if (txAttr.rollbackOn(ex)) {
                           // A RuntimeException: will lead to a rollback.
                           if (ex instanceof RuntimeException) {
                              throw (RuntimeException) ex;
                           }
                           else {
                              throw new ThrowableHolderException(ex);
                           }
                        }
                        else {
                           // A normal return value: will lead to a commit.
                           return new ThrowableHolder(ex);
                        }
                     }
                     finally {
                        cleanupTransactionInfo(txInfo);
                     }
                  }
               });

         // Check result: It might indicate a Throwable to rethrow.
         if (result instanceof ThrowableHolder) {
            throw ((ThrowableHolder) result).getThrowable();
         }
         else {
            return result;
         }
      }
      catch (ThrowableHolderException ex) {
         throw ex.getCause();
      }
   }
}
</code></pre><pre><code>- 1)createTransactionIfNecessary&#xFF08;&#x521B;&#x5EFA;&#x4E8B;&#x52A1;)
</code></pre><ul>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x4F7F;&#x7528;DelegatingTransactionAttribute&#x5C01;&#x88C5;&#x4F20;&#x5165;&#x7684;TransactionAttribute&#x3002;</li>
</ul>
</li>
<li>TransactionAttribute&#x5728;&#x8FD9;&#x91CC;&#x7684;&#x5B9E;&#x9645;&#x7C7B;&#x578B;&#x662F;RuleBasedTransactionAttribute&#xFF0C;&#x662F;&#x7531;&#x83B7;&#x53D6;&#x4E8B;&#x52A1;&#x5C5E;&#x6027;&#x65F6;&#x751F;&#x6210;&#xFF0C;&#x4E3B;&#x8981;&#x7528;&#x4E8E;&#x6570;&#x636E;&#x627F;&#x8F7D;&#xFF0C;&#x4F7F;&#x7528;DelegatingTransactionAttribute&#x627F;&#x8F7D;&#x53EF;&#x4EE5;&#x63D0;&#x4F9B;&#x66F4;&#x591A;&#x7684;&#x529F;&#x80FD;&#x3002;<ul>
<li>2)&#x83B7;&#x53D6;&#x4E8B;&#x52A1;</li>
<li>3)&#x6784;&#x5EFA;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;</li>
</ul>
</li>
<li><p>protected TransactionInfo createTransactionIfNecessary(</p>
<pre><code>PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) {
</code></pre><p> // If no name specified, apply method identification as transaction name.</p>
</li>
</ul>
<pre><code>// &#x5982;&#x679C;&#x6CA1;&#x6709;&#x6307;&#x5B9A;&#x540D;&#x79F0;&#xFF0C;&#x5219;&#x4F7F;&#x7528;&#x65B9;&#x6CD5;&#x552F;&#x4E00;&#x6807;&#x8BC6;&#xFF0C;&#x5E76;&#x4F7F;&#x7528;DelegatingTransactionAttribute&#x5C01;&#x88C5;TransactionAttribute
   if (txAttr != null &amp;&amp; txAttr.getName() == null) {
      txAttr = new DelegatingTransactionAttribute(txAttr) {
         @Override
         public String getName() {
            return joinpointIdentification;
         }
      };
   }

   TransactionStatus status = null;
   if (txAttr != null) {
      if (tm != null) {
</code></pre><ul>
<li>// &#x521B;&#x5EFA;&#x4E8B;&#x52A1;&#xFF0C;&#x8FD4;&#x56DE;TransactionStatus<pre><code>   status = tm.getTransaction(txAttr);
}
else {
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification +
            &quot;] because no transaction manager has been configured&quot;);
   }
}
</code></pre> }</li>
<li>// &#x6839;&#x636E;&#x6307;&#x5B9A;&#x7684;&#x5C5E;&#x6027;&#x4E0E;status&#x51C6;&#x5907;&#x4E00;&#x4E2A;TransactionInfo
 return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
}<ul>
<li>1.1)getTransaction&#xFF08;&#x5F00;&#x542F;&#x4E8B;&#x52A1;&#xFF0C;&#x8FD4;&#x56DE;TransactionStatus)</li>
</ul>
</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x83B7;&#x53D6;&#x4E8B;&#x52A1;&#xFF0C;&#x521B;&#x5EFA;&#x5BF9;&#x5E94;&#x7684;&#x4E8B;&#x52A1;&#x5B9E;&#x4F8B;</li>
<li>2)&#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#xFF0C;&#x90A3;&#x4E48;&#x6839;&#x636E;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#x8FDB;&#x884C;&#x76F8;&#x5E94;&#x5904;&#x7406;</li>
<li>3)&#x4E8B;&#x52A1;&#x8D85;&#x65F6;&#x7684;&#x9A8C;&#x8BC1;</li>
<li>4)&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#x7684;&#x9A8C;&#x8BC1;</li>
<li>5)&#x6784;&#x5EFA;DefaultTransactionStatus&#xFF0C;&#x521B;&#x5EFA;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x7684;&#x72B6;&#x6001;</li>
<li>6)&#x5B8C;&#x5584;transaction&#xFF0C;&#x5305;&#x62EC;&#x8BBE;&#x7F6E;ConnectionHolder&#x3001;&#x9694;&#x79BB;&#x7EA7;&#x522B;&#x3001;timeout&#xFF0C;&#x5982;&#x679C;&#x662F;&#x65B0;&#x8FDE;&#x63A5;&#xFF0C;&#x5219;&#x7ED1;&#x5B9A;&#x5230;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;</li>
<li>7)&#x5C06;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;&#x8BB0;&#x5F55;&#x5728;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E2D;&#x3002;</li>
</ul>
</li>
</ul>
<pre><code>public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {
   Object transaction = doGetTransaction();

   // Cache debug flag to avoid repeated checks.
   boolean debugEnabled = logger.isDebugEnabled();

   if (definition == null) {
      // Use defaults if no transaction definition given.
      definition = new DefaultTransactionDefinition();
   }
   // &#x5224;&#x65AD;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x662F;&#x5426;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#xFF0C;&#x4F9D;&#x636E;&#xFF08;DataSourceTransactionManager)&#x662F;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x8BB0;&#x5F55;&#x7684;&#x8FDE;&#x63A5;connectionHolder&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x4E14;connectionHolder&#x4E2D;&#x7684;transactionActive&#x5C5E;&#x6027;&#x4E3A;true
   if (isExistingTransaction(transaction)) {
      // Existing transaction found -&gt; check propagation behavior to find out how to behave.
</code></pre><ul>
<li>// &#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5DF2;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#xFF0C;&#x6839;&#x636E;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#x8FDB;&#x884C;&#x76F8;&#x5E94;&#x7684;&#x5904;&#x7406;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;<pre><code>return handleExistingTransaction(definition, transaction, debugEnabled);
</code></pre> }</li>
<li><p>// &#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E0D;&#x5B58;&#x5728;&#x4E8B;&#x52A1;
 // &#x4E8B;&#x52A1;&#x8D85;&#x65F6;&#x7684;&#x9A8C;&#x8BC1;
 // Check definition settings for new transaction.
 if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) {</p>
<pre><code>throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout());
</code></pre><p> }</p>
<p> // No existing transaction found -&gt; check propagation behavior to find out how to proceed.</p>
</li>
<li>// &#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#x7684;&#x9A8C;&#x8BC1;</li>
<li>// &#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E0D;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#xFF0C;&#x4F46;&#x662F;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#x5374;&#x88AB;&#x58F0;&#x660E;&#x4E3A;PROPAGATION_MANDATORY&#xFF08;&#x652F;&#x6301;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#xFF0C;&#x5982;&#x679C;&#x5F53;&#x524D;&#x6CA1;&#x6709;&#x4E8B;&#x52A1;&#xFF0C;&#x5C31;&#x629B;&#x51FA;&#x5F02;&#x5E38;)&#xFF0C;&#x5219;&#x629B;&#x51FA;&#x5F02;&#x5E38;
 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {<pre><code>throw new IllegalTransactionStateException(
      &quot;No existing transaction found for transaction marked with propagation &apos;mandatory&apos;&quot;);
</code></pre> }
 else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||<pre><code>   definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
   definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
</code></pre></li>
<li>// &#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x6CA1;&#x6709;&#x4E8B;&#x52A1;&#xFF0C;&#x4E14;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#x662F;&#x4EE5;&#x4E0A;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#xFF0C;&#x90A3;&#x4E48;&#x7A7A;&#x6302;&#x8D77;</li>
<li>// &#x8003;&#x8651;&#x5230;&#x5982;&#x679C;&#x6709;&#x6CE8;&#x518C;&#x7684;Synchronization&#x7684;&#x8BDD;&#xFF0C;&#x9700;&#x8981;&#x6682;&#x65F6;&#x5C06;&#x8FD9;&#x4E9B;&#x4E0E;&#x5C06;&#x8981;&#x5F00;&#x542F;&#x7684;&#x65B0;&#x4E8B;&#x52A1;&#x65E0;&#x5173;&#x7684;Synchronization&#x5148;&#x653E;&#x4E00;&#x8FB9;&#x3002;</li>
<li>// &#x5269;&#x4E0B;&#x7684;&#x5176;&#x4ED6;&#x60C5;&#x51B5;&#xFF0C;&#x5219;&#x8FD4;&#x56DE;&#x4E0D;&#x5305;&#x542B;&#x4EFB;&#x4F55;transaction object&#x7684;TransactionStatus&#x5E76;&#x8FD4;&#x56DE;</li>
<li>// &#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#x867D;&#x7136;&#x662F;&#x7A7A;&#x7684;&#x4E8B;&#x52A1;&#xFF0C;&#x4F46;&#x6709;&#x53EF;&#x80FD;&#x9700;&#x8981;&#x5904;&#x7406;&#x5728;&#x4E8B;&#x52A1;&#x8FC7;&#x7A0B;&#x4E2D;&#x76F8;&#x5173;&#x7684;Synchronization&#x3002;<pre><code>SuspendedResourcesHolder suspendedResources = suspend(null);
if (debugEnabled) {
   logger.debug(&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; + definition);
}
</code></pre></li>
<li><pre><code>try {
   boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
</code></pre></li>
<li><p>// &#x521B;&#x5EFA;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x7684;&#x72B6;&#x6001;</p>
<pre><code>   DefaultTransactionStatus status = newTransactionStatus(
         definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
</code></pre></li>
<li><p>// &#x5B8C;&#x5584;&#x4E8B;&#x52A1;&#xFF0C;&#x5305;&#x62EC;&#x8BBE;&#x7F6E;ConnectionHolder&#x3001;&#x9694;&#x79BB;&#x7EA7;&#x522B;&#x3001;timeout</p>
</li>
<li><p>// &#x53E6;&#x5916;&#x5982;&#x679C;&#x662F;&#x65B0;&#x8FDE;&#x63A5;&#xFF0C;&#x7ED1;&#x5B9A;&#x5230;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;</p>
<pre><code>   doBegin(transaction, definition);
</code></pre></li>
<li><p>// &#x5C06;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;&#x8BB0;&#x5F55;&#x5728;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E2D;</p>
<pre><code>   prepareSynchronization(status, definition);
   return status;
}
catch (RuntimeException ex) {
   resume(null, suspendedResources);
   throw ex;
}
catch (Error err) {
   resume(null, suspendedResources);
   throw err;
}
</code></pre><p> }
 else {</p>
<pre><code>// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.
if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) {
   logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +
         &quot;isolation level will effectively be ignored: &quot; + definition);
}
boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);
</code></pre><p> }
}</p>
<ul>
<li>1.1.1) doGetTransaction&#xFF08;&#x521B;&#x5EFA;&#x4E8B;&#x52A1;&#x5B9E;&#x4F8B;)</li>
</ul>
</li>
<li>DataSourceTransactionManager.doGetTransaction</li>
<li>protected Object doGetTransaction() {
 DataSourceTransactionObject txObject = new DataSourceTransactionObject();
 txObject.setSavepointAllowed(isNestedTransactionAllowed());</li>
<li>// &#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5DF2;&#x7ECF;&#x8BB0;&#x5F55;&#x6570;&#x636E;&#x5E93;&#x8FDE;&#x63A5;&#xFF0C;&#x5219;&#x4F7F;&#x7528;&#x539F;&#x6709;&#x8FDE;&#x63A5;
 ConnectionHolder conHolder =<pre><code>   (ConnectionHolder) TransactionSynchronizationManager.getResource(this.dataSource);
</code></pre></li>
<li>txObject.setConnectionHolder(conHolder, false);
 return txObject;
}<ul>
<li>1.1.1.1) DataSourceTransactionObject.setConnectionHolder</li>
</ul>
</li>
</ul>
<pre><code>public void setConnectionHolder(ConnectionHolder connectionHolder, boolean newConnectionHolder) {
   super.setConnectionHolder(connectionHolder);
   this.newConnectionHolder = newConnectionHolder;
}
</code></pre><pre><code>- 1.1.2) handleExistingTransaction &#xFF08;&#x5904;&#x7406;&#x5DF2;&#x5B58;&#x5728;&#x7684;&#x4E8B;&#x52A1;)
</code></pre><ul>
<li>&#x503C;&#x5F97;&#x6CE8;&#x610F;&#x7684;&#x6709;&#x4E24;&#x70B9;&#xFF1A;<ul>
<li>1)REQUIRES_NEW&#x8868;&#x793A;&#x5F53;&#x524D;&#x65B9;&#x6CD5;&#x5FC5;&#x987B;&#x5728;&#x5B83;&#x81EA;&#x5DF1;&#x7684;&#x4E8B;&#x52A1;&#x91CC;&#x8FD0;&#x884C;&#xFF0C;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x4E8B;&#x52A1;&#x5C06;&#x88AB;&#x542F;&#x52A8;&#x3002;&#x800C;&#x5982;&#x679C;&#x6709;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#x6B63;&#x5728;&#x8FD0;&#x884C;&#x7684;&#x8BDD;&#xFF0C;&#x5219;&#x5728;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x8FD0;&#x884C;&#x671F;&#x95F4;&#x88AB;&#x6302;&#x8D77;&#xFF08;suspend)&#x3002;</li>
<li>2)NESTED&#x8868;&#x793A;&#x5982;&#x679C;&#x5F53;&#x524D;&#x6B63;&#x5728;&#x6709;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#x5728;&#x8FD0;&#x884C;&#x4E2D;&#xFF0C;&#x5219;&#x8BE5;&#x65B9;&#x6CD5;&#x5E94;&#x8BE5;&#x8FD0;&#x884C;&#x5728;&#x4E00;&#x4E2A;&#x5D4C;&#x5957;&#x7684;&#x4E8B;&#x52A1;&#x4E2D;&#xFF0C;&#x88AB;&#x5D4C;&#x5957;&#x7684;&#x4E8B;&#x52A1;&#x53EF;&#x4EE5;&#x72EC;&#x7ACB;&#x4E8E;&#x5C01;&#x88C5;&#x4E8B;&#x52A1;&#x8FDB;&#x884C;&#x63D0;&#x4EA4;&#x6216;&#x8005;&#x56DE;&#x6EDA;&#x3002;&#x5982;&#x679C;&#x5C01;&#x88C5;&#x4E8B;&#x52A1;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x884C;&#x4E3A;&#x5C31;&#x50CF;REQUIRES_NEW&#x3002;</li>
</ul>
</li>
<li>Spring&#x4E3B;&#x8981;&#x6709;&#x4E24;&#x79CD;&#x5904;&#x7406;NESTED&#x7684;&#x65B9;&#x5F0F;&#xFF1A;</li>
<li>&#x9996;&#x9009;&#x8BBE;&#x7F6E;&#x4FDD;&#x5B58;&#x70B9;&#x7684;&#x65B9;&#x5F0F;&#x4F5C;&#x4E3A;&#x5F02;&#x5E38;&#x5904;&#x7406;&#x7684;&#x56DE;&#x6EDA;</li>
<li>JTA&#x65E0;&#x6CD5;&#x4F7F;&#x7528;&#x4FDD;&#x5B58;&#x70B9;&#xFF0C;&#x90A3;&#x4E48;&#x5904;&#x7406;&#x65B9;&#x5F0F;&#x548C;REQUIRES_NEW&#x76F8;&#x540C;&#xFF0C;&#x800C;&#x4E00;&#x65E6;&#x51FA;&#x73B0;&#x5F02;&#x5E38;&#xFF0C;&#x5219;&#x7531;Spring&#x7684;&#x4E8B;&#x52A1;&#x5F02;&#x5E38;&#x5904;&#x7406;&#x673A;&#x5236;&#x53BB;&#x5B8C;&#x6210;&#x540E;&#x7EED;&#x64CD;&#x4F5C;&#x3002;</li>
</ul>
<pre><code>private TransactionStatus handleExistingTransaction(
      TransactionDefinition definition, Object transaction, boolean debugEnabled)
      throws TransactionException {

   if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {
      throw new IllegalTransactionStateException(
            &quot;Existing transaction found for transaction marked with propagation &apos;never&apos;&quot;);
   }

   if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {
      if (debugEnabled) {
         logger.debug(&quot;Suspending current transaction&quot;);
      }
      Object suspendedResources = suspend(transaction);
      boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
      return prepareTransactionStatus(
            definition, null, false, newSynchronization, debugEnabled, suspendedResources);
   }

   if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {
      if (debugEnabled) {
         logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; +
               definition.getName() + &quot;]&quot;);
      }
      SuspendedResourcesHolder suspendedResources = suspend(transaction);
      try {
         boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
         DefaultTransactionStatus status = newTransactionStatus(
               definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
         doBegin(transaction, definition);
         prepareSynchronization(status, definition);
         return status;
      }
      catch (RuntimeException beginEx) {
         resumeAfterBeginException(transaction, suspendedResources, beginEx);
         throw beginEx;
      }
      catch (Error beginErr) {
         resumeAfterBeginException(transaction, suspendedResources, beginErr);
         throw beginErr;
      }
   }

   if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
      if (!isNestedTransactionAllowed()) {
         throw new NestedTransactionNotSupportedException(
               &quot;Transaction manager does not allow nested transactions by default - &quot; +
               &quot;specify &apos;nestedTransactionAllowed&apos; property with value &apos;true&apos;&quot;);
      }
      if (debugEnabled) {
         logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;);
      }
      if (useSavepointForNestedTransaction()) {
         // Create savepoint within existing Spring-managed transaction,
         // through the SavepointManager API implemented by TransactionStatus.
         // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.
         DefaultTransactionStatus status =
               prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);
         status.createAndHoldSavepoint();
         return status;
      }
      else {
         // Nested transaction through nested begin and commit/rollback calls.
         // Usually only for JTA: Spring synchronization might get activated here
         // in case of a pre-existing JTA transaction.
         boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
         DefaultTransactionStatus status = newTransactionStatus(
               definition, transaction, true, newSynchronization, debugEnabled, null);
         doBegin(transaction, definition);
         prepareSynchronization(status, definition);
         return status;
      }
   }
   // &#x5904;&#x7406;SUPPORTS&#x548C;REQUIRED
   // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.
   if (debugEnabled) {
      logger.debug(&quot;Participating in existing transaction&quot;);
   }
   if (isValidateExistingTransaction()) {
      if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {
         Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
         if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {
            Constants isoConstants = DefaultTransactionDefinition.constants;
            throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +
                  definition + &quot;] specifies isolation level which is incompatible with existing transaction: &quot; +
                  (currentIsolationLevel != null ?
                        isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :
                        &quot;(unknown)&quot;));
         }
      }
      if (!definition.isReadOnly()) {
         if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {
            throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +
                  definition + &quot;] is not marked as read-only but existing transaction is&quot;);
         }
      }
   }
   boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
   return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);
}
</code></pre><pre><code>- 1.1.3) suspend&#xFF08;null-&gt;doNothing)
</code></pre><ul>
<li>&#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E0D;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#xFF0C;&#x5E76;&#x4E14;&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#x662F;Required&#x3001;Required_New&#x3001;Nested&#xFF0C;&#x90A3;&#x4E48;&#x6267;&#x884C;suspend(null)&#x3002;</li>
<li><p>&#x8003;&#x8651;&#x5230;&#x5982;&#x679C;&#x6709;&#x6CE8;&#x518C;&#x7684;synchronization&#x7684;&#x8BDD;&#xFF0C;&#x9700;&#x8981;&#x6682;&#x65F6;&#x5C06;&#x8FD9;&#x4E9B;&#x4E0E;&#x5C06;&#x8981;&#x5F00;&#x542F;&#x7684;&#x65B0;&#x4E8B;&#x52A1;&#x65E0;&#x5173;&#x7684;synchronization&#x5148;&#x653E;&#x4E00;&#x8FB9;&#x3002;</p>
</li>
<li><p>&#x6B63;&#x5E38;&#x7684;suspend&#x662F;&#x8BB0;&#x5F55;&#x539F;&#x6709;&#x4E8B;&#x52A1;&#x7684;&#x72B6;&#x6001;&#xFF0C;&#x4EE5;&#x4FBF;&#x540E;&#x7EED;&#x64CD;&#x4F5C;&#x5BF9;&#x4E8B;&#x52A1;&#x7684;&#x6062;&#x590D;</p>
</li>
<li>&#xFF08;TransactionSynchronizationManager.unBindResource)</li>
<li>protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {
 if (TransactionSynchronizationManager.isSynchronizationActive()) {<pre><code>List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();
try {
   Object suspendedResources = null;
   if (transaction != null) {
      suspendedResources = doSuspend(transaction);
   }
   String name = TransactionSynchronizationManager.getCurrentTransactionName();
   TransactionSynchronizationManager.setCurrentTransactionName(null);
   boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
   TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);
   Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
   TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);
   boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();
   TransactionSynchronizationManager.setActualTransactionActive(false);
   return new SuspendedResourcesHolder(
         suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);
}
catch (RuntimeException ex) {
   // doSuspend failed - original transaction is still active...
   doResumeSynchronization(suspendedSynchronizations);
   throw ex;
}
catch (Error err) {
   // doSuspend failed - original transaction is still active...
   doResumeSynchronization(suspendedSynchronizations);
   throw err;
}
</code></pre> }
 else if (transaction != null) {<pre><code>// Transaction active but no synchronization active.
Object suspendedResources = doSuspend(transaction);
return new SuspendedResourcesHolder(suspendedResources);
</code></pre> }
 else {<pre><code>// Neither transaction nor synchronization active.
return null;
</code></pre> }
}</li>
<li><ul>
<li>1.1.3.1) doSuspendSynchronization</li>
</ul>
</li>
</ul>
<pre><code>private List&lt;TransactionSynchronization&gt; doSuspendSynchronization() {
   List&lt;TransactionSynchronization&gt; suspendedSynchronizations =
         TransactionSynchronizationManager.getSynchronizations();
   for (TransactionSynchronization synchronization : suspendedSynchronizations) {
      synchronization.suspend();
   }
</code></pre><ul>
<li>// &#x6E05;&#x7A7A;synchronization
 TransactionSynchronizationManager.clearSynchronization();
 return suspendedSynchronizations;
}</li>
<li><ul>
<li>1.1.4) newTransactionStatus &#xFF08;&#x521B;&#x5EFA;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x7684;&#x72B6;&#x6001;)</li>
</ul>
</li>
<li>boolean newSynchronization = (getTransactionSynchronization() != </li>
<li>SYNCHRONIZATION_NEVER);</li>
<li>DefaultTransactionStatus status = newTransactionStatus(definition, transaction, true, newSynchronization, debugEnabled, null);</li>
<li>&#x65B0;&#x4E8B;&#x52A1;&#x5219;&#x4F20;&#x5165;&#x7684;newTransaction&#x4E3A;true&#xFF0C;&#x5426;&#x5219;&#x4E3A;false</li>
<li><p>definition.isReadOnly()&#x8FD4;&#x56DE;&#x7684;&#x662F;@Transactional&#x4E2D;&#x7684;&#x5C5E;&#x6027;&#xFF0C;&#x9ED8;&#x8BA4;&#x4E3A;false&#x3002;</p>
</li>
<li><p>protected DefaultTransactionStatus newTransactionStatus(</p>
<pre><code>TransactionDefinition definition, Object transaction, boolean newTransaction,
boolean newSynchronization, boolean debug, Object suspendedResources) {
</code></pre><p> boolean actualNewSynchronization = newSynchronization &amp;&amp;</p>
<pre><code>   !TransactionSynchronizationManager.isSynchronizationActive();
</code></pre><p> return new DefaultTransactionStatus(</p>
<pre><code>   transaction, newTransaction, actualNewSynchronization,
   definition.isReadOnly(), debug, suspendedResources);
</code></pre><p>}</p>
</li>
<li><p>&#x7406;&#x89E3;newTransaction </p>
</li>
<li><p>newTransaction&#x6807;&#x8BC6;&#x8BE5;&#x5207;&#x9762;&#x65B9;&#x6CD5;&#x662F;&#x5426;&#x65B0;&#x5EFA;&#x4E86;&#x4E8B;&#x52A1;&#xFF0C;&#x540E;&#x7EED;&#x5207;&#x9762;&#x65B9;&#x6CD5;&#x6267;&#x884C;&#x5B8C;&#x6BD5;&#x65F6;&#xFF0C;&#x901A;&#x8FC7;&#x8BE5;&#x5B57;&#x6BB5;&#x5224;&#x65AD;&#x662F;&#x5426; &#x9700;&#x8981;&#x63D0;&#x4EA4;&#x4E8B;&#x52A1;&#x6216;&#x8005;&#x56DE;&#x6EDA;&#x4E8B;&#x52A1;&#x3002;</p>
</li>
<li><ul>
<li>1.1.5) doBegin&#xFF08;&#x5B8C;&#x5584;&#x4E8B;&#x52A1;&#x5B9E;&#x4F8B;)</li>
</ul>
</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x8FDE;&#x63A5;&#x3002;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E2D;&#x7684;connectionHolder&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#xFF0C;&#x5219;&#x6CA1;&#x6709;&#x5FC5;&#x8981;&#x518D;&#x6B21;&#x83B7;&#x53D6;&#xFF1B;&#x5BF9;&#x4E8E;&#x4E8B;&#x52A1;&#x540C;&#x6B65;&#x8BBE;&#x7F6E;&#x4E3A;true&#x7684;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#x8FDE;&#x63A5;</li>
<li>2)&#x8BBE;&#x7F6E;&#x9694;&#x79BB;&#x7EA7;&#x522B;&#x4EE5;&#x53CA;&#x53EA;&#x8BFB;&#x6807;&#x8BC6;</li>
<li>3)&#x66F4;&#x6539;&#x9ED8;&#x8BA4;&#x7684;&#x63D0;&#x4EA4;&#x8BBE;&#x7F6E;&#xFF0C;&#x5C06;&#x63D0;&#x4EA4;&#x64CD;&#x4F5C;&#x59D4;&#x6258;&#x7ED9;Spring&#x6765;&#x5904;&#x7406;</li>
<li>4)&#x8BBE;&#x7F6E;&#x6807;&#x5FD7;&#x4F4D;&#xFF0C;&#x6807;&#x8BC6;&#x5F53;&#x524D;&#x8FDE;&#x63A5;&#x5DF2;&#x7ECF;&#x88AB;&#x4E8B;&#x52A1;&#x6FC0;&#x6D3B;</li>
<li>5)&#x8BBE;&#x7F6E;&#x8D85;&#x65F6;&#x65F6;&#x95F4;</li>
<li>6)&#x5982;&#x679C;&#x662F;&#x65B0;&#x8FDE;&#x63A5;&#xFF0C;&#x5219;&#x5C06;connectionHolder&#x7ED1;&#x5B9A;&#x5230;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;</li>
</ul>
</li>
<li><p>protected void doBegin(Object transaction, TransactionDefinition definition) {
 DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
 Connection con = null;</p>
<p> try {</p>
<pre><code>if (txObject.getConnectionHolder() == null ||
      txObject.getConnectionHolder().isSynchronizedWithTransaction()) {
   Connection newCon = this.dataSource.getConnection();
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Acquired Connection [&quot; + newCon + &quot;] for JDBC transaction&quot;);
   }
</code></pre></li>
<li><p>// &#x8BBE;&#x7F6E;ConnectionHolder</p>
<pre><code>   txObject.setConnectionHolder(new ConnectionHolder(newCon), true);
}

txObject.getConnectionHolder().setSynchronizedWithTransaction(true);
con = txObject.getConnectionHolder().getConnection();
</code></pre></li>
<li><p>// &#x8BBE;&#x7F6E;&#x9694;&#x79BB;&#x7EA7;&#x522B;</p>
<pre><code>Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);
</code></pre></li>
<li><p>txObject.setPreviousIsolationLevel(previousIsolationLevel);</p>
<pre><code>// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,
// so we don&apos;t want to do it unnecessarily (for example if we&apos;ve explicitly
// configured the connection pool to set it already).
</code></pre></li>
<li><p>// &#x66F4;&#x6539;&#x81EA;&#x52A8;&#x63D0;&#x4EA4;&#x8BBE;&#x7F6E;&#xFF0C;&#x7531;Spring&#x63A7;&#x5236;&#x63D0;&#x4EA4;</p>
<pre><code>if (con.getAutoCommit()) {
   txObject.setMustRestoreAutoCommit(true);
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Switching JDBC Connection [&quot; + con + &quot;] to manual commit&quot;);
   }
   con.setAutoCommit(false);
}

prepareTransactionalConnection(con, definition);
</code></pre></li>
<li><p>// &#x8BBE;&#x7F6E;&#x5224;&#x65AD;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x662F;&#x5426;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#x7684;&#x4F9D;&#x636E;&#xFF0C;&#x5373;transactionActive</p>
<pre><code>txObject.getConnectionHolder().setTransactionActive(true);

int timeout = determineTimeout(definition);
if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {
</code></pre></li>
<li><p>//&#x8BBE;&#x7F6E;timeout&#x5C5E;&#x6027;</p>
<pre><code>   txObject.getConnectionHolder().setTimeoutInSeconds(timeout);
}

// Bind the connection holder to the thread.
</code></pre></li>
<li><p>// &#x5982;&#x679C;&#x662F;&#x65B0;&#x7684;&#x8FDE;&#x63A5;&#xFF0C;&#x5219;&#x5C06;&#x5F53;&#x524D;&#x83B7;&#x53D6;&#x5230;&#x7684;&#x8FDE;&#x63A5;&#x7ED1;&#x5B9A;&#x5230;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;</p>
<pre><code>if (txObject.isNewConnectionHolder()) {
   TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());
}
</code></pre><p> }</p>
<p> catch (Throwable ex) {</p>
<pre><code>if (txObject.isNewConnectionHolder()) {
   DataSourceUtils.releaseConnection(con, this.dataSource);
   txObject.setConnectionHolder(null, false);
}
throw new CannotCreateTransactionException(&quot;Could not open JDBC Connection for transaction&quot;, ex);
</code></pre><p> }
}</p>
<ul>
<li>1.1.6) prepareSynchronization&#xFF08;&#x8BB0;&#x5F55;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;&#x81F3;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;)</li>
</ul>
</li>
<li><p>protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {
 if (status.isNewSynchronization()) {</p>
<pre><code>TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());
TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(
      definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?
            definition.getIsolationLevel() : null);
TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());
TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());
TransactionSynchronizationManager.initSynchronization();
</code></pre><p> }
}</p>
<ul>
<li>1.2)  prepareTransactionInfo&#xFF08;&#x6784;&#x5EFA;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;)</li>
</ul>
</li>
<li>&#x5F53;&#x5DF2;&#x7ECF;&#x5EFA;&#x7ACB;&#x4E8B;&#x52A1;&#x8FDE;&#x63A5;&#x5E76;&#x5B8C;&#x6210;&#x4E86;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;&#x7684;&#x63D0;&#x53D6;&#x540E;&#xFF0C;&#x9700;&#x8981;&#x5C06;&#x6240;&#x6709;&#x7684;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;&#x7EDF;&#x4E00;&#x8BB0;&#x5F55;&#x5728;TransactionInfo&#x5B9E;&#x4F8B;&#x4E2D;&#xFF0C;&#x8FD9;&#x4E2A;&#x5B9E;&#x4F8B;&#x5305;&#x542B;&#x4E86;&#x76EE;&#x6807;&#x65B9;&#x6CD5;&#x5F00;&#x59CB;&#x524D;&#x7684;&#x6240;&#x6709;&#x72B6;&#x6001;&#x4FE1;&#x606F;&#x3002;&#x4E00;&#x65E6;&#x4E8B;&#x52A1;&#x6267;&#x884C;&#x5931;&#x8D25;&#xFF0C;Spring&#x4F1A;&#x901A;&#x8FC7;TransactionInfo&#x5B9E;&#x4F8B;&#x6765;&#x8FDB;&#x884C;&#x56DE;&#x6EDA;&#x7B49;&#x540E;&#x7EED;&#x5DE5;&#x4F5C;&#x3002;</li>
<li><p>protected TransactionInfo prepareTransactionInfo(PlatformTransactionManager tm,</p>
<pre><code>TransactionAttribute txAttr, String joinpointIdentification, TransactionStatus status) {
</code></pre><p> TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification);
 if (txAttr != null) {</p>
<pre><code>// We need a transaction for this method...
if (logger.isTraceEnabled()) {
   logger.trace(&quot;Getting transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);
}
// The transaction manager will flag an error if an incompatible tx already exists.
</code></pre></li>
<li><p>// &#x8BB0;&#x5F55;&#x4E8B;&#x52A1;&#x72B6;&#x6001;</p>
<pre><code>txInfo.newTransactionStatus(status);
</code></pre><p> }
 else {</p>
<pre><code>// The TransactionInfo.hasTransaction() method will return false. We created it only
// to preserve the integrity of the ThreadLocal stack maintained in this class.
if (logger.isTraceEnabled())
   logger.trace(&quot;Don&apos;t need to create transaction for [&quot; + joinpointIdentification +
         &quot;]: This method isn&apos;t transactional.&quot;);
</code></pre><p> }</p>
<p> // We always bind the TransactionInfo to the thread, even if we didn&apos;t create
 // a new transaction here. This guarantees that the TransactionInfo stack
 // will be managed correctly even if no transaction was created by this aspect.
 txInfo.bindToThread();
 return txInfo;
}</p>
<ul>
<li>2)completeTransactionAfterThrowing &#xFF08;&#x56DE;&#x6EDA;&#x4E8B;&#x52A1;)</li>
</ul>
</li>
<li>protected void completeTransactionAfterThrowing(TransactionInfo txInfo, Throwable ex) {</li>
<li>// &#x5F53;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x65F6;&#x9996;&#x5148;&#x5224;&#x65AD;&#x5F53;&#x524D;&#x662F;&#x5426;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#xFF0C;&#x8FD9;&#x662F;&#x57FA;&#x7840;&#x4F9D;&#x636E;
 if (txInfo != null &amp;&amp; txInfo.hasTransaction()) {<pre><code>if (logger.isTraceEnabled()) {
   logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() +
         &quot;] after exception: &quot; + ex);
}
</code></pre></li>
<li>// &#x5224;&#x65AD;&#x662F;&#x5426;&#x56DE;&#x6EDA; &#x9ED8;&#x8BA4;&#x7684;&#x4F9D;&#x636E;&#x662F; &#x629B;&#x51FA;&#x7684;&#x5F02;&#x5E38;&#x662F;&#x5426;&#x662F;RuntimeException&#x6216;&#x8005;&#x662F;Error&#x7684;&#x7C7B;&#x578B;<pre><code>if (txInfo.transactionAttribute.rollbackOn(ex)) {
   try {
     // &#x6839;&#x636E;TransactionStatus&#x4FE1;&#x606F;&#x8FDB;&#x884C;&#x56DE;&#x6EDA;&#x5904;&#x7406;
</code></pre><ul>
<li>txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
  }
  catch (TransactionSystemException ex2) {<pre><code> logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);
 ex2.initApplicationException(ex);
 throw ex2;
</code></pre>  }
  catch (RuntimeException ex2) {<pre><code> logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);
 throw ex2;
</code></pre>  }
  catch (Error err) {<pre><code> logger.error(&quot;Application exception overridden by rollback error&quot;, ex);
 throw err;
</code></pre>  }
}
else {</li>
<li>// &#x5982;&#x679C;&#x4E0D;&#x6EE1;&#x8DB3;&#x56DE;&#x6EDA;&#x6761;&#x4EF6;&#xFF0C;&#x5373;&#x4F7F;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x4E5F;&#x4F1A;&#x63D0;&#x4EA4;
   // We don&apos;t roll back on this exception.
   // Will still roll back if TransactionStatus.isRollbackOnly() is true.
   try {<pre><code>  txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
</code></pre>   }
   catch (TransactionSystemException ex2) {<pre><code>  logger.error(&quot;Application exception overridden by commit exception&quot;, ex);
  ex2.initApplicationException(ex);
  throw ex2;
</code></pre>   }
   catch (RuntimeException ex2) {<pre><code>  logger.error(&quot;Application exception overridden by commit exception&quot;, ex);
  throw ex2;
</code></pre>   }
   catch (Error err) {<pre><code>  logger.error(&quot;Application exception overridden by commit error&quot;, ex);
  throw err;
</code></pre>   }
}
}
}</li>
<li>2.1) TransactionAttribute.rollbackOn&#xFF08;&#x5224;&#x65AD;&#x662F;&#x5426;&#x9700;&#x8981;&#x56DE;&#x6EDA;)</li>
</ul>
</li>
<li>DefaultTransactionAttribute&#x7684;&#x5B9E;&#x73B0;&#x662F;</li>
</ul>
<pre><code>public boolean rollbackOn(Throwable ex) {
   return (ex instanceof RuntimeException || ex instanceof Error);
}
</code></pre><ul>
<li>RuleBasedTransactionAttribute&#x7684;&#x5B9E;&#x73B0;&#x662F;</li>
</ul>
<pre><code>public boolean rollbackOn(Throwable ex) {
   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Applying rules to determine whether transaction should rollback on &quot; + ex);
   }

   RollbackRuleAttribute winner = null;
   int deepest = Integer.MAX_VALUE;

   if (this.rollbackRules != null) {
      for (RollbackRuleAttribute rule : this.rollbackRules) {
         int depth = rule.getDepth(ex);
         if (depth &gt;= 0 &amp;&amp; depth &lt; deepest) {
            deepest = depth;
            winner = rule;
         }
      }
   }

   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Winning rollback rule is: &quot; + winner);
   }

   // User superclass behavior (rollback on unchecked) if no rule matches.
   if (winner == null) {
      logger.trace(&quot;No relevant rollback rule found: applying default rules&quot;);
      return super.rollbackOn(ex);
   }

   return !(winner instanceof NoRollbackRuleAttribute);
}
</code></pre><pre><code>- 2.2) rollback&#xFF08;&#x56DE;&#x6EDA;)
</code></pre><pre><code>public final void rollback(TransactionStatus status) throws TransactionException {
   if (status.isCompleted()) {
      throw new IllegalTransactionStateException(
            &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);
   }

   DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
   processRollback(defStatus);
}
</code></pre><ul>
<li>processRollback<ul>
<li>1)&#x9996;&#x5148;&#x662F;&#x81EA;&#x5B9A;&#x4E49;&#x89E6;&#x53D1;&#x5668;&#x7684;&#x8C03;&#x7528;&#xFF0C;&#x5305;&#x62EC;&#x5728;&#x56DE;&#x6EDA;&#x524D;&#x3001;&#x5B8C;&#x6210;&#x56DE;&#x6EDA;&#x540E;&#x7684;&#x8C03;&#x7528;&#xFF0C;&#x5F53;&#x7136;&#x5B8C;&#x6210;&#x56DE;&#x6EDA;&#x5305;&#x62EC;&#x6B63;&#x5E38;&#x56DE;&#x6EDA;&#x4E0E;&#x56DE;&#x6EDA;&#x8FC7;&#x7A0B;&#x4E2D;&#x51FA;&#x73B0;&#x5F02;&#x5E38;&#xFF0C;&#x81EA;&#x5B9A;&#x4E49;&#x7684;&#x89E6;&#x53D1;&#x5668;&#x4F1A;&#x6839;&#x636E;&#x8FD9;&#x4E9B;&#x4FE1;&#x606F;&#x505A;&#x8FDB;&#x4E00;&#x6B65;&#x5904;&#x7406;&#xFF0C;&#x800C;&#x5BF9;&#x4E8E;&#x89E6;&#x53D1;&#x5668;&#x7684;&#x6CE8;&#x518C;&#xFF0C;&#x5E38;&#x89C1;&#x662F;&#x5728;&#x56DE;&#x8C03;&#x8FC7;&#x7A0B;&#x8FC7;&#x7A0B;&#x4E2D;&#x63D0;&#x4F9B;TransactionSynchronizationManager&#x7C7B;&#x4E2D;&#x7684;&#x9759;&#x6001;&#x65B9;&#x6CD5;&#x76F4;&#x63A5;&#x6CE8;&#x518C;&#x3002;</li>
</ul>
</li>
</ul>
<pre><code>public static void registerSynchronization(TransactionSynchronization synchronization)
</code></pre><pre><code>- 2)&#x9664;&#x4E86;&#x89E6;&#x53D1;&#x76D1;&#x542C;&#x51FD;&#x6570;&#x5916;&#xFF0C;&#x5C31;&#x662F;&#x771F;&#x6B63;&#x7684;&#x56DE;&#x6EDA;&#x903B;&#x8F91;&#x5904;&#x7406;&#x4E86;&#x3002;&#x6709;&#x4FDD;&#x5B58;&#x70B9;&#x5219;&#x56DE;&#x6EDA;&#x5230;&#x4FDD;&#x5B58;&#x70B9;&#xFF0C;&#x662F;&#x65B0;&#x4E8B;&#x52A1;&#x5219;&#x56DE;&#x6EDA;&#x6574;&#x4E2A;&#x4E8B;&#x52A1;&#xFF1B;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#x53C8;&#x4E0D;&#x662F;&#x65B0;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x505A;&#x56DE;&#x6EDA;&#x6807;&#x8BB0;&#x3002;
- 3)&#x56DE;&#x6EDA;&#x540E;&#x8FDB;&#x884C;&#x4FE1;&#x606F;&#x6E05;&#x9664;
</code></pre><pre><code>private void processRollback(DefaultTransactionStatus status) {
   try {
      try {
</code></pre><ul>
<li>// &#x6FC0;&#x6D3B;&#x6240;&#x6709;TransactionSynchronization&#x4E2D;&#x5BF9;&#x5E94;&#x7684;beforeCompletion&#x65B9;&#x6CD5;
   triggerBeforeCompletion(status);
   if (status.hasSavepoint()) {<pre><code>  if (status.isDebug()) {
     logger.debug(&quot;Rolling back transaction to savepoint&quot;);
  }
</code></pre></li>
<li>// &#x5982;&#x679C;&#x6709;&#x4FDD;&#x5B58;&#x70B9;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x4E3A;&#x5355;&#x72EC;&#x7684;&#x7EBF;&#x7A0B;&#xFF0C;&#x5219;&#x4F1A;&#x9000;&#x5230;&#x4FDD;&#x5B58;&#x70B9;<pre><code>      status.rollbackToHeldSavepoint();
   }
   else if (status.isNewTransaction()) {
      if (status.isDebug()) {
         logger.debug(&quot;Initiating transaction rollback&quot;);
      }
</code></pre></li>
<li>// &#x5982;&#x679C;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x4E3A;&#x72EC;&#x7ACB;&#x7684;&#x65B0;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x56DE;&#x6EDA;<pre><code>      doRollback(status);
   }
   else if (status.hasTransaction()) {
      if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {
         if (status.isDebug()) {
            logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);
         }
</code></pre></li>
<li>// &#x5982;&#x679C;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x4E0D;&#x662F;&#x72EC;&#x7ACB;&#x7684;&#x4E8B;&#x52A1;&#xFF0C;&#x90A3;&#x4E48;&#x53EA;&#x80FD;&#x6807;&#x8BB0;&#x72B6;&#x6001;&#xFF0C;&#x7B49;&#x5230;&#x4E8B;&#x52A1;&#x94FE;&#x6267;&#x884C;&#x5B8C;&#x6BD5;&#x540E;&#x7EDF;&#x4E00;&#x56DE;&#x6EDA;<pre><code>         doSetRollbackOnly(status);
      }
      else {
         if (status.isDebug()) {
            logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);
         }
      }
   }
   else {
      logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);
   }
}
catch (RuntimeException ex) {
   triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
   throw ex;
}
catch (Error err) {
   triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
   throw err;
}
</code></pre></li>
<li>// &#x6FC0;&#x6D3B;&#x6240;&#x6709;TransactionSynchronization&#x4E2D;&#x5BF9;&#x5E94;&#x7684;&#x65B9;&#x6CD5;
triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
}
finally {</li>
<li><p>// &#x6E05;&#x7A7A;&#x8BB0;&#x5F55;&#x7684;&#x8D44;&#x6E90;&#x5E76;&#x5C06;&#x6302;&#x8D77;&#x7684;&#x8D44;&#x6E90;&#x6062;&#x590D;
cleanupAfterCompletion(status);
}
}</p>
<ul>
<li>2.2.1) triggerBeforeCompletion&#xFF08;&#x8C03;&#x7528;&#x89E6;&#x53D1;&#x5668;)</li>
</ul>
</li>
<li><p>protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {
 if (status.isNewSynchronization()) {</p>
<pre><code>if (status.isDebug()) {
   logger.trace(&quot;Triggering beforeCompletion synchronization&quot;);
}
TransactionSynchronizationUtils.triggerBeforeCompletion();
</code></pre><p> }
}</p>
</li>
<li><p>TransactionSynchronizationUtils.triggerBeforeCompletion()</p>
</li>
</ul>
<pre><code>public static void triggerBeforeCompletion() {
   for (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) {
      try {
         synchronization.beforeCompletion();
      }
      catch (Throwable tsex) {
         logger.error(&quot;TransactionSynchronization.beforeCompletion threw exception&quot;, tsex);
      }
   }
}
</code></pre><pre><code>- 2.2.2) rollbackToHeldSavepoint&#xFF08;&#x56DE;&#x6EDA;&#x81F3;&#x4FDD;&#x5B58;&#x70B9;)
</code></pre><pre><code>public void rollbackToHeldSavepoint() throws TransactionException {
   if (!hasSavepoint()) {
      throw new TransactionUsageException(
            &quot;Cannot roll back to savepoint - no savepoint associated with current transaction&quot;);
   }
   getSavepointManager().rollbackToSavepoint(getSavepoint());
   getSavepointManager().releaseSavepoint(getSavepoint());
   setSavepoint(null);
}
</code></pre><ul>
<li>JdbcTransactionObjectSupport.rollbackToSavepoint</li>
</ul>
<pre><code>public void rollbackToSavepoint(Object savepoint) throws TransactionException {
   ConnectionHolder conHolder = getConnectionHolderForSavepoint();
   try {
      conHolder.getConnection().rollback((Savepoint) savepoint);
   }
   catch (Throwable ex) {
      throw new TransactionSystemException(&quot;Could not roll back to JDBC savepoint&quot;, ex);
   }
}
</code></pre><pre><code>- 2.2.3) doRollback&#xFF08;&#x56DE;&#x6EDA;&#x6574;&#x4E2A;&#x4E8B;&#x52A1;)
</code></pre><ul>
<li><p>protected void doRollback(DefaultTransactionStatus status) {
 DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
 Connection con = txObject.getConnectionHolder().getConnection();
 if (status.isDebug()) {</p>
<pre><code>logger.debug(&quot;Rolling back JDBC transaction on Connection [&quot; + con + &quot;]&quot;);
</code></pre><p> }
 try {</p>
<pre><code>con.rollback();
</code></pre><p> }
 catch (SQLException ex) {</p>
<pre><code>throw new TransactionSystemException(&quot;Could not roll back JDBC transaction&quot;, ex);
</code></pre><p> }
}</p>
<ul>
<li>2.2.4) doSetRollbackOnly&#xFF08;&#x8BBE;&#x7F6E;&#x56DE;&#x6EDA;&#x6807;&#x8BB0;)</li>
</ul>
</li>
<li>protected void doSetRollbackOnly(DefaultTransactionStatus status) {
 DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
 if (status.isDebug()) {<pre><code>logger.debug(&quot;Setting JDBC transaction [&quot; + txObject.getConnectionHolder().getConnection() +
      &quot;] rollback-only&quot;);
</code></pre> }
 txObject.setRollbackOnly();
}</li>
</ul>
<pre><code>public void setRollbackOnly() {
   this.rollbackOnly = true;
}
</code></pre><pre><code>- 2.2.5) triggerAfterCompletion&#xFF08;&#x8C03;&#x7528;&#x89E6;&#x53D1;&#x5668;)
</code></pre><pre><code>private void triggerAfterCompletion(DefaultTransactionStatus status, int completionStatus) {
   if (status.isNewSynchronization()) {
      List&lt;TransactionSynchronization&gt; synchronizations = TransactionSynchronizationManager.getSynchronizations();
      TransactionSynchronizationManager.clearSynchronization();
      if (!status.hasTransaction() || status.isNewTransaction()) {
         if (status.isDebug()) {
            logger.trace(&quot;Triggering afterCompletion synchronization&quot;);
         }
         // No transaction or new transaction for the current scope -&gt;
         // invoke the afterCompletion callbacks immediately
         invokeAfterCompletion(synchronizations, completionStatus);
      }
      else if (!synchronizations.isEmpty()) {
         // Existing transaction that we participate in, controlled outside
         // of the scope of this Spring transaction manager -&gt; try to register
         // an afterCompletion callback with the existing (JTA) transaction.
         registerAfterCompletionWithExistingTransaction(status.getTransaction(), synchronizations);
      }
   }
}
</code></pre><pre><code>- 2.2.6) cleanupAfterCompletion&#xFF08;&#x56DE;&#x6EDA;&#x540E;&#x6E05;&#x9664;&#x4FE1;&#x606F;)
</code></pre><ul>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x8BBE;&#x7F6E;&#x72B6;&#x6001;&#x662F;&#x5BF9;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;&#x505A;&#x5B8C;&#x6210;&#x6807;&#x8BC6;&#x4EE5;&#x907F;&#x514D;&#x91CD;&#x590D;&#x8C03;&#x7528;</li>
<li>2)&#x5982;&#x679C;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x662F;&#x65B0;&#x7684;&#x540C;&#x6B65;&#x72B6;&#x6001;&#xFF0C;&#x9700;&#x8981;&#x5C06;&#x7ED1;&#x5B9A;&#x5230;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7684;&#x4E8B;&#x52A1;&#x4FE1;&#x606F;&#x6E05;&#x9664;</li>
<li>3)&#x5982;&#x679C;&#x662F;&#x65B0;&#x4E8B;&#x52A1;&#x9700;&#x8981;&#x505A;&#x4E9B;&#x6E05;&#x9664;&#x8D44;&#x6E90;&#x7684;&#x5DE5;&#x4F5C;</li>
</ul>
</li>
</ul>
<pre><code>private void cleanupAfterCompletion(DefaultTransactionStatus status) {
</code></pre><ul>
<li>// &#x8BBE;&#x7F6E;&#x5B8C;&#x6210;&#x72B6;&#x6001;
 status.setCompleted();
 if (status.isNewSynchronization()) {<pre><code>TransactionSynchronizationManager.clear();
</code></pre> }
 if (status.isNewTransaction()) {</li>
<li>// &#x6E05;&#x9664;&#x8D44;&#x6E90;<pre><code>doCleanupAfterCompletion(status.getTransaction());
</code></pre> }
 if (status.getSuspendedResources() != null) {<pre><code>if (status.isDebug()) {
   logger.debug(&quot;Resuming suspended transaction after completion of inner transaction&quot;);
}
</code></pre></li>
<li>// &#x7ED3;&#x675F;&#x4E4B;&#x524D;&#x4E8B;&#x52A1;&#x7684;&#x6302;&#x8D77;&#x72B6;&#x6001;<pre><code>resume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources());
</code></pre> }
}<ul>
<li>2.2.6.1) doCleanupAfterCompletion&#xFF08;&#x65B0;&#x4E8B;&#x52A1;&#x5219;&#x91CA;&#x653E;&#x8D44;&#x6E90;)</li>
</ul>
</li>
<li><p>protected void doCleanupAfterCompletion(Object transaction) {
 DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</p>
</li>
<li><p>// &#x5C06;&#x8FDE;&#x63A5;&#x4ECE;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E2D;&#x89E3;&#x9664;&#x7ED1;&#x5B9A;
 // Remove the connection holder from the thread, if exposed.
 if (txObject.isNewConnectionHolder()) {</p>
<pre><code>TransactionSynchronizationManager.unbindResource(this.dataSource);
</code></pre><p> }</p>
<p> // Reset connection.
 Connection con = txObject.getConnectionHolder().getConnection();
 try {</p>
<pre><code>if (txObject.isMustRestoreAutoCommit()) { 
   con.setAutoCommit(true);
}
</code></pre></li>
<li><p>// &#x91CD;&#x7F6E;&#x6570;&#x636E;&#x5E93;&#x8FDE;&#x63A5;</p>
<pre><code>DataSourceUtils.resetConnectionAfterTransaction(con, txObject.getPreviousIsolationLevel());
</code></pre><p> }
 catch (Throwable ex) {</p>
<pre><code>logger.debug(&quot;Could not reset JDBC Connection after transaction&quot;, ex);
</code></pre><p> }</p>
<p> if (txObject.isNewConnectionHolder()) {</p>
<pre><code>if (logger.isDebugEnabled()) {
   logger.debug(&quot;Releasing JDBC Connection [&quot; + con + &quot;] after transaction&quot;);
}
</code></pre></li>
<li><p>// &#x5982;&#x679C;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x662F;&#x72EC;&#x7ACB;&#x7684;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x5728;&#x4E8B;&#x52A1;&#x5B8C;&#x6210;&#x65F6;&#x91CA;&#x653E;&#x6570;&#x636E;&#x5E93;&#x8FDE;&#x63A5;</p>
<pre><code>DataSourceUtils.releaseConnection(con, this.dataSource);
</code></pre><p> }</p>
<p> txObject.getConnectionHolder().clear();
}</p>
<ul>
<li>2.2.6.2) resume&#xFF08;&#x5C06;&#x6302;&#x8D77;&#x4E8B;&#x52A1;&#x6062;&#x590D;)</li>
</ul>
</li>
<li>&#x5982;&#x679C;&#x5728;&#x4E8B;&#x52A1;&#x6267;&#x884C;&#x524D;&#x6709;&#x4E8B;&#x52A1;&#x6302;&#x8D77;&#xFF0C;&#x90A3;&#x4E48;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x6267;&#x884C;&#x7ED3;&#x675F;&#x540E;&#x9700;&#x8981;&#x5C06;&#x6302;&#x8D77;&#x4E8B;&#x52A1;&#x6062;&#x590D;</li>
<li><p>protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder)</p>
<pre><code>throws TransactionException {
</code></pre><p> if (resourcesHolder != null) {</p>
<pre><code>Object suspendedResources = resourcesHolder.suspendedResources;
if (suspendedResources != null) {
   doResume(transaction, suspendedResources);
}
List&lt;TransactionSynchronization&gt; suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;
if (suspendedSynchronizations != null) {
   TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive);
   TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel);
   TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly);
   TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name);
   doResumeSynchronization(suspendedSynchronizations);
}
</code></pre><p> }
}</p>
</li>
<li><ul>
<li>3)commitTransactionAfterReturning&#xFF08;&#x63D0;&#x4EA4;&#x4E8B;&#x52A1;)</li>
</ul>
</li>
<li><p>protected void commitTransactionAfterReturning(TransactionInfo txInfo) {
 if (txInfo != null &amp;&amp; txInfo.hasTransaction()) {</p>
<pre><code>if (logger.isTraceEnabled()) {
   logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);
}
txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
</code></pre><p> }
}</p>
</li>
<li><p>commit</p>
</li>
<li>&#x67D0;&#x4E2A;&#x4E8B;&#x52A1;&#x662F;&#x53E6;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#x7684;&#x5D4C;&#x5165;&#x4E8B;&#x52A1;&#xFF0C;&#x4F46;&#x662F;&#x8FD9;&#x4E9B;&#x4E8B;&#x52A1;&#x53C8;&#x4E0D;&#x5728;Spring&#x7684;&#x7BA1;&#x7406;&#x8303;&#x56F4;&#x4E4B;&#x5185;&#xFF0C;&#x6216;&#x8005;&#x65E0;&#x6CD5;&#x8BBE;&#x7F6E;&#x4FDD;&#x5B58;&#x70B9;&#xFF0C;&#x90A3;&#x4E48;Spring&#x4F1A;&#x901A;&#x8FC7;&#x8BBE;&#x7F6E;&#x56DE;&#x6EDA;&#x6807;&#x8BC6;&#x7684;&#x65B9;&#x5F0F;&#x6765;&#x7981;&#x6B62;&#x63D0;&#x4EA4;&#x3002;&#x9996;&#x5148;&#x5F53;&#x67D0;&#x4E2A;&#x5D4C;&#x5165;&#x4E8B;&#x52A1;&#x53D1;&#x751F;&#x56DE;&#x6EDA;&#x7684;&#x65F6;&#x5019;&#x4F1A;&#x8BBE;&#x7F6E;&#x56DE;&#x6EDA;&#x6807;&#x8BC6;&#xFF0C;&#x800C;&#x7B49;&#x5230;&#x5916;&#x90E8;&#x4E8B;&#x52A1;&#x63D0;&#x4EA4;&#x65F6;&#xFF0C;&#x4E00;&#x65E6;&#x5224;&#x65AD;&#x51FA;&#x5F53;&#x524D;&#x4E8B;&#x52A1;&#x6D41;&#x88AB;&#x8BBE;&#x7F6E;&#x4E86;&#x56DE;&#x6EDA;&#x6807;&#x8BC6;&#xFF0C;&#x5219;&#x7531;&#x5916;&#x90E8;&#x4E8B;&#x52A1;&#x6765;&#x7EDF;&#x4E00;&#x8FDB;&#x884C;&#x6574;&#x4F53;&#x4E8B;&#x52A1;&#x7684;&#x56DE;&#x6EDA;&#x3002;</li>
</ul>
<pre><code>public final void commit(TransactionStatus status) throws TransactionException {
   if (status.isCompleted()) {
      throw new IllegalTransactionStateException(
            &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);
   }

   DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
</code></pre><ul>
<li><p>// &#x5982;&#x679C;&#x5728;&#x4E8B;&#x52A1;&#x94FE;&#x4E2D;&#x5DF2;&#x7ECF;&#x88AB;&#x6807;&#x8BB0;&#x56DE;&#x6EDA;&#xFF0C;&#x90A3;&#x4E48;&#x4E0D;&#x4F1A;&#x5C1D;&#x8BD5;&#x63D0;&#x4EA4;&#x4E8B;&#x52A1;&#xFF0C;&#x76F4;&#x63A5;&#x56DE;&#x6EDA;
 if (defStatus.isLocalRollbackOnly()) {</p>
<pre><code>if (defStatus.isDebug()) {
   logger.debug(&quot;Transactional code has requested rollback&quot;);
}
processRollback(defStatus);
return;
</code></pre><p> }
 if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) {</p>
<pre><code>if (defStatus.isDebug()) {
   logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;);
}
processRollback(defStatus);
// Throw UnexpectedRollbackException only at outermost transaction boundary
// or if explicitly asked to.
if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {
   throw new UnexpectedRollbackException(
         &quot;Transaction rolled back because it has been marked as rollback-only&quot;);
}
return;
</code></pre><p> }
 // &#x5904;&#x7406;&#x4E8B;&#x52A1;&#x63D0;&#x4EA4;
 processCommit(defStatus);
}</p>
</li>
<li><p>processCommit</p>
</li>
<li>&#x5728;&#x63D0;&#x4EA4;&#x8FC7;&#x7A0B;&#x4E2D;&#x4E5F;&#x4E0D;&#x662F;&#x76F4;&#x63A5;&#x63D0;&#x4EA4;&#x7684;&#xFF0C;&#x800C;&#x662F;&#x8003;&#x8651;&#x4E86;&#x8BF8;&#x591A;&#x65B9;&#x9762;&#x3002;</li>
<li>&#x7B26;&#x5408;&#x63D0;&#x4EA4;&#x7684;&#x6761;&#x4EF6;&#x5982;&#x4E0B;&#xFF1A;</li>
<li>&#x5F53;&#x4E8B;&#x52A1;&#x72B6;&#x6001;&#x4E2D;&#x6709;&#x4FDD;&#x5B58;&#x70B9;&#x4FE1;&#x606F;&#x7684;&#x8BDD;&#x4FBF;&#x4E0D;&#x4F1A;&#x63D0;&#x4EA4;&#x4E8B;&#x52A1;&#xFF1B;</li>
<li><p>&#x5F53;&#x4E8B;&#x52A1;&#x4E0D;&#x662F;&#x65B0;&#x4E8B;&#x52A1;&#x7684;&#x65F6;&#x5019;&#x4E5F;&#x4E0D;&#x4F1A;&#x63D0;&#x4EA4;&#x4E8B;&#x52A1;</p>
</li>
<li><p>&#x539F;&#x56E0;&#x662F;&#xFF1A;</p>
</li>
<li>&#x5BF9;&#x4E8E;&#x5185;&#x5D4C;&#x4E8B;&#x52A1;&#xFF0C;&#x5728;Spring&#x4E2D;&#x4F1A;&#x5C06;&#x5176;&#x5728;&#x5F00;&#x59CB;&#x4E4B;&#x524D;&#x8BBE;&#x7F6E;&#x4FDD;&#x5B58;&#x70B9;&#xFF0C;&#x4E00;&#x65E6;&#x5185;&#x5D4C;&#x4E8B;&#x52A1;&#x51FA;&#x73B0;&#x5F02;&#x5E38;&#x4FBF;&#x6839;&#x636E;&#x4FDD;&#x5B58;&#x70B9;&#x4FE1;&#x606F;&#x8FDB;&#x884C;&#x56DE;&#x6EDA;&#xFF0C;&#x4F46;&#x662F;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x51FA;&#x73B0;&#x5F02;&#x5E38;&#xFF0C;&#x5185;&#x5D4C;&#x4E8B;&#x52A1;&#x5E76;&#x4E0D;&#x4F1A;&#x5355;&#x72EC;&#x63D0;&#x4EA4;&#xFF0C;&#x800C;&#x662F;&#x6839;&#x636E;&#x4E8B;&#x52A1;&#x6D41;&#x7531;&#x6700;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x8D1F;&#x8D23;&#x63D0;&#x4EA4;&#xFF0C;&#x6240;&#x4EE5;&#x5982;&#x679C;&#x5F53;&#x524D;&#x5B58;&#x5728;&#x4FDD;&#x5B58;&#x70B9;&#x4FE1;&#x606F;&#x4FBF;&#x4E0D;&#x662F;&#x6700;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#xFF0C;&#x4E0D;&#x505A;&#x63D0;&#x4EA4;&#x64CD;&#x4F5C;&#x3002;</li>
</ul>
<pre><code>private void processCommit(DefaultTransactionStatus status) throws TransactionException {
   try {
      boolean beforeCompletionInvoked = false;
      try {
</code></pre><ul>
<li>// &#x9884;&#x7559;<pre><code>   prepareForCommit(status);
</code></pre></li>
<li>// &#x6DFB;&#x52A0;&#x7684;TransactionSynchronization&#x4E2D;&#x5BF9;&#x5E94;&#x65B9;&#x6CD5;&#x7684;&#x8C03;&#x7528;<pre><code>   triggerBeforeCommit(status);
</code></pre></li>
<li>// &#x6DFB;&#x52A0;&#x7684;TransactionSynchronization&#x4E2D;&#x5BF9;&#x5E94;&#x65B9;&#x6CD5;&#x7684;&#x8C03;&#x7528;<pre><code>   triggerBeforeCompletion(status);
   beforeCompletionInvoked = true;
   boolean globalRollbackOnly = false;
   if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {
      globalRollbackOnly = status.isGlobalRollbackOnly();
   }
   if (status.hasSavepoint()) {
      if (status.isDebug()) {
         logger.debug(&quot;Releasing transaction savepoint&quot;);
      }
</code></pre></li>
<li>// &#x5982;&#x679C;&#x5B58;&#x5728;&#x4FDD;&#x5B58;&#x70B9;&#xFF0C;&#x5219;&#x6E05;&#x9664;&#x4FDD;&#x5B58;&#x70B9;&#x4FE1;&#x606F;<pre><code>      status.releaseHeldSavepoint();
   }
   else if (status.isNewTransaction()) {
      if (status.isDebug()) {
         logger.debug(&quot;Initiating transaction commit&quot;);
      }
</code></pre></li>
<li>// &#x5982;&#x679C;&#x662F;&#x65B0;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x63D0;&#x4EA4;<pre><code>      doCommit(status);
   }
   // Throw UnexpectedRollbackException if we have a global rollback-only
   // marker but still didn&apos;t get a corresponding exception from commit.
   if (globalRollbackOnly) {
      throw new UnexpectedRollbackException(
            &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);
   }
}
catch (UnexpectedRollbackException ex) {
   // can only be caused by doCommit
   triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
   throw ex;
}
catch (TransactionException ex) {
   // can only be caused by doCommit
   if (isRollbackOnCommitFailure()) {
      doRollbackOnCommitException(status, ex);
   }
   else {
      triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
   }
   throw ex;
}
catch (RuntimeException ex) {
   if (!beforeCompletionInvoked) {
</code></pre></li>
<li>// &#x6DFB;&#x52A0;&#x7684;TransactionSynchronization&#x4E2D;&#x5BF9;&#x5E94;&#x65B9;&#x6CD5;&#x7684;&#x8C03;&#x7528;<pre><code>      triggerBeforeCompletion(status);
   }
</code></pre></li>
<li><p>// &#x63D0;&#x4EA4;&#x8FC7;&#x7A0B;&#x4E2D;&#x51FA;&#x73B0;&#x5F02;&#x5E38;&#x5219;&#x56DE;&#x6EDA;</p>
<pre><code>   doRollbackOnCommitException(status, ex);
   throw ex;
}
catch (Error err) {
   if (!beforeCompletionInvoked) {
      triggerBeforeCompletion(status);
   }
   doRollbackOnCommitException(status, err);
   throw err;
}

// Trigger afterCommit callbacks, with an exception thrown there
// propagated to callers but the transaction still considered as committed.
try {
</code></pre></li>
<li><p>// &#x6DFB;&#x52A0;&#x7684;TransactionSynchronization&#x4E2D;&#x5BF9;&#x5E94;&#x65B9;&#x6CD5;&#x7684;&#x8C03;&#x7528;</p>
<pre><code>   triggerAfterCommit(status);
}
finally {
   triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);
}
</code></pre><p> }
 finally {</p>
<pre><code>cleanupAfterCompletion(status);
</code></pre><p> }
}</p>
</li>
<li></li>
<li><p>&#x5B9E;&#x4F8B;</p>
</li>
</ul>
<pre><code>public interface LoginService {
    void login(RegisterDTO dto);
}
</code></pre><pre><code>@Service
public class LoginServiceImpl implements LoginService{
    @Override
    @Transactional(rollbackFor = RuntimeException.class,propagation = Propagation.NESTED)
    public void login(RegisterDTO dto) {
        System.out.println(&quot;login...&quot;);
        throw new RuntimeException(&quot;exception in loginservice&quot;);
    }
}
</code></pre><pre><code>public interface UserService {
    void addUser(RegisterDTO dto);
}
</code></pre><pre><code>@Service
public class UserServiceImpl implements UserService{

    @Transactional(rollbackFor = RuntimeException.class,propagation = Propagation.NESTED)
    @Override
    public void addUser(RegisterDTO dto) {
        System.out.println(&quot;addUser...&quot;);
    }
}
</code></pre><pre><code>public interface RegisterService {
    void register(RegisterDTO dto);
}
</code></pre><pre><code>@Service
public class RegisterServiceImpl implements  RegisterService{
    @Autowired
    private LoginService loginService;
    @Autowired
    private UserService userService;

    @Transactional(rollbackFor = RuntimeException.class,propagation = Propagation.NESTED)
    @Override
    public void register(RegisterDTO dto) {
        System.out.println(&quot;registering...&quot;);
        loginService.login(dto);
        System.out.println(&quot;invoke other methods...&quot;);
        userService.addUser(dto);
    }
}
</code></pre><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath*:spring/spring-*.xml&quot;)
@WebAppConfiguration
public class TransactionTest {
    @Autowired
    private RegisterService registerService;

    @Test
    public void test(){
        registerService.register(new RegisterDTO());
    }
}
</code></pre><ul>
<li>REQUIRED&#xFF08;&#x5185;&#x5C42;&#x4E8B;&#x52A1;newTransaction&#x4E3A;false&#xFF0C;&#x5185;&#x5C42;&#x4E8B;&#x52A1;&#x56DE;&#x6EDA;&#x65F6;&#x4EC5;&#x8BBE;&#x7F6E;&#x56DE;&#x6EDA;&#x6807;&#x8BB0;&#xFF0C;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x8FDB;&#x884C;&#x5916;&#x5C42;&#x56DE;&#x6EDA;)</li>
<li>&#x5982;&#x679C;&#x51E0;&#x4E2A;&#x4E0D;&#x540C;&#x7684;service&#x90FD;&#x662F;&#x5171;&#x4EAB;&#x540C;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#xFF08;&#x4E5F;&#x5C31;&#x662F;service&#x5BF9;&#x8C61;&#x5D4C;&#x5957;&#x4F20;&#x64AD;&#x673A;&#x5236;&#x4E3A;Propagation.REQUIRED)&#xFF0C;&#x90A3;&#x4E48;&#x5B83;&#x4EEC;&#x4F1A;&#x4E00;&#x8D77;&#x63D0;&#x4EA4;&#xFF0C;&#x4E00;&#x8D77;&#x56DE;&#x6EDA;&#x3002;</li>
<li><p>&#x540C;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#xFF0C;&#x5982;&#x679C;&#x4E00;&#x4E2A;service&#x5DF2;&#x7ECF;&#x63D0;&#x4EA4;&#x4E86;&#xFF0C;&#x5728;&#x53E6;&#x5916;service&#x4E2D;rollback&#x81EA;&#x7136;&#x5BF9;&#x7B2C;&#x4E00;&#x4E2A;service&#x63D0;&#x4EA4;&#x7684;&#x4EE3;&#x7801;&#x56DE;&#x6EDA;&#x4E0D;&#x4E86;&#x7684;&#x3002;&#x6240;&#x4EE5;spring&#x5904;&#x7406;&#x5D4C;&#x5957;&#x4E8B;&#x52A1;&#xFF0C;&#x5C31;&#x662F;&#x5728;TransactionInterceptor&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;&#x6839;&#x636E;&#x4E00;&#x7CFB;&#x5217;&#x5F00;&#x5173;&#xFF08;&#x4E8B;&#x52A1;&#x4F20;&#x64AD;&#x884C;&#x4E3A;)&#xFF0C;&#x6765;&#x5904;&#x7406;&#x4E8B;&#x52A1;&#x662F;&#x540C;&#x4E00;&#x4E2A;&#x8FD8;&#x662F;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#xFF0C;&#x5982;&#x679C;&#x662F;&#x540C;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;,&#x4E0D;&#x540C;service&#x7684;commit&#x4E0E;rollback&#x7684;&#x65F6;&#x673A;&#x3002;</p>
</li>
<li><p>&#x8FD9;&#x91CC;&#x6709;&#x4E00;&#x4E2A;&#x5916;&#x5C42;&#x5207;&#x9762;register&#xFF0C;&#x4F7F;&#x7528;&#x4E86;&#x4E8B;&#x52A1;&#xFF0C;&#x91CC;&#x9762;&#x8C03;&#x7528;&#x4E86;&#x4E24;&#x4E2A;service&#xFF0C;&#x5B83;&#x4EEC;&#x4E5F;&#x662F;&#x8981;&#x6C42;&#x4F7F;&#x7528;&#x4E8B;&#x52A1;&#x7684;&#x3002;</p>
</li>
<li>&#x56E0;&#x4E3A;&#x4F20;&#x64AD;&#x884C;&#x4E3A;&#x662F;REQUIRED&#xFF0C;&#x6240;&#x4EE5;&#x5171;&#x7528;&#x540C;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#x3002;</li>
<li><p>&#x5F53;&#x8C03;&#x7528;register&#x65F6;&#xFF0C;&#x5728;getTransaction&#x65F6;&#x4F1A;&#x5C06;TransactionStatus&#x4E2D;&#x7684;newTransaction&#x8BBE;&#x7F6E;&#x4E3A;true&#xFF0C;&#x5E76;&#x4E14;&#x5C06;&#x8FDE;&#x63A5;&#x7ED1;&#x5B9A;&#x5230;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#xFF0C;&#x8BBE;&#x7F6E;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#x3002;</p>
</li>
<li><p>&#x5F53;&#x540E;&#x7EED;&#x8C03;&#x7528;login&#x548C;addUser&#x65F6;&#xFF0C;&#x5B83;&#x4EEC;&#x7684;TransactionStatus&#x4E2D;&#x7684;newTransaction&#x8BBE;&#x7F6E;&#x4E3A;false&#x3002;</p>
</li>
<li><p>&#x5982;&#x679C;register&#x65B9;&#x6CD5;&#x4E2D;&#x629B;&#x51FA;&#x8FD0;&#x884C;&#x65F6;&#x5F02;&#x5E38;&#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;rollback&#x6574;&#x4E2A;&#x4E8B;&#x52A1;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x662F;&#x4E00;&#x4E2A;&#x65B0;&#x4E8B;&#x52A1;&#x3002;</p>
</li>
<li>&#x5982;&#x679C;login&#x65B9;&#x6CD5;&#x4E2D;&#x629B;&#x51FA;&#x8FD0;&#x884C;&#x65F6;&#x5F02;&#x5E38;&#xFF0C;&#x53EA;&#x80FD;&#x5C06;rollbackOnly&#x8BBE;&#x7F6E;&#x4E3A;true&#x3002;&#x56E0;&#x4E3A;login&#x4E2D;&#x6CA1;&#x6709;catch&#x8BE5;&#x5F02;&#x5E38;&#xFF08;&#x56DE;&#x6EDA;&#x540E;&#x53C8;&#x629B;&#x51FA;&#x8BE5;&#x5F02;&#x5E38;)&#xFF0C;&#x6240;&#x4EE5;&#x5F02;&#x5E38;&#x88AB;register&#x6355;&#x83B7;&#xFF08;&#x8DF3;&#x8FC7;&#x4E86;addUser)&#xFF0C;&#x6240;&#x4EE5;register&#x53C8;&#x8981;&#x6267;&#x884C;rollback&#x65B9;&#x6CD5;&#xFF0C;&#x6574;&#x4E2A;&#x4E8B;&#x52A1;&#x8FDB;&#x884C;&#x56DE;&#x6EDA;&#x3002;</li>
<li>REQUIRES_NEW&#xFF08;&#x5185;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x5E73;&#x7EA7;&#xFF0C;&#x5185;&#x5C42;&#x4E8B;&#x52A1;newTransaction&#x4E3A;true&#xFF0C;suspend&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#xFF0C;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x540E;&#x5185;&#x5C42;&#x4E8B;&#x52A1;&#x8FDB;&#x884C;&#x5185;&#x5C42;&#x56DE;&#x6EDA;&#xFF0C;resume&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#xFF0C;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x6355;&#x83B7;&#x5230;&#x5185;&#x5C42;&#x629B;&#x51FA;&#x7684;&#x5F02;&#x5E38;&#x540E;&#x8FDB;&#x884C;&#x5916;&#x5C42;&#x56DE;&#x6EDA;)</li>
<li><p>register&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x4E8B;&#x52A1;&#xFF0C;newTransaction&#x4E3A;true&#x3002;</p>
</li>
<li><p>&#x8C03;&#x7528;login&#x65B9;&#x6CD5;&#x65F6;&#x68C0;&#x6D4B;&#x5230;&#x5DF2;&#x5B58;&#x5728;&#x4E8B;&#x52A1;&#xFF0C;&#x5219;&#x5C06;&#x5DF2;&#x5B58;&#x5728;&#x4E8B;&#x52A1;suspend&#xFF0C;&#x5E76;&#x4E14;&#x521B;&#x5EFA;&#x7684;&#x65B0;&#x4E8B;&#x52A1;&#xFF0C;newTransaction&#x4E3A;true&#x3002;</p>
</li>
<li><p>&#x5F53;login&#x65B9;&#x6CD5;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x65F6;&#xFF0C;&#x56E0;&#x4E3A;newTransaction&#x4E3A;true&#xFF0C;&#x5219;&#x56DE;&#x6EDA;&#x8BE5;&#x4E8B;&#x52A1;&#x3002;&#x5F02;&#x5E38;&#x88AB;&#x629B;&#x51FA;&#x5230;&#x5916;&#x5C42;register&#xFF0C;register&#x6355;&#x83B7;&#x8BE5;&#x5F02;&#x5E38;&#xFF0C;&#x5E76;&#x56DE;&#x6EDA;&#x3002;</p>
</li>
<li>NESTED&#xFF08;&#x5185;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x5D4C;&#x5957;&#xFF0C;&#x5185;&#x5C42;&#x4E8B;&#x52A1;newTransaction&#x4E3A;false&#xFF0C;&#x5E76;&#x521B;&#x5EFA;&#x8FD8;&#x539F;&#x70B9;&#xFF0C;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x540E;rollback&#x81F3;&#x8FD8;&#x539F;&#x70B9;&#xFF0C;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x6355;&#x83B7;&#x5230;&#x5185;&#x5C42;&#x629B;&#x51FA;&#x7684;&#x5F02;&#x5E38;&#x540E;&#x8FDB;&#x884C;&#x5916;&#x5C42;&#x56DE;&#x6EDA;)</li>
<li>&#x5982;&#x679C;PlatformTransactionManager&#x652F;&#x6301;&#x8FD8;&#x539F;&#x70B9;&#xFF0C;&#x4FBF;&#x5982;&#x4E0A;&#x6267;&#x884C;&#xFF1B;&#x5982;&#x679C;&#x4E0D;&#x652F;&#x6301;&#xFF0C;&#x90A3;&#x4E48;&#x884C;&#x4E3A;&#x4E0E;REQUIRES_NEW&#x76F8;&#x540C;&#x3002;</li>
<li><p>&#x5916;&#x5C42;&#x4E8B;&#x52A1;register&#x7684;newTransaction&#x4E3A;true&#xFF0C;&#x8FDB;&#x5165;&#x5185;&#x5C42;&#x4E8B;&#x52A1;login&#x3002;</p>
</li>
<li><p>&#x5185;&#x5C42;&#x4E8B;&#x52A1;login&#x7684;newTransaction&#x4E3A;false&#xFF0C;&#x5E76;&#x5728;&#x83B7;&#x53D6;Transaction&#x65F6;&#x521B;&#x5EFA;&#x4E86;&#x4E00;&#x4E2A;&#x8FD8;&#x539F;&#x70B9;&#x3002;&#xFF08;JTA&#x4E0D;&#x652F;&#x6301;&#x8FD8;&#x539F;&#x70B9;&#xFF0C;&#x6B64;&#x65F6;&#x884C;&#x4E3A;&#x4E0E;REQUIRES_NEW&#x76F8;&#x540C;)&#x3002;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x540E;&#x5728;rollback&#x65F6;&#x76F4;&#x63A5;rollback&#x81F3;&#x4E4B;&#x524D;&#x521B;&#x5EFA;&#x7684;&#x8FD8;&#x539F;&#x70B9;&#xFF0C;&#x5E76;&#x5220;&#x9664;&#x4E86;&#x8BE5;&#x8FD8;&#x539F;&#x70B9;&#x3002;</p>
</li>
</ul>
<ul>
<li><p>&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x6355;&#x83B7;&#x5230;&#x8BE5;&#x5F02;&#x5E38;&#xFF0C;&#x8FDB;&#x5165;rollback&#xFF0C;&#x56E0;&#x4E3A;&#x662F;&#x65B0;&#x4E8B;&#x52A1;&#xFF0C;&#x6267;&#x884C;&#x5916;&#x5C42;&#x4E8B;&#x52A1;&#x7684;&#x56DE;&#x6EDA;&#x3002;</p>
</li>
<li><p>Spring MVC</p>
</li>
<li>&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x793A;&#x4F8B;</li>
<li>web.xml</li>
<li><context-param>
  <param-name>contextConfigLocation&lt;/param-name&gt;
  <param-value>classpath<em>:spring/spring-</em>.xml&lt;/param-value&gt;
&lt;/context-param&gt;</param-value></param-name></context-param></li>
</ul>
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<servlet>
    <servlet-name>springDispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring/spring-web.xml</param-value>
    </init-param>
</servlet>

<p><servlet-mapping>
    <servlet-name>springDispatcherServlet&lt;/servlet-name&gt;
    <url-pattern>/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</url-pattern></servlet-name></servlet-mapping></p>
<ul>
<li>&#x5728;&#x8FD9;&#x91CC;&#x914D;&#x7F6E;&#x4E86;contextConfigLocation&#xFF0C;&#x6307;&#x5B9A;&#x4E86;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x7684;&#x4F4D;&#x7F6E;&#xFF1B;</li>
<li>&#x5E76;&#x914D;&#x7F6E;&#x4E86;DispatcherServlet&#xFF0C;Spring&#x4F7F;&#x7528;&#x8BE5;&#x7C7B;&#x62E6;&#x622A;Web&#x8BF7;&#x6C42;&#x5E76;&#x8FDB;&#x884C;&#x8F6C;&#x53D1;&#xFF1B;</li>
<li>&#x8FD8;&#x914D;&#x7F6E;&#x4E86;ContextLoaderListener&#xFF0C;&#x7528;&#x4E8E;&#x521D;&#x59CB;&#x5316;Spring&#x3002;</li>
<li><p>&#x5728;Spring&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#xFF0C;&#x9700;&#x8981;&#x914D;&#x7F6E;viewResolver&#x3002;</p>
</li>
<li></li>
<li><p>&#x8FD0;&#x884C;&#x6D41;&#x7A0B;</p>
</li>
<li><p>DispatcherServlet&#xFF1A; SpringMVC&#x603B;&#x7684;&#x62E6;&#x622A;&#x5668;</p>
</li>
<li>HandlerMapping&#xFF1A;&#x8BF7;&#x6C42;&#x548C;&#x5904;&#x7406;&#x5668;&#x4E4B;&#x95F4;&#x7684;&#x6620;&#x5C04;&#xFF0C;&#x7528;&#x4E8E;&#x83B7;&#x53D6;HandlerExecutionChain</li>
<li>HandlerExecutionChain&#xFF1A;&#x6301;&#x6709;&#x4E00;&#x7EC4;Interceptor&#x548C;&#x5B9E;&#x9645;&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x5668;HandlerAdapter&#xFF0C;&#x8D1F;&#x8D23;&#x6267;&#x884C;Interceptor&#x7684;&#x5404;&#x4E2A;&#x65B9;&#x6CD5;&#x548C;&#x5904;&#x7406;&#x65B9;&#x6CD5;&#x3002;</li>
<li>HandlerAdapter&#xFF1A;&#x5B9E;&#x9645;&#x7684;&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x5668;&#xFF0C;&#x5904;&#x7406;&#x540E;&#x8FD4;&#x56DE;ModelAndView</li>
<li>HandlerExceptionResolver&#xFF1A;&#x5F02;&#x5E38;&#x5904;&#x7406;&#x5668;&#xFF0C;&#x5F53;&#x62E6;&#x622A;&#x5668;&#x7684;postHandle&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x540E;&#x68C0;&#x67E5;&#x5F02;&#x5E38;&#x3002;</li>
<li>ViewResolver&#xFF1A;&#x89C6;&#x56FE;&#x89E3;&#x6790;&#x5668;,&#x89E3;&#x6790;&#x89C6;&#x56FE;&#x540D;&#xFF0C;&#x5F97;&#x5230;View&#xFF0C;&#x7531;&#x903B;&#x8F91;&#x89C6;&#x56FE;&#x53D8;&#x4E3A;&#x7269;&#x7406;&#x89C6;&#x56FE;&#x3002;</li>
<li>View &#xFF1A;&#x6709;render&#x65B9;&#x6CD5;&#xFF0C;&#x6E32;&#x67D3;&#x89C6;&#x56FE;</li>
<li>&#x6E32;&#x67D3;&#x5B8C;&#x6BD5;&#x540E;&#x8C03;&#x7528;&#x8F6C;&#x53D1;</li>
<li></li>
<li><p>&#x521D;&#x59CB;&#x5316;ApplicationContext</p>
</li>
<li>ContextLoaderListener&#xFF08;&#x5165;&#x53E3;)</li>
<li>ContextLoaderListener&#x7684;&#x4F5C;&#x7528;&#x5C31;&#x662F;&#x542F;&#x52A8;Web&#x5BB9;&#x5668;&#x65F6;&#xFF0C;&#x81EA;&#x52A8;&#x88C5;&#x914D;ApplicationContext&#x7684;&#x914D;&#x7F6E;&#x4FE1;&#x606F;&#x3002;</li>
<li>&#x56E0;&#x4E3A;&#x5B83;&#x5B9E;&#x73B0;&#x4E86;ServletContextListener&#x8FD9;&#x4E2A;&#x63A5;&#x53E3;&#xFF0C;&#x5728;web.xml&#x914D;&#x7F6E;&#x8FD9;&#x4E2A;&#x76D1;&#x542C;&#x5668;&#xFF0C;&#x542F;&#x52A8;&#x5BB9;&#x5668;&#x65F6;&#xFF0C;&#x5C31;&#x4F1A;&#x9ED8;&#x8BA4;&#x6267;&#x884C;&#x5B83;&#x5B9E;&#x73B0;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x4F7F;&#x7528;ServletContextListener&#x63A5;&#x53E3;&#xFF0C;&#x5F00;&#x53D1;&#x8005;&#x80FD;&#x591F;&#x5728;&#x4E3A;&#x5BA2;&#x6237;&#x7AEF;&#x8BF7;&#x6C42;&#x63D0;&#x4F9B;&#x670D;&#x52A1;&#x4E4B;&#x524D;&#x5411;ServletContext&#x4E2D;&#x6DFB;&#x52A0;&#x4EFB;&#x610F;&#x7684;&#x5BF9;&#x8C61;&#x3002;</li>
<li>&#x5728;ServletContextListener&#x4E2D;&#x7684;&#x6838;&#x5FC3;&#x903B;&#x8F91;&#x662F;&#x521D;&#x59CB;&#x5316;WebApplicationContext&#x5B9E;&#x4F8B;&#x5E76;&#x5B58;&#x653E;&#x5728;ServletContext&#x4E2D;&#x3002;</li>
</ul>
<pre><code>public void contextInitialized(ServletContextEvent event) {
   initWebApplicationContext(event.getServletContext());
}
</code></pre><ul>
<li>ContextLoader#initWebApplicationContext</li>
</ul>
<pre><code>public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
   if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {
      throw new IllegalStateException(
            &quot;Cannot initialize context because there is already a root application context present - &quot; +
            &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);
   }

   Log logger = LogFactory.getLog(ContextLoader.class);
   servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);
   if (logger.isInfoEnabled()) {
      logger.info(&quot;Root WebApplicationContext: initialization started&quot;);
   }
   long startTime = System.currentTimeMillis();

   try {
      // Store context in local instance variable, to guarantee that
      // it is available on ServletContext shutdown.
      if (this.context == null) {
</code></pre><ul>
<li><p>// &#x521B;&#x5EFA;WebApplicationContext</p>
<pre><code>   this.context = createWebApplicationContext(servletContext);
}
if (this.context instanceof ConfigurableWebApplicationContext) {
   ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
   if (!cwac.isActive()) {
      // The context has not yet been refreshed -&gt; provide services such as
      // setting the parent context, setting the application context id, etc
      if (cwac.getParent() == null) {
         // The context instance was injected without an explicit parent -&gt;
         // determine parent for root web application context, if any.
         ApplicationContext parent = loadParentContext(servletContext);
         cwac.setParent(parent);
      }
      configureAndRefreshWebApplicationContext(cwac, servletContext);
   }
}
// &#x8BB0;&#x5F55;&#x5728;ServletContext&#x4E2D; servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);

ClassLoader ccl = Thread.currentThread().getContextClassLoader();
if (ccl == ContextLoader.class.getClassLoader()) {
   currentContext = this.context;
}
else if (ccl != null) {
   currentContextPerThread.put(ccl, this.context);
}

if (logger.isDebugEnabled()) {
   logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +
         WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);
}
if (logger.isInfoEnabled()) {
   long elapsedTime = System.currentTimeMillis() - startTime;
   logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);
}

return this.context;
</code></pre><p> }
 catch (RuntimeException ex) {</p>
<pre><code>logger.error(&quot;Context initialization failed&quot;, ex);
servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
throw ex;
</code></pre><p> }
 catch (Error err) {</p>
<pre><code>logger.error(&quot;Context initialization failed&quot;, err);
servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
throw err;
</code></pre><p> }
}</p>
</li>
<li>ContextLoader#createWebApplicationContext&#xFF08;&#x521B;&#x5EFA;WebApplicationContext&#x5B9E;&#x4F8B;)</li>
<li><p>protected WebApplicationContext createWebApplicationContext(ServletContext sc) {
 Class&lt;?&gt; contextClass = determineContextClass(sc);
 if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {</p>
<pre><code>throw new ApplicationContextException(&quot;Custom context class [&quot; + contextClass.getName() +
      &quot;] is not of type [&quot; + ConfigurableWebApplicationContext.class.getName() + &quot;]&quot;);
</code></pre><p> }
 return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
}</p>
</li>
<li><p>determineContextClass</p>
</li>
<li>protected Class&lt;?&gt; determineContextClass(ServletContext servletContext) {
 String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</li>
<li>// &#x5982;&#x679C;&#x5728;web.xml&#x4E2D;&#x914D;&#x7F6E;&#x4E86;contextClass,&#x5219;&#x76F4;&#x63A5;&#x52A0;&#x8F7D;&#x8FD9;&#x4E2A;&#x7C7B;
 if (contextClassName != null) {<pre><code>try {
   return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());
}
catch (ClassNotFoundException ex) {
   throw new ApplicationContextException(
         &quot;Failed to load custom context class [&quot; + contextClassName + &quot;]&quot;, ex);
}
</code></pre> }
 else {</li>
<li><p>// &#x5426;&#x5219;&#x4F7F;&#x7528;&#x9ED8;&#x8BA4;&#x503C;</p>
<pre><code>contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());
try {
   return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());
}
catch (ClassNotFoundException ex) {
   throw new ApplicationContextException(
         &quot;Failed to load default context class [&quot; + contextClassName + &quot;]&quot;, ex);
}
</code></pre><p> }
}</p>
</li>
<li><p>&#x770B;defaultStrategies&#x662F;&#x600E;&#x4E48;&#x521D;&#x59CB;&#x5316;&#x7684;</p>
</li>
<li>static {
 // Load default strategy implementations from properties file.
 // This is currently strictly internal and not meant to be customized
 // by application developers.
 try {<pre><code>ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);
defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);
</code></pre> }
 catch (IOException ex) {<pre><code>throw new IllegalStateException(&quot;Could not load &apos;ContextLoader.properties&apos;: &quot; + ex.getMessage());
</code></pre> }
}</li>
</ul>
<pre><code>private static final String DEFAULT_STRATEGIES_PATH = &quot;ContextLoader.properties&quot;;
</code></pre><ul>
<li>&#x5728;ContextLoader&#x76EE;&#x5F55;&#x4E0B;&#x6709;&#x4E00;&#x4E2A;&#x914D;&#x7F6E;&#x6587;&#x4EF6;ContextLoader.properties</li>
<li>&#x5185;&#x5BB9;&#x4E3A;&#xFF1A;</li>
<li><p>org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext</p>
</li>
<li><p>&#x5728;&#x521D;&#x59CB;&#x5316;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x7A0B;&#x5E8F;&#x9996;&#x5148;&#x4F1A;&#x8BFB;&#x53D6;ContextLoader&#x7C7B;&#x7684;&#x540C;&#x76EE;&#x5F55;&#x4E0B;&#x7684;&#x914D;&#x7F6E;&#x6587;&#x4EF6;ContextLoader.properties&#xFF0C;&#x5E76;&#x6839;&#x636E;&#x5176;&#x4E2D;&#x7684;&#x914D;&#x7F6E;&#x63D0;&#x53D6;&#x5C06;&#x8981;&#x5B9E;&#x73B0;WebApplicationContext&#x63A5;&#x53E3;&#x7684;&#x5B9E;&#x73B0;&#x7C7B;&#xFF0C;&#x5E76;&#x6839;&#x636E;&#x8FD9;&#x4E2A;&#x5B9E;&#x73B0;&#x7C7B;&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x7684;&#x65B9;&#x5F0F;&#x8FDB;&#x884C;&#x5B9E;&#x4F8B;&#x7684;&#x521B;&#x5EFA;&#x3002;</p>
</li>
<li></li>
<li><p>&#x521D;&#x59CB;&#x5316;DispatcherServlet</p>
</li>
<li>&#x7B2C;&#x4E00;&#x6B21;&#x8BBF;&#x95EE;&#x7F51;&#x7AD9;&#x65F6;&#xFF0C;&#x4F1A;&#x521D;&#x59CB;&#x5316;&#x8BBF;&#x95EE;&#x5230;&#x7684;servlet&#x3002;</li>
<li>&#x521D;&#x59CB;&#x5316;&#x9636;&#x6BB5;&#x4F1A;&#x8C03;&#x7528;servlet&#x7684;init&#x65B9;&#x6CD5;&#xFF0C;&#x5728;DispatcherServlet&#x4E2D;&#x662F;&#x7531;&#x5176;&#x7236;&#x7C7B;HttpServletBean&#x5B9E;&#x73B0;&#x7684;&#x3002;</li>
<li>&#x903B;&#x8F91;&#xFF1A;<ul>
<li>1)&#x5C01;&#x88C5;&#x53CA;&#x9A8C;&#x8BC1;&#x521D;&#x59CB;&#x5316;&#x53C2;&#x6570; &#x89E3;&#x6790;init-param&#x5E76;&#x5C01;&#x88C5;&#x5230;PropertyValues&#x4E2D;</li>
<li>2)&#x5C06;DispatcherServlet&#x8F6C;&#x5316;&#x4E3A;BeanWrapper&#x5B9E;&#x4F8B;</li>
<li>3)&#x6CE8;&#x518C;&#x76F8;&#x5BF9;&#x4E8E;Resource&#x7684;&#x5C5E;&#x6027;&#x7F16;&#x8F91;&#x5668;</li>
<li>4)PropertyValues&#x5C5E;&#x6027;&#x6CE8;&#x5165;</li>
<li>5)servletBean&#x7684;&#x521D;&#x59CB;&#x5316;&#xFF08;initServletBean)</li>
</ul>
</li>
</ul>
<pre><code>public final void init() throws ServletException {
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Initializing servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);
   }

   // Set bean properties from init parameters.
   try {
</code></pre><ul>
<li>// &#x89E3;&#x6790;init-param&#x5E76;&#x5C01;&#x88C5;&#x5230;PropertyValues&#x4E2D;<pre><code>PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
</code></pre></li>
<li>// &#x628A;DispatcherServlet&#x8F6C;&#x5316;&#x4E3A;&#x4E00;&#x4E2A;BeanWrapper&#xFF0C;&#x4ECE;&#x800C;&#x80FD;&#x591F;&#x4EE5;Spring&#x7684;&#x65B9;&#x5F0F;&#x6765;&#x5BF9;init-param&#x7684;&#x503C;&#x8FDB;&#x884C;&#x6CE8;&#x5165;<pre><code>BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());
</code></pre></li>
<li>// &#x8BBE;&#x7F6E;&#x81EA;&#x5B9A;&#x4E49;&#x5C5E;&#x6027;&#x7F16;&#x8F91;&#x5668;&#xFF0C;&#x5982;&#x679C;&#x9047;&#x5230;Resource&#x7C7B;&#x578B;&#x7684;&#x5C5E;&#x6027;&#x5C06;&#x4F1A;&#x4F7F;&#x7528;ResourceEditor&#x8FDB;&#x884C;&#x89E3;&#x6790;<pre><code>bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));
</code></pre></li>
<li>// &#x7A7A;&#x5B9E;&#x73B0;&#xFF0C;&#x7559;&#x7ED9;&#x5B50;&#x7C7B;&#x8986;&#x76D6;<pre><code>initBeanWrapper(bw);
</code></pre></li>
<li><p>// &#x5C5E;&#x6027;&#x6CE8;&#x5165;</p>
<pre><code>bw.setPropertyValues(pvs, true);
</code></pre><p> }
 catch (BeansException ex) {</p>
<pre><code>if (logger.isErrorEnabled()) {
   logger.error(&quot;Failed to set bean properties on servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex);
}
throw ex;
</code></pre><p> }</p>
<p> // Let subclasses do whatever initialization they like.</p>
</li>
<li><p>// &#x7559;&#x7ED9;&#x5B50;&#x7C7B;&#x6269;&#x5C55;
 initServletBean();</p>
<p> if (logger.isDebugEnabled()) {</p>
<pre><code>logger.debug(&quot;Servlet &apos;&quot; + getServletName() + &quot;&apos; configured successfully&quot;);
</code></pre><p> }
}</p>
<ul>
<li>1)ServletConfigPropertyValues&#xFF08;&#x5C01;&#x88C5;init-param)</li>
</ul>
</li>
</ul>
<pre><code>private static class ServletConfigPropertyValues extends MutablePropertyValues {

   /**
    * Create new ServletConfigPropertyValues.
    * @param config ServletConfig we&apos;ll use to take PropertyValues from
    * @param requiredProperties set of property names we need, where
    * we can&apos;t accept default values
    * @throws ServletException if any required properties are missing
    */
   public ServletConfigPropertyValues(ServletConfig config, Set&lt;String&gt; requiredProperties)
      throws ServletException {

      Set&lt;String&gt; missingProps = (requiredProperties != null &amp;&amp; !requiredProperties.isEmpty() ?
            new HashSet&lt;String&gt;(requiredProperties) : null);

      Enumeration&lt;String&gt; paramNames = config.getInitParameterNames();
      while (paramNames.hasMoreElements()) {
         String property = paramNames.nextElement();
         Object value = config.getInitParameter(property);
         addPropertyValue(new PropertyValue(property, value));
         if (missingProps != null) {
            missingProps.remove(property);
         }
      }

      // Fail if we are still missing properties.
      if (!CollectionUtils.isEmpty(missingProps)) {
         throw new ServletException(
            &quot;Initialization from ServletConfig for servlet &apos;&quot; + config.getServletName() +
            &quot;&apos; failed; the following required properties were missing: &quot; +
            StringUtils.collectionToDelimitedString(missingProps, &quot;, &quot;));
      }
   }
}
</code></pre><pre><code>- 2)FrameworkServlet#initServletBean&#xFF08;&#x5BF9;WebApplicationContext&#x5B9E;&#x4F8B;&#x8865;&#x5145;&#x521D;&#x59CB;&#x5316;)
</code></pre><ul>
<li><p>protected final void initServletBean() throws ServletException {
 getServletContext().log(&quot;Initializing Spring FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);
 if (this.logger.isInfoEnabled()) {</p>
<pre><code>this.logger.info(&quot;FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;: initialization started&quot;);
</code></pre><p> }
 long startTime = System.currentTimeMillis();</p>
<p> try {</p>
<pre><code>this.webApplicationContext = initWebApplicationContext();
</code></pre></li>
<li><p>// &#x7559;&#x7ED9;&#x5B50;&#x7C7B;&#x8986;&#x76D6;</p>
<pre><code>initFrameworkServlet();
</code></pre><p> }
 catch (ServletException ex) {</p>
<pre><code>this.logger.error(&quot;Context initialization failed&quot;, ex);
throw ex;
</code></pre><p> }
 catch (RuntimeException ex) {</p>
<pre><code>this.logger.error(&quot;Context initialization failed&quot;, ex);
throw ex;
</code></pre><p> }</p>
<p> if (this.logger.isInfoEnabled()) {</p>
<pre><code>long elapsedTime = System.currentTimeMillis() - startTime;
this.logger.info(&quot;FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;: initialization completed in &quot; +
      elapsedTime + &quot; ms&quot;);
</code></pre><p> }
}</p>
<ul>
<li>2.1)FrameworkServlet#initWebApplicationContext</li>
</ul>
</li>
<li><p>&#x521B;&#x5EFA;&#x6216;&#x5237;&#x65B0;WebApplicationContext&#x5B9E;&#x4F8B;&#xFF0C;&#x5E76;&#x5BF9;servlet&#x529F;&#x80FD;&#x6240;&#x4F7F;&#x7528;&#x7684;&#x53D8;&#x91CF;&#x8FDB;&#x884C;&#x521D;&#x59CB;&#x5316;</p>
</li>
<li><p>&#x903B;&#x8F91;&#xFF1A;</p>
<ul>
<li>1)&#x5BFB;&#x627E;&#x6216;&#x521B;&#x5EFA;&#x5BF9;&#x5E94;&#x7684;WebApplicationContext&#x5B9E;&#x4F8B;</li>
</ul>
</li>
<li>&#x901A;&#x8FC7;&#x6784;&#x9020;&#x51FD;&#x6570;&#x7684;&#x6CE8;&#x5165;&#x8FDB;&#x884C;&#x521D;&#x59CB;&#x5316;</li>
<li>&#x901A;&#x8FC7;contextAttribute&#x8FDB;&#x884C;&#x521D;&#x59CB;&#x5316;</li>
<li>&#x901A;&#x8FC7;&#x5728;web.xml&#x4E2D;&#x914D;&#x7F6E;&#x7684;servlet&#x53C2;&#x6570;contextAttribute&#x6765;&#x67E5;&#x627E;ServletContext&#x4E2D;&#x5BF9;&#x5E94;&#x7684;&#x5C5E;&#x6027;&#xFF0C;&#x9ED8;&#x8BA4;&#x4E3A;WebApplicationContext.class.getName() + &#x201C;.ROOT&#x201D;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x5728;ContextLoaderListener&#x52A0;&#x8F7D;&#x65F6;&#x4F1A;&#x521B;&#x5EFA;WebApplicationContext&#x5B9E;&#x4F8B;&#xFF0C;&#x5E76;&#x5C06;&#x5B9E;&#x4F8B;&#x4EE5;</li>
<li>WebApplicationContext.class.getName() + &#x201C;.ROOT&#x201D;&#x4E3A;key&#x653E;&#x5165;ServletContext&#x4E2D;&#x3002;</li>
<li>&#x91CD;&#x65B0;&#x521B;&#x5EFA;WebApplicationContext&#x5B9E;&#x4F8B;<ul>
<li>2)&#x5BF9;&#x5DF2;&#x7ECF;&#x521B;&#x5EFA;&#x7684;WebApplicationContext&#x5B9E;&#x4F8B;&#x8FDB;&#x884C;&#x914D;&#x7F6E;&#x548C;&#x5237;&#x65B0;</li>
<li>3)&#x5237;&#x65B0;Spring&#x5728;Web&#x529F;&#x80FD;&#x5B9E;&#x73B0;&#x4E2D;&#x5FC5;&#x987B;&#x4F7F;&#x7528;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;</li>
</ul>
</li>
<li><p>protected WebApplicationContext initWebApplicationContext() {
 WebApplicationContext rootContext =</p>
<pre><code>   WebApplicationContextUtils.getWebApplicationContext(getServletContext());
</code></pre><p> WebApplicationContext wac = null;</p>
<p> if (this.webApplicationContext != null) {</p>
</li>
<li>// applicationContext&#x5B9E;&#x4F8B;&#x5728;&#x6784;&#x9020;&#x51FD;&#x6570;&#x4E2D;&#x88AB;&#x6CE8;&#x5165;<pre><code>// A context instance was injected at construction time -&gt; use it
wac = this.webApplicationContext;
if (wac instanceof ConfigurableWebApplicationContext) {
   ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
   if (!cwac.isActive()) {
      // The context has not yet been refreshed -&gt; provide services such as
      // setting the parent context, setting the application context id, etc
      if (cwac.getParent() == null) {
         // The context instance was injected without an explicit parent -&gt; set
         // the root application context (if any; may be null) as the parent
         cwac.setParent(rootContext);
      }
</code></pre></li>
<li>// &#x5237;&#x65B0;&#x4E0A;&#x4E0B;&#x6587;&#x73AF;&#x5883;<pre><code>      configureAndRefreshWebApplicationContext(cwac);
   }
}
</code></pre> }
 if (wac == null) {<pre><code>// No context instance was injected at construction time -&gt; see if one
// has been registered in the servlet context. If one exists, it is assumed
// that the parent context (if any) has already been set and that the
// user has performed any initialization such as setting the context id
</code></pre></li>
<li>// &#x6839;&#x636E;contextAttribute&#x5C5E;&#x6027;&#x52A0;&#x8F7D;WebApplicationContext 
wac = findWebApplicationContext();
}
if (wac == null) {
// No context instance is defined for this servlet -&gt; create a local one </li>
<li><p>// &#x91CD;&#x65B0;&#x521B;&#x5EFA;WebApplicationContext</p>
<pre><code>wac = createWebApplicationContext(rootContext);
</code></pre><p> }</p>
<p> if (!this.refreshEventReceived) {</p>
<pre><code>// Either the context is not a ConfigurableApplicationContext with refresh
// support or the context injected at construction time had already been
// refreshed -&gt; trigger initial onRefresh manually here.
</code></pre></li>
<li><p>// &#x5237;&#x65B0;Spring&#x5728;web&#x529F;&#x80FD;&#x5B9E;&#x73B0;&#x4E2D;&#x5FC5;&#x987B;&#x4F7F;&#x7528;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;</p>
<pre><code>onRefresh(wac);
</code></pre><p> }</p>
<p> if (this.publishContext) {</p>
<pre><code>// Publish the context as a servlet context attribute.
String attrName = getServletContextAttributeName();
getServletContext().setAttribute(attrName, wac);
if (this.logger.isDebugEnabled()) {
   this.logger.debug(&quot;Published WebApplicationContext of servlet &apos;&quot; + getServletName() +
         &quot;&apos; as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;);
}
</code></pre><p> }</p>
<p> return wac;
}</p>
<ul>
<li>2.1.1) &#xFF08;&#x4E0E;IOC&#x8854;&#x63A5;)configureAndRefreshWebApplicationContext</li>
</ul>
</li>
<li><p>protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {
 if (ObjectUtils.identityToString(wac).equals(wac.getId())) {</p>
<pre><code>// The application context id is still set to its original default value
// -&gt; assign a more useful id based on available information
if (this.contextId != null) {
   wac.setId(this.contextId);
}
else {
   // Generate default id...
   wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
         ObjectUtils.getDisplayString(getServletContext().getContextPath()) + &apos;/&apos; + getServletName());
}
</code></pre><p> }</p>
<p> wac.setServletContext(getServletContext());
 wac.setServletConfig(getServletConfig());
 wac.setNamespace(getNamespace());
 wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));</p>
<p> // The wac environment&apos;s #initPropertySources will be called in any case when the context
 // is refreshed; do it eagerly here to ensure servlet property sources are in place for
 // use in any post-processing or initialization that occurs below prior to #refresh
 ConfigurableEnvironment env = wac.getEnvironment();
 if (env instanceof ConfigurableWebEnvironment) {</p>
<pre><code>((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());
</code></pre><p> }</p>
<p> postProcessWebApplicationContext(wac);
 applyInitializers(wac);</p>
</li>
<li><p>// &#x52A0;&#x8F7D;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4EE5;&#x53CA;&#x6574;&#x5408;parent&#x5230;wac&#xFF08;&#x5C31;&#x662F;ApplicationContext&#x4E2D;&#x7684;refresh&#x65B9;&#x6CD5;)
 wac.refresh();
}</p>
<ul>
<li>2.1.2) findWebApplicationContext</li>
</ul>
</li>
<li><p>protected WebApplicationContext findWebApplicationContext() {
 String attrName = getContextAttribute();
 if (attrName == null) {</p>
<pre><code>return null;
</code></pre><p> }
 WebApplicationContext wac =         WebApplicationContextUtils.getWebApplicationContext(getServletContext(), attrName);
 if (wac == null) {</p>
<pre><code>throw new IllegalStateException(&quot;No WebApplicationContext found: initializer not registered?&quot;);
</code></pre><p> }
 return wac;
}</p>
<ul>
<li>2.1.3) FrameworkServlet#createWebApplicationContext</li>
</ul>
</li>
<li>protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) {</li>
<li>// &#x83B7;&#x53D6;servlet&#x7684;&#x521D;&#x59CB;&#x5316;&#x53C2;&#x6570;contextClass&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x914D;&#x7F6E;&#x9ED8;&#x8BA4;&#x4E3A;XMLWebApplicationContext.class
 Class&lt;?&gt; contextClass = getContextClass();
 if (this.logger.isDebugEnabled()) {<pre><code>this.logger.debug(&quot;Servlet with name &apos;&quot; + getServletName() +
      &quot;&apos; will try to create custom WebApplicationContext context of class &apos;&quot; +
      contextClass.getName() + &quot;&apos;&quot; + &quot;, using parent context [&quot; + parent + &quot;]&quot;);
</code></pre> }
 if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {<pre><code>throw new ApplicationContextException(
      &quot;Fatal initialization error in servlet with name &apos;&quot; + getServletName() +
      &quot;&apos;: custom WebApplicationContext class [&quot; + contextClass.getName() +
      &quot;] is not of type ConfigurableWebApplicationContext&quot;);
</code></pre> }</li>
<li><p>// &#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x5B9E;&#x4F8B;&#x5316;contextClass
 ConfigurableWebApplicationContext wac =</p>
<pre><code>   (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
</code></pre><p> wac.setEnvironment(getEnvironment());</p>
</li>
<li><p>// parent&#x4E3A;&#x5728;ContextLoaderListener&#x4E2D;&#x521B;&#x5EFA;&#x7684;&#x5B9E;&#x4F8B;
 wac.setParent(parent);</p>
<ul>
<li><p>// &#x83B7;&#x53D6;contextConfigLocation&#x5C5E;&#x6027;&#xFF0C;&#x914D;&#x7F6E;&#x5728;servlet&#x521D;&#x59CB;&#x5316;&#x53C2;&#x6570;&#x4E2D;
wac.setConfigLocation(getContextConfigLocation());
// &#x521D;&#x59CB;&#x5316;Spring&#x73AF;&#x5883;&#x5305;&#x62EC;&#x52A0;&#x8F7D;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x7B49;&#xFF08;&#x5373;&#x4E3A;2.1.1)
configureAndRefreshWebApplicationContext(wac);</p>
<p>return wac;
}</p>
</li>
<li><p>2.1.4) DispatcherServlet#onRefresh</p>
</li>
</ul>
</li>
<li><p>protected void onRefresh(ApplicationContext context) {
 initStrategies(context);
}</p>
</li>
<li><p>HandlerMapping&#xFF1A;&#x8BF7;&#x6C42;&#x548C;&#x5904;&#x7406;&#x5668;&#x4E4B;&#x95F4;&#x7684;&#x6620;&#x5C04;&#xFF0C;&#x7528;&#x4E8E;&#x83B7;&#x53D6;HandlerExecutionChain</p>
</li>
<li>HandlerAdapter&#xFF1A;&#x5B9E;&#x9645;&#x7684;&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x5668;&#xFF0C;&#x5904;&#x7406;&#x540E;&#x8FD4;&#x56DE;ModelAndView</li>
<li>HandlerExceptionResolver&#xFF1A;&#x5F02;&#x5E38;&#x5904;&#x7406;&#x5668;&#xFF0C;&#x5F53;&#x62E6;&#x622A;&#x5668;&#x7684;postHandle&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x540E;&#x68C0;&#x67E5;&#x5F02;&#x5E38;&#x3002;</li>
<li><p>ViewResolver&#xFF1A;&#x89C6;&#x56FE;&#x89E3;&#x6790;&#x5668;,&#x89E3;&#x6790;&#x89C6;&#x56FE;&#x540D;&#xFF0C;&#x5F97;&#x5230;View&#xFF0C;&#x7531;&#x903B;&#x8F91;&#x89C6;&#x56FE;&#x53D8;&#x4E3A;&#x7269;&#x7406;&#x89C6;&#x56FE;&#x3002;</p>
</li>
<li><p>protected void initStrategies(ApplicationContext context) {</p>
</li>
<li>// &#x521D;&#x59CB;&#x5316;&#x6587;&#x4EF6;&#x4E0A;&#x4F20;&#x6A21;&#x5757;
 initMultipartResolver(context);</li>
<li>// &#x521D;&#x59CB;&#x5316;&#x56FD;&#x9645;&#x5316;&#x6A21;&#x5757;
 initLocaleResolver(context);</li>
<li>// &#x521D;&#x59CB;&#x5316;&#x4E3B;&#x9898;&#x6A21;&#x5757;
 initThemeResolver(context);</li>
<li>// &#x521D;&#x59CB;&#x5316;HandlerMappings
 initHandlerMappings(context);</li>
<li>// &#x521D;&#x59CB;&#x5316;HandlerAdapters
 initHandlerAdapters(context);</li>
<li>// &#x521D;&#x59CB;&#x5316;HandlerExceptionResolvers
 initHandlerExceptionResolvers(context);
 initRequestToViewNameTranslator(context);</li>
<li><p>// &#x521D;&#x59CB;&#x5316;ViewResolvers
 initViewResolvers(context);
 initFlashMapManager(context);
}</p>
<ul>
<li>2.1.4.1) initHandlerMappings</li>
</ul>
</li>
<li>&#x5F53;&#x5BA2;&#x6237;&#x7AEF;&#x53D1;&#x51FA;Request&#x65F6;DispatcherServlet&#x4F1A;&#x5C06;Request&#x63D0;&#x4EA4;&#x7ED9;HandlerMapping&#xFF0C;&#x7136;&#x540E;HandlerMapping&#x6839;&#x636E;WebApplicationContext&#x7684;&#x914D;&#x7F6E;&#xFF0C;&#x56DE;&#x4F20;&#x7ED9;DispatcherServlet&#x76F8;&#x5E94;&#x7684;Controller&#x3002;</li>
<li><p>&#x5728;&#x57FA;&#x4E8E;SpringMVC&#x7684;web&#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x4E3A;DispatcherServlet&#x63D0;&#x4F9B;&#x591A;&#x4E2A;HandlerMapping&#x4F9B;&#x5176;&#x4F7F;&#x7528;&#x3002;DispatcherServlet&#x5728;&#x9009;&#x7528;HandlerMapping&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x5C06;&#x6839;&#x636E;&#x6211;&#x4EEC;&#x6240;&#x6307;&#x5B9A;&#x7684;&#x4E00;&#x7CFB;&#x5217;HandlerMapping&#x7684;&#x4F18;&#x5148;&#x7EA7;&#x8FDB;&#x884C;&#x6392;&#x5E8F;&#xFF0C;&#x7136;&#x540E;&#x4F18;&#x5148;&#x4F7F;&#x7528;&#x4F18;&#x5148;&#x7EA7;&#x5728;&#x524D;&#x7684;HandlerMapping&#x3002;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7684;HandlerMapping&#x80FD;&#x591F;&#x8FD4;&#x56DE;&#x53EF;&#x7528;&#x7684;Handler&#xFF0C;&#x5219;&#x4F7F;&#x7528;&#x5F53;&#x524D;&#x7684;Handler&#x8FDB;&#x884C;Web&#x8BF7;&#x6C42;&#x7684;&#x5904;&#x7406;&#xFF0C;&#x800C;&#x4E0D;&#x518D;&#x7EE7;&#x7EED;&#x8BE2;&#x95EE;&#x5176;&#x4ED6;&#x7684;HandlerMapping&#x3002;&#x5426;&#x5219;&#xFF0C;&#x5C06;&#x7EE7;&#x7EED;&#x6309;&#x7167;&#x5404;&#x4E2A;HandlerMapping&#x7684;&#x4F18;&#x5148;&#x7EA7;&#x8BE2;&#x95EE;&#xFF0C;&#x76F4;&#x5230;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x53EF;&#x7528;&#x7684;Handler&#x4E3A;&#x6B62;&#x3002;</p>
</li>
<li><p>&#x9ED8;&#x8BA4;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;SpringMVC&#x5C06;&#x52A0;&#x8F7D;&#x5F53;&#x524D;&#x7CFB;&#x7EDF;&#x4E2D;&#x6240;&#x6709;&#x5B9E;&#x73B0;&#x4E86;HandlerMapping&#x63A5;&#x53E3;&#x7684;bean&#x3002;&#x5982;&#x679C;&#x53EA;&#x671F;&#x671B;SpringMVC&#x52A0;&#x8F7D;&#x6307;&#x5B9A;&#x7684;handlerMapping&#x65F6;&#xFF0C;&#x53EF;&#x4EE5;&#x4FEE;&#x6539;web.xml&#x4E2D;&#x7684;DispatcherServlet&#x7684;&#x521D;&#x59CB;&#x53C2;&#x6570;&#xFF0C;&#x5C06;detectAllHandlerMappings&#x7684;&#x503C;&#x8BBE;&#x7F6E;&#x4E3A;false&#x3002;</p>
</li>
<li>&#x6B64;&#x65F6;&#xFF0C;SpingMVC&#x5C06;&#x67E5;&#x627E;&#x540D;&#x4E3A;handlerMapping&#x7684;bean&#xFF0C;&#x5E76;&#x4F5C;&#x4E3A;&#x5F53;&#x524D;&#x7CFB;&#x7EDF;&#x4E2D;&#x552F;&#x4E00;&#x7684;handlerMapping&#x3002;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x5B9A;&#x4E49;handlerMapping&#x7684;&#x8BDD;&#xFF0C;&#x5219;SpringMVC&#x5C06;&#x6309;&#x7167;DispatcherServlet&#x6240;&#x5728;&#x76EE;&#x5F55;&#x4E0B;&#x7684;DispatcherServlet.properties&#x4E2D;&#x6240;&#x5B9A;&#x4E49;&#x7684;&#x5185;&#x5BB9;&#x6765;&#x52A0;&#x8F7D;&#x9ED8;&#x8BA4;&#x7684;handlerMapping&#x3002;</li>
</ul>
<pre><code>private void initHandlerMappings(ApplicationContext context) {
   this.handlerMappings = null;

   if (this.detectAllHandlerMappings) {
      // Find all HandlerMappings in the ApplicationContext, including ancestor contexts.
      Map&lt;String, HandlerMapping&gt; matchingBeans =
            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);
      if (!matchingBeans.isEmpty()) {
         this.handlerMappings = new ArrayList&lt;HandlerMapping&gt;(matchingBeans.values());
         // We keep HandlerMappings in sorted order.
         AnnotationAwareOrderComparator.sort(this.handlerMappings);
      }
   }
   else {
      try {
         HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
         this.handlerMappings = Collections.singletonList(hm);
      }
      catch (NoSuchBeanDefinitionException ex) {
</code></pre><ul>
<li><p>// Ignore, we&apos;ll add a default HandlerMapping later.</p>
<pre><code>}
</code></pre><p> }</p>
<p> // Ensure we have at least one HandlerMapping, by registering
 // a default HandlerMapping if no other mappings are found.
 if (this.handlerMappings == null) {</p>
<pre><code>this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);
if (logger.isDebugEnabled()) {
   logger.debug(&quot;No HandlerMappings found in servlet &apos;&quot; + getServletName() + &quot;&apos;: using default&quot;);
}
</code></pre><p> }
}</p>
</li>
<li><p>&#x9ED8;&#x8BA4;&#x7684;handlerMappings&#x6709;</p>
</li>
<li><p>org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,  org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</p>
</li>
<li><p>getBean&#x65F6;&#x4F1A;&#x8C03;&#x7528;afterPropertiesSet</p>
</li>
</ul>
<pre><code>public void afterPropertiesSet() {
   initHandlerMethods();
}
</code></pre><ul>
<li><ul>
<li>2.1.4.1.1) AbstractHandlerMethodMapping#initHandlerMethods&#xFF08;&#x600E;&#x4E48;&#x628A;Controller&#x91CC;&#x7684;&#x5404;&#x4E2A;&#x65B9;&#x6CD5;&#x5C01;&#x88C5;&#x4E3A;HandlerMethod&#x7684;)</li>
</ul>
</li>
<li><p>protected void initHandlerMethods() {
 if (logger.isDebugEnabled()) {</p>
<pre><code>logger.debug(&quot;Looking for request mappings in application context: &quot; + getApplicationContext());
</code></pre><p> }
 String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?</p>
<pre><code>   BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :
   getApplicationContext().getBeanNamesForType(Object.class));
</code></pre><p> for (String beanName : beanNames) {</p>
<pre><code>if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {
   Class&lt;?&gt; beanType = null;
   try {
      beanType = getApplicationContext().getType(beanName);
   }
   catch (Throwable ex) {
      // An unresolvable bean type, probably from a lazy bean - let&apos;s ignore it.
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Could not resolve target class for bean with name &apos;&quot; + beanName + &quot;&apos;&quot;, ex);
      }
   }
   if (beanType != null &amp;&amp; isHandler(beanType)) {
      detectHandlerMethods(beanName);
   }
}
</code></pre><p> }
 handlerMethodsInitialized(getHandlerMethods());
}</p>
</li>
<li>&#x91CD;&#x70B9;&#xFF01;&#x51E1;&#x662F;&#x6709;Controller&#x6216;&#x8005;RequestMapping&#x6CE8;&#x89E3;&#x7684;Class&#x7C7B;&#x90FD;&#x88AB;&#x89C6;&#x4E3A;HandlerMethod&#xFF0C;&#x4E4B;&#x540E;&#x4F1A;&#x904D;&#x5386;&#x8BE5;&#x7C7B;&#x7684;Method&#x68C0;&#x67E5;&#x662F;&#x5426;&#x7B26;&#x5408;&#x8981;&#x6C42;&#x3002;</li>
<li>protected boolean isHandler(Class&lt;?&gt; beanType) {
 return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||<pre><code>   AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));
</code></pre>}<ul>
<li>2.1.4.1.1.1) detectHandlerMethods</li>
</ul>
</li>
</ul>
<pre><code>protected void detectHandlerMethods(final Object handler) {
   Class&lt;?&gt; handlerType = (handler instanceof String ?
         getApplicationContext().getType((String) handler) : handler.getClass());
   final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);

   Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,
         new MethodIntrospector.MetadataLookup&lt;T&gt;() {
            @Override
            public T inspect(Method method) {
               try {
                  return getMappingForMethod(method, userType);
               }
               catch (Throwable ex) {
                  throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; +
                        userType.getName() + &quot;]: &quot; + method, ex);
               }
            }
         });

   if (logger.isDebugEnabled()) {
      logger.debug(methods.size() + &quot; request handler methods found on &quot; + userType + &quot;: &quot; + methods);
   }
   for (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) {
      Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);
      T mapping = entry.getValue();
      registerHandlerMethod(handler, invocableMethod, mapping);
   }
}
</code></pre><pre><code>- 2.1.4.1.1.1.1) MethodIntrospector#selectMethods
</code></pre><pre><code>public static &lt;T&gt; Map&lt;Method, T&gt; selectMethods(Class&lt;?&gt; targetType, final MetadataLookup&lt;T&gt; metadataLookup) {
   final Map&lt;Method, T&gt; methodMap = new LinkedHashMap&lt;Method, T&gt;();
   Set&lt;Class&lt;?&gt;&gt; handlerTypes = new LinkedHashSet&lt;Class&lt;?&gt;&gt;();
   Class&lt;?&gt; specificHandlerType = null;

   if (!Proxy.isProxyClass(targetType)) {
      handlerTypes.add(targetType);
      specificHandlerType = targetType;
   }
   handlerTypes.addAll(Arrays.asList(targetType.getInterfaces()));

   for (Class&lt;?&gt; currentHandlerType : handlerTypes) {
      final Class&lt;?&gt; targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);

      ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {
         @Override
         public void doWith(Method method) {
            Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);
            T result = metadataLookup.inspect(specificMethod);
            if (result != null) {
               Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
               if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {
                  methodMap.put(specificMethod, result);
               }
            }
         }
      }, ReflectionUtils.USER_DECLARED_METHODS);
   }

   return methodMap;
}
</code></pre><pre><code>- 2.1.4.1.1.1.1.1) doWithMethods
</code></pre><pre><code>public static void doWithMethods(Class&lt;?&gt; clazz, MethodCallback mc, MethodFilter mf) {
   // Keep backing up the inheritance hierarchy.
   Method[] methods = getDeclaredMethods(clazz);
   for (Method method : methods) {
      if (mf != null &amp;&amp; !mf.matches(method)) {
         continue;
      }
      try {
         mc.doWith(method);
      }
      catch (IllegalAccessException ex) {
         throw new IllegalStateException(&quot;Not allowed to access method &apos;&quot; + method.getName() + &quot;&apos;: &quot; + ex);
      }
   }
   if (clazz.getSuperclass() != null) {
      doWithMethods(clazz.getSuperclass(), mc, mf);
   }
   else if (clazz.isInterface()) {
      for (Class&lt;?&gt; superIfc : clazz.getInterfaces()) {
         doWithMethods(superIfc, mc, mf);
      }
   }
}
</code></pre><pre><code>- 2.1.4.1.1.1.1.1.1) metadataLookup#inspect&#xFF08;&#x6839;&#x636E;Method&#x627E;&#x5230;RequestMapping&#x6CE8;&#x89E3;&#x4FE1;&#x606F;)
</code></pre><pre><code>public T inspect(Method method) {
   try {
      return getMappingForMethod(method, userType);
   }
   catch (Throwable ex) {
      throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; +
            userType.getName() + &quot;]: &quot; + method, ex);
   }
}
</code></pre><ul>
<li>protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {
 RequestMappingInfo info = createRequestMappingInfo(method);
 if (info != null) {<pre><code>RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);
if (typeInfo != null) {
   info = typeInfo.combine(info);
}
</code></pre> }
 return info;
}</li>
</ul>
<pre><code>private RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) {
   RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);
   RequestCondition&lt;?&gt; condition = (element instanceof Class ?
         getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));
   return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);
}
</code></pre><ul>
<li><p>protected RequestMappingInfo createRequestMappingInfo(</p>
<pre><code>RequestMapping requestMapping, RequestCondition&lt;?&gt; customCondition) {
</code></pre><p> return RequestMappingInfo</p>
<pre><code>   .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))
   .methods(requestMapping.method())
   .params(requestMapping.params())
   .headers(requestMapping.headers())
   .consumes(requestMapping.consumes())
   .produces(requestMapping.produces())
   .mappingName(requestMapping.name())
   .customCondition(customCondition)
   .options(this.config)
   .build();
</code></pre><p>}</p>
</li>
</ul>
<pre><code>- 2.1.4.1.1.1.2) registerHandlerMethod
</code></pre><ul>
<li><p>protected void registerHandlerMethod(Object handler, Method method, T mapping) {
 this.mappingRegistry.register(mapping, handler, method);
}</p>
<ul>
<li>2.1.4.1.1.1.2.1) MappingRegistry#register</li>
</ul>
</li>
</ul>
<pre><code>public void register(T mapping, Object handler, Method method) {
   this.readWriteLock.writeLock().lock();
   try {
      HandlerMethod handlerMethod = createHandlerMethod(handler, method);
      assertUniqueMethodMapping(handlerMethod, mapping);

      if (logger.isInfoEnabled()) {
         logger.info(&quot;Mapped \&quot;&quot; + mapping + &quot;\&quot; onto &quot; + handlerMethod);
      }
      this.mappingLookup.put(mapping, handlerMethod);

      List&lt;String&gt; directUrls = getDirectUrls(mapping);
      for (String url : directUrls) {
         this.urlLookup.add(url, mapping);
      }

      String name = null;
      if (getNamingStrategy() != null) {
         name = getNamingStrategy().getName(handlerMethod, mapping);
         addMappingName(name, handlerMethod);
      }

      CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);
      if (corsConfig != null) {
         this.corsLookup.put(handlerMethod, corsConfig);
      }

      this.registry.put(mapping, new MappingRegistration&lt;T&gt;(mapping, handlerMethod, directUrls, name));
   }
   finally {
      this.readWriteLock.writeLock().unlock();
   }
}
</code></pre><pre><code>- 2.1.4.1.1.1.2.1.1) AbstractHandlerMethodMapping#createHandlerMethod
</code></pre><ul>
<li>protected HandlerMethod createHandlerMethod(Object handler, Method method) {
 HandlerMethod handlerMethod;
 if (handler instanceof String) {<pre><code>String beanName = (String) handler;
handlerMethod = new HandlerMethod(beanName,
      getApplicationContext().getAutowireCapableBeanFactory(), method);
</code></pre> }
 else {<pre><code>handlerMethod = new HandlerMethod(handler, method);
</code></pre> }
 return handlerMethod;
}</li>
</ul>
<pre><code>public HandlerMethod(String beanName, BeanFactory beanFactory, Method method) {
   Assert.hasText(beanName, &quot;Bean name is required&quot;);
   Assert.notNull(beanFactory, &quot;BeanFactory is required&quot;);
   Assert.notNull(method, &quot;Method is required&quot;);
   this.bean = beanName;
   this.beanFactory = beanFactory;
   this.beanType = ClassUtils.getUserClass(beanFactory.getType(beanName));
   this.method = method;
   this.bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
</code></pre><ul>
<li>// &#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;&#x53C2;&#x6570;
 this.parameters = initMethodParameters();
 this.resolvedFromHandlerMethod = null;
}</li>
</ul>
<pre><code>private MethodParameter[] initMethodParameters() {
   int count = this.bridgedMethod.getParameterTypes().length;
   MethodParameter[] result = new MethodParameter[count];
   for (int i = 0; i &lt; count; i++) {
      HandlerMethodParameter parameter = new HandlerMethodParameter(i);
      GenericTypeResolver.resolveParameterType(parameter, this.beanType);
      result[i] = parameter;
   }
   return result;
}
</code></pre><ul>
<li><ul>
<li>2.1.4.2) initHandlerAdapters</li>
</ul>
</li>
<li>detectAllHandlerAdapters&#x8FD9;&#x4E2A;&#x53D8;&#x91CF;&#x548C;detectAllHandlerMappings&#x4F5C;&#x7528;&#x5DEE;&#x4E0D;&#x591A;&#x3002;</li>
</ul>
<pre><code>private void initHandlerAdapters(ApplicationContext context) {
   this.handlerAdapters = null;

   if (this.detectAllHandlerAdapters) {
      // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.
      Map&lt;String, HandlerAdapter&gt; matchingBeans =
            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);
      if (!matchingBeans.isEmpty()) {
         this.handlerAdapters = new ArrayList&lt;HandlerAdapter&gt;(matchingBeans.values());
         // We keep HandlerAdapters in sorted order.
         AnnotationAwareOrderComparator.sort(this.handlerAdapters);
      }
   }
   else {
      try {
         HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);
         this.handlerAdapters = Collections.singletonList(ha);
      }
      catch (NoSuchBeanDefinitionException ex) {
         // Ignore, we&apos;ll add a default HandlerAdapter later.
      }
   }

   // Ensure we have at least some HandlerAdapters, by registering
   // default HandlerAdapters if no other adapters are found.
   if (this.handlerAdapters == null) {
      this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;No HandlerAdapters found in servlet &apos;&quot; + getServletName() + &quot;&apos;: using default&quot;);
      }
   }
}
</code></pre><ul>
<li>getDefaultStrategies(context, HandlerAdapter.class)</li>
<li>defaultStrategies&#x662F;&#x4ECE;&#x914D;&#x7F6E;&#x6587;&#x4EF6;DispatcherServlet.properties&#x4E2D;&#x52A0;&#x8F7D;&#x5F97;&#x5230;&#x7684;&#x3002;</li>
<li>&#x9ED8;&#x8BA4;&#x6709;&#x4EE5;&#x4E0B;HandlerAdapter&#xFF1A;</li>
<li><p>org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,   org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,   org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</p>
</li>
<li><p>protected <t> List<t> getDefaultStrategies(ApplicationContext context, Class<t> strategyInterface) {
 String key = strategyInterface.getName();
 String value = defaultStrategies.getProperty(key);
 if (value != null) {</t></t></t></p>
<pre><code>String[] classNames = StringUtils.commaDelimitedListToStringArray(value);
List&lt;T&gt; strategies = new ArrayList&lt;T&gt;(classNames.length);
for (String className : classNames) {
   try {
      Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());
      Object strategy = createDefaultStrategy(context, clazz);
      strategies.add((T) strategy);
   }
   catch (ClassNotFoundException ex) {
      throw new BeanInitializationException(
            &quot;Could not find DispatcherServlet&apos;s default strategy class [&quot; + className +
                  &quot;] for interface [&quot; + key + &quot;]&quot;, ex);
   }
   catch (LinkageError err) {
      throw new BeanInitializationException(
            &quot;Error loading DispatcherServlet&apos;s default strategy class [&quot; + className +
                  &quot;] for interface [&quot; + key + &quot;]: problem with class file or dependent class&quot;, err);
   }
}
return strategies;
</code></pre><p> }
 else {</p>
<pre><code>return new LinkedList&lt;T&gt;();
</code></pre><p> }
}</p>
</li>
<li><p>HttpRequestHandlerAdapter&#xFF08;HTTP&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x5668;&#x9002;&#x914D;&#x5668;)</p>
</li>
<li><p>&#x4EC5;&#x4EC5;&#x652F;&#x6301;&#x5BF9;HTTP&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x5668;&#x7684;&#x9002;&#x914D;&#xFF0C;&#x5B83;&#x7B80;&#x5355;&#x5730;&#x5C06;HTTP&#x8BF7;&#x6C42;&#x548C;&#x54CD;&#x5E94;&#x5BF9;&#x8C61;&#x4F20;&#x9012;&#x7ED9;HTTP&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x5668;&#x7684;&#x5B9E;&#x73B0;&#xFF0C;&#x5E76;&#x4E0D;&#x9700;&#x8981;&#x8FD4;&#x56DE;&#x503C;&#xFF0C;&#x4E3B;&#x8981;&#x5E94;&#x7528;&#x5728;&#x57FA;&#x4E8E;HTTP&#x7684;&#x8FDC;&#x7A0B;&#x8C03;&#x7528;&#x7684;&#x5B9E;&#x73B0;&#x4E0A;&#x3002;</p>
</li>
<li><p>SimpleControllerHandlerAdapter&#xFF08;&#x7B80;&#x5355;&#x63A7;&#x5236;&#x5668;&#x5904;&#x7406;&#x5668;&#x9002;&#x914D;&#x5668;)</p>
</li>
<li>&#x8FD9;&#x4E2A;&#x5B9E;&#x73B0;&#x7C7B;&#x5C06;HTTP&#x8BF7;&#x6C42;&#x9002;&#x914D;&#x5230;&#x4E00;&#x4E2A;Controller&#x7684;&#x5B9E;&#x73B0;&#x8FDB;&#x884C;&#x5904;&#x7406;&#x3002;&#x8FD9;&#x91CC;&#x63A7;&#x5236;&#x5668;&#x7684;&#x5B9E;&#x73B0;&#x662F;&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;Controller&#x63A5;&#x53E3;&#x7684;&#x5B9E;&#x73B0;&#x3002;SimpleControllerHandlerAdapter &#x88AB;&#x8BBE;&#x8BA1;&#x6210;&#x4E00;&#x4E2A;&#x6846;&#x67B6;&#x7C7B;&#x7684;&#x5B9E;&#x73B0;&#xFF0C;&#x4E0D;&#x9700;&#x8981;&#x88AB;&#x6539;&#x5199;&#xFF0C;&#x5BA2;&#x6237;&#x5316;&#x7684;&#x4E1A;&#x52A1;&#x903B;&#x8F91;&#x901A;&#x5E38;&#x662F;&#x5728;Controller&#x63A5;&#x53E3;&#x7684;&#x5B9E;&#x73B0;&#x7C7B;&#x4E2D;&#x5B9E;&#x73B0;&#x7684;&#x3002;</li>
<li>AnnotationMethodHandlerAdapter&#xFF08;&#x6CE8;&#x89E3;&#x65B9;&#x6CD5;&#x5904;&#x7406;&#x5668;&#x9002;&#x914D;&#x5668;)</li>
<li>&#x8FD9;&#x4E2A;&#x7C7B;&#x7684;&#x5B9E;&#x73B0;&#x662F;&#x57FA;&#x4E8E;&#x6CE8;&#x89E3;&#x7684;&#x5B9E;&#x73B0;&#xFF0C;&#x5B83;&#x9700;&#x8981;&#x7ED3;&#x5408;&#x6CE8;&#x89E3;&#x65B9;&#x6CD5;&#x6620;&#x5C04;&#x548C;&#x6CE8;&#x89E3;&#x65B9;&#x6CD5;&#x5904;&#x7406;&#x5668;&#x534F;&#x540C;&#x5DE5;&#x4F5C;&#x3002;&#x5B83;&#x901A;&#x8FC7;&#x89E3;&#x6790;&#x58F0;&#x660E;&#x5728;&#x6CE8;&#x89E3;&#x63A7;&#x5236;&#x5668;&#x7684;&#x8BF7;&#x6C42;&#x6620;&#x5C04;&#x4FE1;&#x606F;&#x6765;&#x89E3;&#x6790;&#x76F8;&#x5E94;&#x7684;&#x5904;&#x7406;&#x5668;&#x65B9;&#x6CD5;&#x6765;&#x5904;&#x7406;&#x5F53;&#x524D;&#x7684;HTTP&#x8BF7;&#x6C42;&#x3002;</li>
<li><p>&#x5728;&#x5904;&#x7406;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x5B83;&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x6765;&#x53D1;&#x73B0;&#x63A2;&#x6D4B;&#x5904;&#x7406;&#x5668;&#x65B9;&#x6CD5;&#x7684;&#x53C2;&#x6570;&#xFF0C;&#x8C03;&#x7528;&#x5904;&#x7406;&#x5668;&#x65B9;&#x6CD5;&#xFF0C;&#x5E76;&#x4E14;&#x6620;&#x5C04;&#x8FD4;&#x56DE;&#x503C;&#x5230;&#x6A21;&#x578B;&#x548C;&#x63A7;&#x5236;&#x5668;&#x5BF9;&#x8C61;&#xFF0C;&#x6700;&#x540E;&#x8FD4;&#x56DE;&#x6A21;&#x578B;&#x548C;&#x63A7;&#x5236;&#x5668;&#x5BF9;&#x8C61;&#x7ED9;DispatcherServlet&#x3002;</p>
</li>
<li><p>RequestMappingHandlerAdapter&#xFF08;&#x8BF7;&#x6C42;&#x6620;&#x5C04;&#x5904;&#x7406;&#x5668;&#x9002;&#x914D;&#x5668;)</p>
</li>
<li>&#x521D;&#x59CB;&#x5316;&#x8BE5;Adapter&#x65F6;&#x521D;&#x59CB;&#x5316;&#x4E00;&#x4E9B;&#x89E3;&#x6790;&#x5668;&#xFF1A;</li>
</ul>
<pre><code>public void afterPropertiesSet() {
   // Do this first, it may add ResponseBody advice beans
   initControllerAdviceCache();

   if (this.argumentResolvers == null) {
      List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();
      this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
   }
   if (this.initBinderArgumentResolvers == null) {
      List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();
      this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
   }
   if (this.returnValueHandlers == null) {
      List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();
      this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
   }
}
</code></pre><pre><code>private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() {
   List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList&lt;HandlerMethodArgumentResolver&gt;();

   // Annotation-based argument resolution
   resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false));
   resolvers.add(new RequestParamMapMethodArgumentResolver());
   resolvers.add(new PathVariableMethodArgumentResolver());
   resolvers.add(new PathVariableMapMethodArgumentResolver());
   resolvers.add(new MatrixVariableMethodArgumentResolver());
   resolvers.add(new MatrixVariableMapMethodArgumentResolver());
   resolvers.add(new ServletModelAttributeMethodProcessor(false));
   resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));
   resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice));
   resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory()));
   resolvers.add(new RequestHeaderMapMethodArgumentResolver());
   resolvers.add(new ServletCookieValueMethodArgumentResolver(getBeanFactory()));
   resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory()));
   resolvers.add(new SessionAttributeMethodArgumentResolver());
   resolvers.add(new RequestAttributeMethodArgumentResolver());

   // Type-based argument resolution
   resolvers.add(new ServletRequestMethodArgumentResolver());
   resolvers.add(new ServletResponseMethodArgumentResolver());
   resolvers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));
   resolvers.add(new RedirectAttributesMethodArgumentResolver());
   resolvers.add(new ModelMethodProcessor());
   resolvers.add(new MapMethodProcessor());
   resolvers.add(new ErrorsMethodArgumentResolver());
   resolvers.add(new SessionStatusMethodArgumentResolver());
   resolvers.add(new UriComponentsBuilderMethodArgumentResolver());

   // Custom arguments
   if (getCustomArgumentResolvers() != null) {
      resolvers.addAll(getCustomArgumentResolvers());
   }

   // Catch-all
   resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));
   resolvers.add(new ServletModelAttributeMethodProcessor(true));

   return resolvers;
}
</code></pre><ul>
<li>Spring&#x4E2D;&#x6240;&#x4F7F;&#x7528;&#x7684;Handler&#x5E76;&#x6CA1;&#x6709;&#x4EFB;&#x4F55;&#x7279;&#x6B8A;&#x7684;&#x8054;&#x7CFB;&#xFF0C;&#x4E3A;&#x4E86;&#x7EDF;&#x4E00;&#x5904;&#x7406;&#xFF0C;Spring&#x63D0;&#x4F9B;&#x4E86;&#x4E0D;&#x540C;&#x60C5;&#x51B5;&#x4E0B;&#x7684;&#x9002;&#x914D;&#x5668;&#x3002;<ul>
<li>2.1.4.3) initHandlerExceptionResolvers</li>
</ul>
</li>
<li>HanlderExceptionResolver&#x662F;&#x53EF;&#x4EE5;&#x88AB;&#x7528;&#x6237;&#x5B9A;&#x5236;&#x7684;&#xFF0C;&#x53EA;&#x8981;&#x5B9E;&#x73B0;&#x8BE5;&#x63A5;&#x53E3;&#xFF0C;&#x5B9E;&#x73B0;resolveException&#x65B9;&#x6CD5;&#x5E76;&#x5B9A;&#x4E49;&#x4E3A;&#x4E00;&#x4E2A;bean&#x5373;&#x53EF;&#x3002;</li>
<li>resolveException&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;ModelAndView&#x5BF9;&#x8C61;&#xFF0C;&#x5728;&#x65B9;&#x6CD5;&#x5185;&#x90E8;&#x5BF9;&#x5F02;&#x5E38;&#x7684;&#x7C7B;&#x578B;&#x8FDB;&#x884C;&#x5224;&#x65AD;&#xFF0C;&#x7136;&#x540E;&#x5C1D;&#x8BD5;&#x751F;&#x6210;&#x5BF9;&#x5E94;&#x7684;ModelAndView&#x5BF9;&#x8C61;&#xFF0C;&#x5982;&#x679C;&#x8BE5;&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;null&#xFF0C;&#x5219;Spring&#x4F1A;&#x7EE7;&#x7EED;&#x5BFB;&#x627E;&#x5176;&#x4ED6;&#x5B9E;&#x73B0;&#x4E86;HanlderExceptionResolver&#x63A5;&#x53E3;&#x7684;bean&#x3002;</li>
</ul>
<pre><code>private void initHandlerExceptionResolvers(ApplicationContext context) {
   this.handlerExceptionResolvers = null;

   if (this.detectAllHandlerExceptionResolvers) {
      // Find all HandlerExceptionResolvers in the ApplicationContext, including ancestor contexts.
      Map&lt;String, HandlerExceptionResolver&gt; matchingBeans = BeanFactoryUtils
            .beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false);
      if (!matchingBeans.isEmpty()) {
         this.handlerExceptionResolvers = new ArrayList&lt;HandlerExceptionResolver&gt;(matchingBeans.values());
         // We keep HandlerExceptionResolvers in sorted order.
         AnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers);
      }
   }
   else {
      try {
         HandlerExceptionResolver her =
               context.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);
         this.handlerExceptionResolvers = Collections.singletonList(her);
      }
      catch (NoSuchBeanDefinitionException ex) {
         // Ignore, no HandlerExceptionResolver is fine too.
      }
   }

   // Ensure we have at least some HandlerExceptionResolvers, by registering
   // default HandlerExceptionResolvers if no other resolvers are found.
   if (this.handlerExceptionResolvers == null) {
      this.handlerExceptionResolvers = getDefaultStrategies(context, HandlerExceptionResolver.class);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;No HandlerExceptionResolvers found in servlet &apos;&quot; + getServletName() + &quot;&apos;: using default&quot;);
      }
   }
}
</code></pre><pre><code>- 2.1.4.4) initRequestToViewNameTranslator
</code></pre><ul>
<li>&#x5F53;Controller&#x65B9;&#x6CD5;&#x6CA1;&#x6709;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;View&#x6216;&#x8005;&#x903B;&#x8F91;&#x89C6;&#x56FE;&#x540D;&#x79F0;&#xFF0C;&#x5E76;&#x4E14;&#x5728;&#x8BE5;&#x65B9;&#x6CD5;&#x4E2D;&#x6CA1;&#x6709;&#x76F4;&#x63A5;&#x5F80;response&#x8F93;&#x51FA;&#x6D41;&#x91CC;&#x9762;&#x5199;&#x6570;&#x636E;&#x7684;&#x65F6;&#x5019;&#xFF0C;Spring&#x5C31;&#x4F1A;&#x6309;&#x7167;&#x7EA6;&#x5B9A;&#x597D;&#x7684;&#x65B9;&#x5F0F;&#x63D0;&#x4F9B;&#x4E00;&#x4E2A;&#x903B;&#x8F91;&#x89C6;&#x56FE;&#x540D;&#x79F0;&#xFF08;&#x6700;&#x7B80;&#x7B54;&#x7684;&#x60C5;&#x51B5;&#x5C31;&#x662F;&#x52A0;prefix&#x548C;suffix)&#x3002;</li>
<li>&#x8FD9;&#x4E2A;&#x903B;&#x8F91;&#x89C6;&#x56FE;&#x540D;&#x79F0;&#x662F;&#x901A;&#x8FC7;Spring&#x5B9A;&#x4E49;&#x7684;RequestToViewNameTranslator&#x63A5;&#x53E3;&#x7684;getViewName&#x65B9;&#x6CD5;&#x6765;&#x5B9E;&#x73B0;&#x7684;&#xFF0C;&#x7528;&#x6237;&#x4E5F;&#x53EF;&#x4EE5;&#x81EA;&#x5B9A;&#x4E49;&#x81EA;&#x5DF1;&#x7684;RequestToViewNameTranslator&#x3002;</li>
<li>Spring&#x4E3A;&#x6211;&#x4EEC;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x4E2A;&#x9ED8;&#x8BA4;&#x7684;&#x5B9E;&#x73B0;DefaultRequestToViewNameTranslator&#x3002;</li>
</ul>
<pre><code>public static final String REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME = &quot;viewNameTranslator&quot;;
</code></pre><pre><code>private void initRequestToViewNameTranslator(ApplicationContext context) {
   try {
      this.viewNameTranslator =
            context.getBean(REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME, RequestToViewNameTranslator.class);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Using RequestToViewNameTranslator [&quot; + this.viewNameTranslator + &quot;]&quot;);
      }
   }
   catch (NoSuchBeanDefinitionException ex) {
      // We need to use the default.
      this.viewNameTranslator = getDefaultStrategy(context, RequestToViewNameTranslator.class);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Unable to locate RequestToViewNameTranslator with name &apos;&quot; +
               REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME + &quot;&apos;: using default [&quot; + this.viewNameTranslator +
               &quot;]&quot;);
      }
   }
}
</code></pre><pre><code>- 2.1.4.5) initViewResolvers
</code></pre><ul>
<li>&#x5F53;Controller&#x5C06;&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x7ED3;&#x679C;&#x653E;&#x5230;ModelAndView&#x4E2D;&#x4EE5;&#x540E;&#xFF0C;DispatcherServlet&#x4F1A;&#x6839;&#x636E;ModelAndView&#x9009;&#x62E9;&#x5408;&#x9002;&#x7684;&#x89C6;&#x56FE;&#x8FDB;&#x884C;&#x6E32;&#x67D3;&#x3002;ViewResolver&#x63A5;&#x53E3;&#x5B9A;&#x4E49;&#x4E86;resolveViewName&#x65B9;&#x6CD5;&#xFF0C;&#x6839;&#x636E;viewName&#x521B;&#x5EFA;&#x5408;&#x9002;&#x7C7B;&#x578B;&#x7684;View&#x5B9E;&#x73B0;&#x3002;</li>
<li>&#x53EF;&#x4EE5;&#x5728;Spring&#x7684;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x4E2D;&#x5B9A;&#x4E49;viewResolver&#x3002;</li>
</ul>
<pre><code>private void initViewResolvers(ApplicationContext context) {
   this.viewResolvers = null;

   if (this.detectAllViewResolvers) {
      // Find all ViewResolvers in the ApplicationContext, including ancestor contexts.
      Map&lt;String, ViewResolver&gt; matchingBeans =
            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, true, false);
      if (!matchingBeans.isEmpty()) {
         this.viewResolvers = new ArrayList&lt;ViewResolver&gt;(matchingBeans.values());
         // We keep ViewResolvers in sorted order.
         AnnotationAwareOrderComparator.sort(this.viewResolvers);
      }
   }
   else {
      try {
         ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);
         this.viewResolvers = Collections.singletonList(vr);
      }
      catch (NoSuchBeanDefinitionException ex) {
         // Ignore, we&apos;ll add a default ViewResolver later.
      }
   }

   // Ensure we have at least one ViewResolver, by registering
   // a default ViewResolver if no other resolvers are found.
   if (this.viewResolvers == null) {
      this.viewResolvers = getDefaultStrategies(context, ViewResolver.class);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;No ViewResolvers found in servlet &apos;&quot; + getServletName() + &quot;&apos;: using default&quot;);
      }
   }
}
</code></pre><pre><code>- 2.1.4.6) initFlashMapManager
</code></pre><ul>
<li>flash attributes&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x4E2A;&#x8BF7;&#x6C42;&#x5B58;&#x50A8;&#x5C5E;&#x6027;&#xFF0C;&#x53EF;&#x4F9B;&#x5176;&#x4ED6;&#x8BF7;&#x6C42;&#x4F7F;&#x7528;&#x3002;&#x5728;&#x4F7F;&#x7528;&#x91CD;&#x5B9A;&#x5411;&#x7684;&#x65F6;&#x5019;&#x975E;&#x5E38;&#x5FC5;&#x8981;&#x3002;</li>
<li>Spring MVC &#x6709;&#x4E24;&#x4E2A;&#x4E3B;&#x8981;&#x7684;&#x62BD;&#x8C61;&#x6765;&#x652F;&#x6301; flash attributes&#x3002; FlashMap &#x7528;&#x4E8E;&#x4FDD;&#x6301; flash attributes &#x800C; FlashMapManager&#x7528;&#x4E8E;&#x5B58;&#x50A8;&#xFF0C;&#x68C0;&#x7D22;&#xFF0C;&#x7BA1;&#x7406;FlashMap &#x5B9E;&#x4F8B;&#x3002;</li>
<li>Flash attribute &#x652F;&#x6301;&#x9ED8;&#x8BA4;&#x5F00;&#x542F;&#xFF0C;&#x5E76;&#x4E0D;&#x9700;&#x8981;&#x663E;&#x5F0F;&#x542F;&#x7528;&#xFF0C;&#x5B83;&#x6C38;&#x8FDC;&#x4E0D;&#x4F1A;&#x5BFC;&#x81F4;HTTP Session&#x7684;&#x521B;&#x5EFA;&#x3002; &#x6BCF;&#x4E00;&#x4E2A;&#x8BF7;&#x6C42;&#x90FD;&#x6709;&#x4E00;&#x4E2A; &#x201C;input&#x201D;FlashMap &#x5177;&#x6709;&#x4ECE;&#x4E0A;&#x4E00;&#x4E2A;&#x8BF7;&#x6C42;&#xFF08;&#x5982;&#x679C;&#x6709;&#x7684;&#x8BDD;)&#x4F20;&#x8FC7;&#x6765;&#x7684;&#x5C5E;&#x6027;&#x548C;&#x4E00;&#x4E2A; &#x201C;output&#x201D; FlashMap &#x5177;&#x6709;&#x5C06;&#x8981;&#x5728;&#x540E;&#x7EED;&#x8BF7;&#x6C42;&#x4E2D;&#x4FDD;&#x5B58;&#x7684;&#x5C5E;&#x6027;&#x3002; &#x8FD9;&#x4E24;&#x4E2A; FlashMap &#x5B9E;&#x4F8B;&#x90FD;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x9759;&#x6001;&#x65B9;&#x6CD5;RequestContextUtils&#x4ECE;Spring MVC&#x7684;&#x4EFB;&#x4F55;&#x4F4D;&#x7F6E;&#x8BBF;&#x95EE;&#x3002;</li>
</ul>
<pre><code>private void initFlashMapManager(ApplicationContext context) {
   try {
      this.flashMapManager = context.getBean(FLASH_MAP_MANAGER_BEAN_NAME, FlashMapManager.class);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Using FlashMapManager [&quot; + this.flashMapManager + &quot;]&quot;);
      }
   }
   catch (NoSuchBeanDefinitionException ex) {
      // We need to use the default.
      this.flashMapManager = getDefaultStrategy(context, FlashMapManager.class);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Unable to locate FlashMapManager with name &apos;&quot; +
               FLASH_MAP_MANAGER_BEAN_NAME + &quot;&apos;: using default [&quot; + this.flashMapManager + &quot;]&quot;);
      }
   }
}
</code></pre><ul>
<li></li>
<li><p>&#x5904;&#x7406;&#x8BF7;&#x6C42;</p>
</li>
<li>FrameworkServlet#service&#xFF08;&#x5165;&#x53E3;)</li>
<li>DispatcherServlet&#xFF08;FrameworkServlet&#x7684;&#x5B50;&#x7C7B;)&#x65E0;&#x8BBA;&#x662F;doGet&#x3001;doPost&#x7B49;&#x65B9;&#x6CD5;&#x90FD;&#x4F1A;&#x8C03;&#x7528;processRequest&#x65B9;&#x6CD5;&#x5904;&#x7406;&#x8BF7;&#x6C42;&#x3002;</li>
<li>FrameworkServlet#processRequest</li>
<li><p>&#x903B;&#x8F91;&#xFF1A;</p>
<ul>
<li>1)&#x4E3A;&#x4E86;&#x4FDD;&#x8BC1;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7684;LocaleContext&#x548C;RequestAttributes&#x53EF;&#x4EE5;&#x5728;&#x5F53;&#x524D;&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x5B8C;&#x6BD5;&#x540E;&#x8FD8;&#x80FD;&#x6062;&#x590D;&#xFF0C;&#x63D0;&#x53D6;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7684;&#x4E24;&#x4E2A;&#x5C5E;&#x6027;</li>
<li>2)&#x6839;&#x636E;&#x5F53;&#x524D;request&#x521B;&#x5EFA;&#x5BF9;&#x5E94;&#x7684;LocaleContext&#x548C;RequestAttributes&#xFF0C;&#x5E76;&#x7ED1;&#x5B9A;&#x5230;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;</li>
<li>3)&#x59D4;&#x6258;&#x7ED9;doService&#x65B9;&#x6CD5;&#x8FDB;&#x4E00;&#x6B65;&#x5904;&#x7406;</li>
<li>4)&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x7ED3;&#x675F;&#x540E;&#x6062;&#x590D;&#x7EBF;&#x7A0B;&#x5230;&#x539F;&#x59CB;&#x72B6;&#x6001;</li>
<li>5)&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x7ED3;&#x675F;&#x540E;&#x65E0;&#x8BBA;&#x6210;&#x529F;&#x4E0E;&#x5426;&#x90FD;&#x4F1A;&#x53D1;&#x5E03;&#x4E8B;&#x4EF6;&#x901A;&#x77E5;</li>
</ul>
</li>
<li><p>protected final void processRequest(HttpServletRequest request, HttpServletResponse response)</p>
<pre><code>throws ServletException, IOException {
</code></pre><p> long startTime = System.currentTimeMillis();
 Throwable failureCause = null;</p>
<p> LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
 LocaleContext localeContext = buildLocaleContext(request);</p>
<p> RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
 ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</p>
<p> WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
 asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());
 // &#x5C06;localeContext&#x548C;requestAttributes&#x7ED1;&#x5B9A;&#x5230;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;
 initContextHolders(request, localeContext, requestAttributes);</p>
<p> try {</p>
<pre><code>doService(request, response);
</code></pre><p> }
 catch (ServletException ex) {</p>
<pre><code>failureCause = ex;
throw ex;
</code></pre><p> }
 catch (IOException ex) {</p>
<pre><code>failureCause = ex;
throw ex;
</code></pre><p> }
 catch (Throwable ex) {</p>
<pre><code>failureCause = ex;
throw new NestedServletException(&quot;Request processing failed&quot;, ex);
</code></pre><p> }</p>
<p> finally {</p>
</li>
<li><p>// &#x6062;&#x590D;&#x7EBF;&#x7A0B;&#x5230;&#x539F;&#x59CB;&#x72B6;&#x6001;</p>
<pre><code>resetContextHolders(request, previousLocaleContext, previousAttributes);
if (requestAttributes != null) {
   requestAttributes.requestCompleted();
}

if (logger.isDebugEnabled()) {
   if (failureCause != null) {
      this.logger.debug(&quot;Could not complete request&quot;, failureCause);
   }
   else {
      if (asyncManager.isConcurrentHandlingStarted()) {
         logger.debug(&quot;Leaving response open for concurrent processing&quot;);
      }
      else {
         this.logger.debug(&quot;Successfully completed request&quot;);
      }
   }
}
// &#x53D1;&#x5E03;&#x4E8B;&#x4EF6;&#x901A;&#x77E5;
publishRequestHandledEvent(request, response, startTime, failureCause);
</code></pre><p> }
}</p>
</li>
<li><p>DispatcherServlet#doService</p>
</li>
<li>&#x5C06;&#x5DF2;&#x7ECF;&#x521D;&#x59CB;&#x5316;&#x7684;&#x529F;&#x80FD;&#x8F85;&#x52A9;&#x5DE5;&#x5177;&#x53D8;&#x91CF;&#x8BBE;&#x7F6E;&#x5728;request&#x5C5E;&#x6027;&#x4E2D;&#x3002;</li>
<li>&#x4E3B;&#x8981;&#x4E1A;&#x52A1;&#x903B;&#x8F91;&#x662F;&#x5728;doDispatch&#x65B9;&#x6CD5;&#x4E2D;&#x5904;&#x7406;&#x3002;</li>
<li><p>protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
 if (logger.isDebugEnabled()) {</p>
<pre><code>String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? &quot; resumed&quot; : &quot;&quot;;
logger.debug(&quot;DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot; + resumed +
      &quot; processing &quot; + request.getMethod() + &quot; request for [&quot; + getRequestUri(request) + &quot;]&quot;);
</code></pre><p> }</p>
<p> // Keep a snapshot of the request attributes in case of an include,
 // to be able to restore the original attributes after the include.
 Map<string, object=""> attributesSnapshot = null;
 if (WebUtils.isIncludeRequest(request)) {</string,></p>
<pre><code>attributesSnapshot = new HashMap&lt;String, Object&gt;();
Enumeration&lt;?&gt; attrNames = request.getAttributeNames();
while (attrNames.hasMoreElements()) {
   String attrName = (String) attrNames.nextElement();
   if (this.cleanupAfterInclude || attrName.startsWith(&quot;org.springframework.web.servlet&quot;)) {
      attributesSnapshot.put(attrName, request.getAttribute(attrName));
   }
}
</code></pre><p> }</p>
<p> // Make framework objects available to handlers and view objects.
 request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
 request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
 request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
 request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</p>
<p> FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
 if (inputFlashMap != null) {</p>
<pre><code>request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
</code></pre><p> }
 request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
 request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);</p>
<p> try {</p>
<pre><code>doDispatch(request, response);
</code></pre><p> }
 finally {</p>
<pre><code>if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
   // Restore the original attribute snapshot, in case of an include.
   if (attributesSnapshot != null) {
      restoreAttributesAfterInclude(request, attributesSnapshot);
   }
}
</code></pre><p> }
}</p>
</li>
<li></li>
<li><p>doDispatch&#xFF08;&#x4E3B;&#x4F53;)</p>
</li>
<li><p>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
 HttpServletRequest processedRequest = request;
 HandlerExecutionChain mappedHandler = null;
 boolean multipartRequestParsed = false;</p>
<p> WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</p>
<p> try {</p>
<pre><code>ModelAndView mv = null;
Exception dispatchException = null;

try {
</code></pre></li>
<li>// &#x5982;&#x679C;request&#x662F;MultiPartContent&#x7C7B;&#x578B;&#x7684;&#xFF0C;&#x5219;&#x5C06;&#x5176;&#x8F6C;&#x4E3A;MultiPartHttpServletRequest<pre><code>   processedRequest = checkMultipart(request);
   multipartRequestParsed = (processedRequest != request);
   // &#x6839;&#x636E;request&#x4FE1;&#x606F;&#x5BFB;&#x627E;&#x5BF9;&#x5E94;&#x7684;Handler
   mappedHandler = getHandler(processedRequest);
   if (mappedHandler == null || mappedHandler.getHandler() == null) {
</code></pre></li>
<li><p>// &#x6CA1;&#x6709;&#x627E;&#x5230;&#x5BF9;&#x5E94;&#x7684;handler&#xFF0C;&#x5219;&#x901A;&#x8FC7;response&#x53CD;&#x9988;&#x9519;&#x8BEF;&#x4FE1;&#x606F;</p>
<pre><code>      noHandlerFound(processedRequest, response);
      return;
   }
   // &#x6839;&#x636E;&#x5F53;&#x524D;&#x7684;handler&#x5BFB;&#x627E;&#x5BF9;&#x5E94;&#x7684;HandlerAdapter
   HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
   // &#x5982;&#x679C;&#x5F53;&#x524D;handler&#x652F;&#x6301;Last-Modified&#x8BF7;&#x6C42;&#x5934;&#xFF0C;&#x5219;&#x5BF9;&#x5176;&#x8FDB;&#x884C;&#x5904;&#x7406;
   // Process last-modified header, if supported by the handler.
   String method = request.getMethod();
   boolean isGet = &quot;GET&quot;.equals(method);
   if (isGet || &quot;HEAD&quot;.equals(method)) {
      long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);
      }
      if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {
         return;
      }
   }
   // &#x8C03;&#x7528;&#x62E6;&#x622A;&#x5668;&#x7684;preHandle&#x65B9;&#x6CD5;
   if (!mappedHandler.applyPreHandle(processedRequest, response)) {
      return;
   }
   // &#x8C03;&#x7528;handler&#x5E76;&#x8FD4;&#x56DE;&#x89C6;&#x56FE;
   mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

   if (asyncManager.isConcurrentHandlingStarted()) {
      return;
   }
   // &#x8F6C;&#x6362;&#x89C6;&#x56FE;&#x540D;&#x79F0;&#xFF08;&#x52A0;prefix&#x548C;suffix)
   applyDefaultViewName(processedRequest, mv);
</code></pre></li>
<li>// &#x8C03;&#x7528;&#x62E6;&#x622A;&#x5668;&#x7684;postHandle&#x65B9;&#x6CD5;<pre><code>   mappedHandler.applyPostHandle(processedRequest, response, mv);
}
catch (Exception ex) {
   dispatchException = ex;
}
catch (Throwable err) {
   // As of 4.3, we&apos;re processing Errors thrown from handler methods as well,
   // making them available for @ExceptionHandler methods and other scenarios.
   dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);
}
// &#x5904;&#x7406;handle&#x7684;&#x7ED3;&#x679C;
processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
</code></pre> }
 catch (Exception ex) {<pre><code>triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
</code></pre> }
 catch (Throwable err) {<pre><code>triggerAfterCompletion(processedRequest, response, mappedHandler,
      new NestedServletException(&quot;Handler processing failed&quot;, err));
</code></pre> }
 finally {<pre><code>if (asyncManager.isConcurrentHandlingStarted()) {
   // Instead of postHandle and afterCompletion
   if (mappedHandler != null) {
      mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
   }
}
else {
   // Clean up any resources used by a multipart request.
   if (multipartRequestParsed) {
      cleanupMultipart(processedRequest);
   }
}
</code></pre> }
}</li>
<li><ul>
<li>1) checkMultiPart&#xFF08;&#x5904;&#x7406;&#x6587;&#x4EF6;&#x4E0A;&#x4F20;&#x8BF7;&#x6C42;)</li>
</ul>
</li>
<li>protected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException {
 if (this.multipartResolver != null &amp;&amp; this.multipartResolver.isMultipart(request)) {<pre><code>if (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != null) {
   logger.debug(&quot;Request is already a MultipartHttpServletRequest - if not in a forward, &quot; +
         &quot;this typically results from an additional MultipartFilter in web.xml&quot;);
}
else if (hasMultipartException(request) ) {
   logger.debug(&quot;Multipart resolution failed for current request before - &quot; +
         &quot;skipping re-resolution for undisturbed error rendering&quot;);
}
else {
   try {
      return this.multipartResolver.resolveMultipart(request);
   }
   catch (MultipartException ex) {
      if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {
         logger.debug(&quot;Multipart resolution failed for error dispatch&quot;, ex);
         // Keep processing error dispatch with regular request handle below
      }
      else {
         throw ex;
      }
   }
}
</code></pre> }
 // If not returned before: return original request.
 return request;
}</li>
<li></li>
<li><p>MultipartResolver.resolveMultipart</p>
</li>
<li><p>MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException;</p>
<ul>
<li>2) getHandler&#xFF08;&#x83B7;&#x53D6;HandlerExecutionChain)</li>
</ul>
</li>
<li>protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
 for (HandlerMapping hm : this.handlerMappings) {<pre><code>if (logger.isTraceEnabled()) {
   logger.trace(
         &quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);
}
HandlerExecutionChain handler = hm.getHandler(request);
if (handler != null) {
   return handler;
}
</code></pre> }
 return null;
}</li>
<li>HandlerMapping.getHandler</li>
<li>HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;<ul>
<li>2.1) AbstractHandlerMapping#getHandler</li>
</ul>
</li>
</ul>
<pre><code>public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
</code></pre><ul>
<li>// &#x6839;&#x636E;request&#x83B7;&#x53D6;&#x5BF9;&#x5E94;&#x7684;handler
 Object handler = getHandlerInternal(request);
 if (handler == null) {</li>
<li>// &#x5982;&#x679C;&#x6CA1;&#x6709;&#x5BF9;&#x5E94;&#x7684;request&#x7684;handler&#x5219;&#x4F7F;&#x7528;&#x9ED8;&#x8BA4;&#x7684;handler<pre><code>handler = getDefaultHandler();
</code></pre> }</li>
<li>// &#x6CA1;&#x6709;&#x9ED8;&#x8BA4;&#x7684;handler&#x5219;&#x65E0;&#x6CD5;&#x7EE7;&#x7EED;&#x5904;&#x7406;
 if (handler == null) {<pre><code>return null;
</code></pre> }</li>
<li><p>// &#x5F53;&#x67E5;&#x627E;&#x7684;Controller&#x4E3A;String&#xFF0C;&#x5C31;&#x610F;&#x5473;&#x7740;&#x8FD4;&#x56DE;&#x7684;&#x662F;&#x914D;&#x7F6E;&#x7684;bean&#x540D;&#x79F0;&#xFF0C;&#x9700;&#x8981;&#x6839;&#x636E;bean&#x540D;&#x79F0;&#x67E5;&#x627E;&#x5BF9;&#x5E94;&#x7684;bean
 // Bean name or resolved handler?
 if (handler instanceof String) {</p>
<pre><code>String handlerName = (String) handler;
handler = getApplicationContext().getBean(handlerName);
</code></pre><p> }</p>
<p> HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);
 if (CorsUtils.isCorsRequest(request)) {</p>
<pre><code>CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request);
CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);
CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);
executionChain = getCorsHandlerExecutionChain(request, executionChain, config);
</code></pre><p> }
 return executionChain;
}</p>
</li>
<li><p>2.1.1-a) AbstractUrlHandlerMapping#getHandlerInternal</p>
</li>
<li>&#x4EE5;AbstractUrlHandlerMapping&#x4E3A;&#x4F8B;</li>
<li>protected Object getHandlerInternal(HttpServletRequest request) throws Exception {</li>
<li>// &#x622A;&#x53D6;&#x7528;&#x4E8E;&#x5339;&#x914D;url&#x7684;&#x6709;&#x6548;&#x8DEF;&#x5F84;
 String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</li>
<li>// &#x6839;&#x636E;&#x8DEF;&#x5F84;&#x5BFB;&#x627E;handler
 Object handler = lookupHandler(lookupPath, request);
 if (handler == null) {<pre><code>// We need to care for the default handler directly, since we need to
// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.
Object rawHandler = null;
if (&quot;/&quot;.equals(lookupPath)) {
</code></pre></li>
<li>// &#x5982;&#x679C;&#x8BF7;&#x6C42;&#x8DEF;&#x5F84;&#x662F;/&#xFF0C;&#x90A3;&#x4E48;&#x4F7F;&#x7528;RootHandler&#x8FDB;&#x884C;&#x5904;&#x7406;<pre><code>   rawHandler = getRootHandler();
}
if (rawHandler == null) {
</code></pre></li>
<li>// &#x5982;&#x679C;&#x65E0;&#x6CD5;&#x627E;&#x5230;handler&#xFF0C;&#x5219;&#x4F7F;&#x7528;&#x9ED8;&#x8BA4;handler<pre><code>   rawHandler = getDefaultHandler();
}
if (rawHandler != null) {
   // Bean name or resolved handler?
   if (rawHandler instanceof String) {
</code></pre></li>
<li>// &#x6839;&#x636E;beanName&#x5BFB;&#x627E;&#x5BF9;&#x5E94;&#x7684;beanName<pre><code>      String handlerName = (String) rawHandler;
      rawHandler = getApplicationContext().getBean(handlerName);
   }
   validateHandler(rawHandler, request);
   // &#x6A21;&#x677F;&#x65B9;&#x6CD5;
</code></pre></li>
<li>handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);<pre><code>}
</code></pre> }
 if (handler != null &amp;&amp; logger.isDebugEnabled()) {<pre><code>logger.debug(&quot;Mapping [&quot; + lookupPath + &quot;] to &quot; + handler);
</code></pre> }
 else if (handler == null &amp;&amp; logger.isTraceEnabled()) {<pre><code>logger.trace(&quot;No handler mapping found for [&quot; + lookupPath + &quot;]&quot;);
</code></pre> }
 return handler;
}<ul>
<li>2.1.1.1) lookupHandler</li>
</ul>
</li>
<li><p>protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception {
 // Direct match?</p>
<ul>
<li><p>// &#x76F4;&#x63A5;&#x5339;&#x914D;
Object handler = this.handlerMap.get(urlPath);
if (handler != null) {
// Bean name or resolved handler?
if (handler instanceof String) {
   String handlerName = (String) handler;
   handler = getApplicationContext().getBean(handlerName);
}
validateHandler(handler, request);
return buildPathExposingHandler(handler, urlPath, urlPath, null);
}
// &#x901A;&#x914D;&#x7B26;&#x5339;&#x914D;
// Pattern match?
List<string> matchingPatterns = new ArrayList<string>();
for (String registeredPattern : this.handlerMap.keySet()) {
if (getPathMatcher().match(registeredPattern, urlPath)) {
   matchingPatterns.add(registeredPattern);
}
else if (useTrailingSlashMatch()) {
   if (!registeredPattern.endsWith(&quot;/&quot;) &amp;&amp; getPathMatcher().match(registeredPattern + &quot;/&quot;, urlPath)) {</string></string></p>
<pre><code>  matchingPatterns.add(registeredPattern +&quot;/&quot;);
</code></pre><p>   }
}
}</p>
<p>String bestMatch = null;
Comparator<string> patternComparator = getPathMatcher().getPatternComparator(urlPath);
if (!matchingPatterns.isEmpty()) {
Collections.sort(matchingPatterns, patternComparator);
if (logger.isDebugEnabled()) {
   logger.debug(&quot;Matching patterns for request [&quot; + urlPath + &quot;] are &quot; + matchingPatterns);
}
bestMatch = matchingPatterns.get(0);
}
if (bestMatch != null) {
handler = this.handlerMap.get(bestMatch);
if (handler == null) {
   if (bestMatch.endsWith(&quot;/&quot;)) {</string></p>
<pre><code>  handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1));
</code></pre><p>   }
   if (handler == null) {</p>
<pre><code>  throw new IllegalStateException(
        &quot;Could not find handler for best pattern match [&quot; + bestMatch + &quot;]&quot;);
</code></pre><p>   }
}
// Bean name or resolved handler?
if (handler instanceof String) {
   String handlerName = (String) handler;
   handler = getApplicationContext().getBean(handlerName);
}
validateHandler(handler, request);
String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath);</p>
<p>// There might be multiple &apos;best patterns&apos;, let&apos;s make sure we have the correct URI template variables
// for all of them
Map<string, string=""> uriTemplateVariables = new LinkedHashMap<string, string="">();
for (String matchingPattern : matchingPatterns) {
   if (patternComparator.compare(bestMatch, matchingPattern) == 0) {</string,></string,></p>
<pre><code>  Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);
  Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);
  uriTemplateVariables.putAll(decodedVars);
</code></pre><p>   }
}
if (logger.isDebugEnabled()) {
   logger.debug(&quot;URI Template variables for request [&quot; + urlPath + &quot;] are &quot; + uriTemplateVariables);
}
return buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);
}</p>
<p>// No handler found...
return null;
}</p>
</li>
<li>2.1.1.1.1) buildPathExposingHandler&#xFF08;&#x5C06;handler&#x5C01;&#x88C5;&#x4E3A;HandlerExecutionChain&#xFF0C;&#x5E76;&#x6DFB;&#x52A0;&#x4E24;&#x4E2A;&#x62E6;&#x622A;&#x5668;)</li>
</ul>
</li>
<li><p>protected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern,</p>
<pre><code>String pathWithinMapping, Map&lt;String, String&gt; uriTemplateVariables) {
</code></pre><p> HandlerExecutionChain chain = new HandlerExecutionChain(rawHandler);
 chain.addInterceptor(new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));
 if (!CollectionUtils.isEmpty(uriTemplateVariables)) {</p>
<pre><code>chain.addInterceptor(new UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));
</code></pre><p> }
 return chain;
}</p>
</li>
<li>2.1.1-b) AbstractHandlerMethodMapping#getHandlerInternal&#xFF08;&#x52A0;&#x5165;&#x62E6;&#x622A;&#x5668;)</li>
<li>protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {
 String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
 if (logger.isDebugEnabled()) {<pre><code>logger.debug(&quot;Looking up handler method for path &quot; + lookupPath);
</code></pre> }
 this.mappingRegistry.acquireReadLock();
 try {<pre><code>HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);
if (logger.isDebugEnabled()) {
   if (handlerMethod != null) {
      logger.debug(&quot;Returning handler method [&quot; + handlerMethod + &quot;]&quot;);
   }
   else {
      logger.debug(&quot;Did not find handler method for [&quot; + lookupPath + &quot;]&quot;);
   }
}
return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);
</code></pre> }
 finally {<pre><code>this.mappingRegistry.releaseReadLock();
</code></pre> }
}<ul>
<li>2.1.1.1) lookupHandlerMethod</li>
</ul>
</li>
<li>protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {
 List<match> matches = new ArrayList<match>();</match></match></li>
<li>// &#x76F4;&#x63A5;&#x5339;&#x914D;
 List<t> directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);
 if (directPathMatches != null) {<pre><code>addMatchingMappings(directPathMatches, matches, request);
</code></pre> }
 if (matches.isEmpty()) {<pre><code>// No choice but to go through all mappings...
</code></pre></t></li>
<li><p>// &#x52A0;&#x5165;&#x6240;&#x6709;&#x7684;&#x6620;&#x5C04;</p>
<pre><code>addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);
</code></pre><p> }</p>
<p> if (!matches.isEmpty()) {</p>
<pre><code>Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request));
</code></pre></li>
<li><p>// &#x6309;&#x5339;&#x914D;&#x7A0B;&#x5EA6;&#x6392;&#x5E8F;</p>
<pre><code>Collections.sort(matches, comparator);
if (logger.isTraceEnabled()) {
   logger.trace(&quot;Found &quot; + matches.size() + &quot; matching mapping(s) for [&quot; +
         lookupPath + &quot;] : &quot; + matches);
}
</code></pre><ul>
<li><p>// &#x5F97;&#x5230;&#x6700;&#x7B26;&#x5408;&#x7684;&#x5339;&#x914D;&#x7ED3;&#x679C;
Match bestMatch = matches.get(0);
if (matches.size() &gt; 1) {
   if (CorsUtils.isPreFlightRequest(request)) {</p>
<pre><code>  return PREFLIGHT_AMBIGUOUS_MATCH;
</code></pre><p>   }
   Match secondBestMatch = matches.get(1);
   if (comparator.compare(bestMatch, secondBestMatch) == 0) {</p>
<pre><code>  Method m1 = bestMatch.handlerMethod.getMethod();
  Method m2 = secondBestMatch.handlerMethod.getMethod();
  throw new IllegalStateException(&quot;Ambiguous handler methods mapped for HTTP path &apos;&quot; +
        request.getRequestURL() + &quot;&apos;: {&quot; + m1 + &quot;, &quot; + m2 + &quot;}&quot;);
</code></pre><p>   }
}
handleMatch(bestMatch.mapping, lookupPath, request);
return bestMatch.handlerMethod;
}
else {
return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);
}
}</p>
</li>
<li><p>2.1.2) getHandlerExecutionChain&#xFF08;&#x52A0;&#x5165;&#x62E6;&#x622A;&#x5668;)</p>
</li>
</ul>
</li>
<li>&#x5C06;handler&#x5B9E;&#x4F8B;&#x548C;&#x6240;&#x6709;&#x5339;&#x914D;&#x7684;&#x62E6;&#x622A;&#x5668;&#x5C01;&#x88C5;&#x5230;HandlerExecutionChain&#x4E2D;&#x3002;</li>
<li><p>protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {
 HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?</p>
<pre><code>   (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));
</code></pre><p> String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);
 for (HandlerInterceptor interceptor : this.adaptedInterceptors) {</p>
<pre><code>if (interceptor instanceof MappedInterceptor) {
   MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;
   if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {
      chain.addInterceptor(mappedInterceptor.getInterceptor());
   }
}
else {
   chain.addInterceptor(interceptor);
}
</code></pre><p> }
 return chain;
}</p>
<ul>
<li>3) noHandlerFound&#xFF08;&#x6CA1;&#x6709;&#x627E;&#x5230;HandlerExecutionChain)</li>
</ul>
</li>
<li>protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {
 if (pageNotFoundLogger.isWarnEnabled()) {<pre><code>pageNotFoundLogger.warn(&quot;No mapping found for HTTP request with URI [&quot; + getRequestUri(request) +
      &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);
</code></pre> }</li>
<li><p>// &#x9ED8;&#x8BA4;&#x4E3A;false
 if (this.throwExceptionIfNoHandlerFound) {</p>
<pre><code>throw new NoHandlerFoundException(request.getMethod(), getRequestUri(request),
      new ServletServerHttpRequest(request).getHeaders());
</code></pre><p> }
 else {</p>
<pre><code>response.sendError(HttpServletResponse.SC_NOT_FOUND);
</code></pre><p> }
}</p>
</li>
<li><ul>
<li>4) getHandlerAdapter&#xFF08;&#x6839;&#x636E;HandlerExecutionChain&#x83B7;&#x53D6;HandlerAdapter)</li>
</ul>
</li>
<li><p>protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
 for (HandlerAdapter ha : this.handlerAdapters) {</p>
<pre><code>if (logger.isTraceEnabled()) {
   logger.trace(&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;);
}
if (ha.supports(handler)) {
   return ha;
}
</code></pre><p> }
 throw new ServletException(&quot;No adapter for handler [&quot; + handler +</p>
<pre><code>   &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);
</code></pre><p>}</p>
</li>
<li><p>4.1-a) SimpleControllerHandlerAdapter#supports</p>
</li>
</ul>
<pre><code>public boolean supports(Object handler) {
   return (handler instanceof Controller);
}
</code></pre><ul>
<li>4.1-b) AbstractHandlerMethodAdapter#supports</li>
</ul>
<pre><code>public final boolean supports(Object handler) {
   return (handler instanceof HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));
}
</code></pre><pre><code>- 5) HandlerExecutionChain#applyPreHandle&#xFF08;&#x62E6;&#x622A;&#x5668;preHandle)
</code></pre><ul>
<li><p>boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
 HandlerInterceptor[] interceptors = getInterceptors();
 if (!ObjectUtils.isEmpty(interceptors)) {</p>
<pre><code>for (int i = 0; i &lt; interceptors.length; i++) {
   HandlerInterceptor interceptor = interceptors[i];
   if (!interceptor.preHandle(request, response, this.handler)) {
      triggerAfterCompletion(request, response, null);
      return false;
   }
   this.interceptorIndex = i;
}
</code></pre><p> }
 return true;
}</p>
<ul>
<li>6) HandlerAdapter#handle&#xFF08;&#x5904;&#x7406;&#x8BF7;&#x6C42;)</li>
</ul>
</li>
<li><p>ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;</p>
</li>
<li><p>6.1-a) SimpleControllerHandlerAdapter.handle</p>
</li>
</ul>
<pre><code>public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
      throws Exception {
   return ((Controller) handler).handleRequest(request, response);
}
</code></pre><pre><code>- 6.1.1) AbstractController#handleRequest
</code></pre><pre><code>public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)
      throws Exception {

   if (HttpMethod.OPTIONS.matches(request.getMethod())) {
      response.setHeader(&quot;Allow&quot;, getAllowHeader());
      return null;
   }

   // Delegate to WebContentGenerator for checking and preparing.
   checkRequest(request);
   prepareResponse(response);
   // &#x5982;&#x679C;&#x9700;&#x8981;session&#x5185;&#x7684;&#x540C;&#x6B65;&#x6267;&#x884C;
   // Execute handleRequestInternal in synchronized block if required.
   if (this.synchronizeOnSession) {
      HttpSession session = request.getSession(false);
      if (session != null) {
         Object mutex = WebUtils.getSessionMutex(session);
         synchronized (mutex) {
</code></pre><ul>
<li>// &#x8C03;&#x7528;&#x7528;&#x6237;&#x7684;&#x903B;&#x8F91;<pre><code>      return handleRequestInternal(request, response);
   }
}
</code></pre> }
 // &#x8C03;&#x7528;&#x7528;&#x6237;&#x7684;&#x903B;&#x8F91;
 return handleRequestInternal(request, response);
}</li>
<li>6.1-b) AbstractHandlerMethodAdapter#handle</li>
</ul>
<pre><code>public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
      throws Exception {

   return handleInternal(request, response, (HandlerMethod) handler);
}
</code></pre><pre><code>- 6.1.1) RequestMappingHandlerAdapter#handleInternal
</code></pre><ul>
<li><p>protected ModelAndView handleInternal(HttpServletRequest request,</p>
<pre><code>HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
</code></pre><p> ModelAndView mav;
 checkRequest(request);</p>
<p> // Execute invokeHandlerMethod in synchronized block if required.
 if (this.synchronizeOnSession) {</p>
<pre><code>HttpSession session = request.getSession(false);
if (session != null) {
   Object mutex = WebUtils.getSessionMutex(session);
   synchronized (mutex) {
      mav = invokeHandlerMethod(request, response, handlerMethod);
   }
}
else {
   // No HttpSession available -&gt; no mutex necessary
   mav = invokeHandlerMethod(request, response, handlerMethod);
}
</code></pre><p> }
 else {</p>
<pre><code>// No synchronization on session demanded at all...
mav = invokeHandlerMethod(request, response, handlerMethod);
</code></pre><p> }</p>
<p> if (!response.containsHeader(HEADER_CACHE_CONTROL)) {</p>
<pre><code>if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
   applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);
}
else {
   prepareResponse(response);
}
</code></pre><p> }</p>
<p> return mav;
}</p>
<ul>
<li>6.1.1.1) invokeHandlerMethod</li>
</ul>
</li>
<li><p>protected ModelAndView invokeHandlerMethod(HttpServletRequest request,</p>
<pre><code>HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
</code></pre><p> ServletWebRequest webRequest = new ServletWebRequest(request, response);
 try {</p>
</li>
<li><p>WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</p>
<p>ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
invocableMethod.setDataBinderFactory(binderFactory);
invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);</p>
<p>ModelAndViewContainer mavContainer = new ModelAndViewContainer();
mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
modelFactory.initModel(webRequest, mavContainer, invocableMethod);
mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</p>
<p>AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);
asyncWebRequest.setTimeout(this.asyncRequestTimeout);</p>
<p>WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
asyncManager.setTaskExecutor(this.taskExecutor);
asyncManager.setAsyncWebRequest(asyncWebRequest);
asyncManager.registerCallableInterceptors(this.callableInterceptors);
asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</p>
<p>if (asyncManager.hasConcurrentResult()) {
  Object result = asyncManager.getConcurrentResult();
  mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];
  asyncManager.clearConcurrentResult();
  if (logger.isDebugEnabled()) {</p>
<pre><code> logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);
</code></pre><p>  }
  invocableMethod = invocableMethod.wrapConcurrentResult(result);
}</p>
<p>invocableMethod.invokeAndHandle(webRequest, mavContainer);
if (asyncManager.isConcurrentHandlingStarted()) {
  return null;
}</p>
<p>return getModelAndView(mavContainer, modelFactory, webRequest);
}
finally {
webRequest.requestCompleted();
}
}</p>
</li>
</ul>
<ul>
<li>protected ServletInvocableHandlerMethod createInvocableHandlerMethod(HandlerMethod handlerMethod) {
 return new ServletInvocableHandlerMethod(handlerMethod);
}</li>
</ul>
<pre><code>private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,
      ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception {

   modelFactory.updateModel(webRequest, mavContainer);
   if (mavContainer.isRequestHandled()) {
      return null;
   }
</code></pre><ul>
<li><p>// &#x5C06;&#x8FD4;&#x56DE;&#x503C;ModelMap&#x8F6C;&#x4E3A;ModelAndView
 ModelMap model = mavContainer.getModel();
 ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());
 if (!mavContainer.isViewReference()) {</p>
<pre><code>mav.setView((View) mavContainer.getView());
</code></pre><p> }
 if (model instanceof RedirectAttributes) {</p>
<pre><code>Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();
HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
</code></pre><p> }
 return mav;
}</p>
<ul>
<li>6.1.1.1.1) ServletInvocableHandlerMethod#invokeAndHandle</li>
</ul>
</li>
</ul>
<pre><code>public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
      Object... providedArgs) throws Exception {

   Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
   setResponseStatus(webRequest);

   if (returnValue == null) {
      if (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) {
         mavContainer.setRequestHandled(true);
         return;
      }
   }
   else if (StringUtils.hasText(this.responseReason)) {
      mavContainer.setRequestHandled(true);
      return;
   }

   mavContainer.setRequestHandled(false);
   try {
      this.returnValueHandlers.handleReturnValue(
            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
   }
   catch (Exception ex) {
      if (logger.isTraceEnabled()) {
         logger.trace(getReturnValueHandlingErrorMessage(&quot;Error handling return value&quot;, returnValue), ex);
      }
      throw ex;
   }
}
</code></pre><ul>
<li><ul>
<li>6.1.1.1.1.1) InvocableHandlerMethod#invokeForRequest</li>
</ul>
</li>
</ul>
<pre><code>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,
      Object... providedArgs) throws Exception {

   Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Invoking &apos;&quot; + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +
            &quot;&apos; with arguments &quot; + Arrays.toString(args));
   }
   Object returnValue = doInvoke(args);
   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Method [&quot; + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +
            &quot;] returned [&quot; + returnValue + &quot;]&quot;);
   }
   return returnValue;
}
</code></pre><pre><code>- 6.1.1.1.1.1.1) &#xFF08;&#x5904;&#x7406;&#x53C2;&#x6570;)getMethodArgumentValues&#xFF08;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x6CE8;&#x5165;&#xFF0C;&#x8FD4;&#x56DE;&#x503C;&#x5373;&#x4E3A;&#x65B9;&#x6CD5;&#x53C2;&#x6570;)
</code></pre><pre><code>private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,
      Object... providedArgs) throws Exception {
   // &#x904D;&#x5386;&#x8BF7;&#x6C42;&#x53C2;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x59D4;&#x6258;&#x7ED9;HandlerMethodArgumentResolver#resolveArgument&#x8FDB;&#x884C;&#x53C2;&#x6570;&#x89E3;&#x6790;
   MethodParameter[] parameters = getMethodParameters();
   Object[] args = new Object[parameters.length];
   for (int i = 0; i &lt; parameters.length; i++) {
      MethodParameter parameter = parameters[i];
      parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
      args[i] = resolveProvidedArgument(parameter, providedArgs);
      if (args[i] != null) {
         continue;
      }
      if (this.argumentResolvers.supportsParameter(parameter)) {
         try {
            args[i] = this.argumentResolvers.resolveArgument(
                  parameter, mavContainer, request, this.dataBinderFactory);
            continue;
         }
         catch (Exception ex) {
            if (logger.isDebugEnabled()) {
               logger.debug(getArgumentResolutionErrorMessage(&quot;Failed to resolve&quot;, i), ex);
            }
            throw ex;
         }
      }
      if (args[i] == null) {
         throw new IllegalStateException(&quot;Could not resolve method parameter at index &quot; +
               parameter.getParameterIndex() + &quot; in &quot; + parameter.getMethod().toGenericString() +
               &quot;: &quot; + getArgumentResolutionErrorMessage(&quot;No suitable resolver for&quot;, i));
      }
   }
   return args;
}
</code></pre><pre><code>- 6.1.1.1.1.1.1.1) HandlerMethodArgumentResolverComposite#resolveArgument&#xFF08;&#x5C06;&#x5F62;&#x53C2;&#x89E3;&#x6790;&#x4E3A;&#x5B9E;&#x53C2;)
</code></pre><pre><code>public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
      NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

   HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
   if (resolver == null) {
      throw new IllegalArgumentException(&quot;Unknown parameter type [&quot; + parameter.getParameterType().getName() + &quot;]&quot;);
   }
   return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
}
</code></pre><pre><code>- 6.1.1.1.1.1.1.1.1) getArgumentResolver
</code></pre><pre><code>private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {
   HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);
   if (result == null) {
      for (HandlerMethodArgumentResolver methodArgumentResolver : this.argumentResolvers) {
         if (logger.isTraceEnabled()) {
            logger.trace(&quot;Testing if argument resolver [&quot; + methodArgumentResolver + &quot;] supports [&quot; +
                  parameter.getGenericParameterType() + &quot;]&quot;);
         }
         if (methodArgumentResolver.supportsParameter(parameter)) {
            result = methodArgumentResolver;
            this.argumentResolverCache.put(parameter, result);
            break;
         }
      }
   }
   return result;
}
</code></pre><pre><code>- 6.1.1.1.1.1.1.1.2) &#xFF08;&#x4F8B;&#x5B50;)RequestParamMethodArgumentResolver
</code></pre><pre><code>public boolean supportsParameter(MethodParameter parameter) {
   if (parameter.hasParameterAnnotation(RequestParam.class)) {
      if (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {
         String paramName = parameter.getParameterAnnotation(RequestParam.class).name();
         return StringUtils.hasText(paramName);
      }
      else {
         return true;
      }
   }
   else {
      if (parameter.hasParameterAnnotation(RequestPart.class)) {
         return false;
      }
      parameter = parameter.nestedIfOptional();
      if (MultipartResolutionDelegate.isMultipartArgument(parameter)) {
         return true;
      }
      else if (this.useDefaultResolution) {
         return BeanUtils.isSimpleProperty(parameter.getNestedParameterType());
      }
      else {
         return false;
      }
   }
}
</code></pre><ul>
<li>AbstractNamedValueMethodArgumentResolver#resolveArgument</li>
</ul>
<pre><code>public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
      NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

   NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);
   MethodParameter nestedParameter = parameter.nestedIfOptional();

   Object resolvedName = resolveStringValue(namedValueInfo.name);
   if (resolvedName == null) {
      throw new IllegalArgumentException(
            &quot;Specified name must not resolve to null: [&quot; + namedValueInfo.name + &quot;]&quot;);
   }

   Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);
   if (arg == null) {
      if (namedValueInfo.defaultValue != null) {
         arg = resolveStringValue(namedValueInfo.defaultValue);
      }
      else if (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) {
         handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);
      }
      arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());
   }
   else if (&quot;&quot;.equals(arg) &amp;&amp; namedValueInfo.defaultValue != null) {
      arg = resolveStringValue(namedValueInfo.defaultValue);
   }

   if (binderFactory != null) {
      WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);
      try {
</code></pre><ul>
<li><p>// WebDataBinder&#x8FDB;&#x884C;&#x6570;&#x636E;&#x8F6C;&#x6362;</p>
<pre><code>   arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);
}
catch (ConversionNotSupportedException ex) {
   throw new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),
         namedValueInfo.name, parameter, ex.getCause());
}
catch (TypeMismatchException ex) {
   throw new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),
         namedValueInfo.name, parameter, ex.getCause());

}
</code></pre><p> }</p>
<p> handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</p>
<p> return arg;
}</p>
<ul>
<li>6.1.1.1.1.1.1.1.2.1) resolveName</li>
</ul>
</li>
<li><p>protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {
 HttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);
 MultipartHttpServletRequest multipartRequest =</p>
<pre><code>   WebUtils.getNativeRequest(servletRequest, MultipartHttpServletRequest.class);
</code></pre><p> Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);
 if (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) {</p>
<pre><code>return mpArg;
</code></pre><p> }</p>
<p> Object arg = null;
 if (multipartRequest != null) {</p>
<pre><code>List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);
if (!files.isEmpty()) {
   arg = (files.size() == 1 ? files.get(0) : files);
}
</code></pre><p> }
 if (arg == null) {</p>
<pre><code>String[] paramValues = request.getParameterValues(name);
if (paramValues != null) {
   arg = (paramValues.length == 1 ? paramValues[0] : paramValues);
}
</code></pre><p> }
 return arg;
}</p>
<ul>
<li>6.1.1.1.1.1.1.1.2.2) WebDataBinder#convertIfNecessary</li>
</ul>
</li>
</ul>
<pre><code>public &lt;T&gt; T convertIfNecessary(Object value, Class&lt;T&gt; requiredType, MethodParameter methodParam)
      throws TypeMismatchException {

   return getTypeConverter().convertIfNecessary(value, requiredType, methodParam);
}
</code></pre><pre><code>- 6.1.1.1.1.1.2)&#xFF08;&#x5904;&#x7406;&#x8C03;&#x7528;) InvocableHandlerMethod#doInvoke
</code></pre><ul>
<li>protected Object doInvoke(Object... args) throws Exception {
 ReflectionUtils.makeAccessible(getBridgedMethod());
 try {</li>
<li><p>// Controller&#x4E2D;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;method.invoke</p>
<pre><code>return getBridgedMethod().invoke(getBean(), args);
</code></pre><p> }
 catch (IllegalArgumentException ex) {</p>
<pre><code>assertTargetBean(getBridgedMethod(), getBean(), args);
String text = (ex.getMessage() != null ? ex.getMessage() : &quot;Illegal argument&quot;);
throw new IllegalStateException(getInvocationErrorMessage(text, args), ex);
</code></pre><p> }
 catch (InvocationTargetException ex) {</p>
<pre><code>// Unwrap for HandlerExceptionResolvers ...
Throwable targetException = ex.getTargetException();
if (targetException instanceof RuntimeException) {
   throw (RuntimeException) targetException;
}
else if (targetException instanceof Error) {
   throw (Error) targetException;
}
else if (targetException instanceof Exception) {
   throw (Exception) targetException;
}
else {
   String text = getInvocationErrorMessage(&quot;Failed to invoke handler method&quot;, args);
   throw new IllegalStateException(text, targetException);
}
</code></pre><p> }
}</p>
<ul>
<li>6.1.1.1.1.2) &#xFF08;&#x5904;&#x7406;&#x8FD4;&#x56DE;&#x503C;)HandlerMethodReturnValueHandler#handleReturnValue</li>
</ul>
</li>
<li>&#x4EE5;HandlerMethodReturnValueHandlerComposite&#x4E3A;&#x4F8B;&#xFF1A;</li>
</ul>
<pre><code>public void handleReturnValue(Object returnValue, MethodParameter returnType,
      ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {

   HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
   if (handler == null) {
      throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());
   }
   handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
}
</code></pre><pre><code>- 6.1.1.1.1.2.1) selectHandler
</code></pre><pre><code>private HandlerMethodReturnValueHandler selectHandler(Object value, MethodParameter returnType) {
   boolean isAsyncValue = isAsyncReturnValue(value, returnType);
   for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {
      if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {
         continue;
      }
      if (handler.supportsReturnType(returnType)) {
         return handler;
      }
   }
   return null;
}
</code></pre><ul>
<li>&#x5982;&#x679C;&#x8FD4;&#x56DE;&#x503C;&#x662F;ModelAndView&#xFF0C;&#x90A3;&#x4E48;handler&#x662F;ModelAndViewMethodReturnValueHandler&#x3002;</li>
<li>&#x5982;&#x679C;&#x8FD4;&#x56DE;&#x503C;&#x662F;&#x666E;&#x901A;&#x7684;&#x5BF9;&#x8C61;(@ResponseBody)&#xFF0C;&#x90A3;&#x4E48;handler&#x662F;</li>
<li><p>RequestResponseBodyMethodProcessor&#x3002;</p>
<ul>
<li>6.1.1.1.1.2.2) handleReturnValue</li>
</ul>
</li>
<li>&#x4EE5;RequestResponseBodyMethodProcessor&#x4E3A;&#x4F8B;&#xFF1A;</li>
</ul>
<pre><code>public void handleReturnValue(Object returnValue, MethodParameter returnType,
      ModelAndViewContainer mavContainer, NativeWebRequest webRequest)
      throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {

   mavContainer.setRequestHandled(true);
   ServletServerHttpRequest inputMessage = createInputMessage(webRequest);
   ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);

   // Try even with null return value. ResponseBodyAdvice could get involved.
   writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);
}
</code></pre><ul>
<li>&#x4EE5;ModelAndViewMethodReturnValueHandler&#x4E3A;&#x4F8B;&#xFF1A;</li>
</ul>
<pre><code>public void handleReturnValue(Object returnValue, MethodParameter returnType,
      ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {

   if (returnValue == null) {
      mavContainer.setRequestHandled(true);
      return;
   }

   ModelAndView mav = (ModelAndView) returnValue;
   if (mav.isReference()) {
      String viewName = mav.getViewName();
      mavContainer.setViewName(viewName);
      if (viewName != null &amp;&amp; isRedirectViewName(viewName)) {
         mavContainer.setRedirectModelScenario(true);
      }
   }
   else {
      View view = mav.getView();
      mavContainer.setView(view);
      if (view instanceof SmartView) {
         if (((SmartView) view).isRedirectView()) {
            mavContainer.setRedirectModelScenario(true);
         }
      }
   }
   mavContainer.setStatus(mav.getStatus());
   mavContainer.addAllAttributes(mav.getModel());
}
</code></pre><ul>
<li><ul>
<li>7) applyDefaultViewName&#xFF08;&#x8F6C;&#x6362;&#x89C6;&#x56FE;&#x540D;&#x79F0;)</li>
</ul>
</li>
</ul>
<pre><code>private void applyDefaultViewName(HttpServletRequest request, ModelAndView mv) throws Exception {
   if (mv != null &amp;&amp; !mv.hasView()) {
      mv.setViewName(getDefaultViewName(request));
   }
}
</code></pre><ul>
<li><p>protected String getDefaultViewName(HttpServletRequest request) throws Exception {
 return this.viewNameTranslator.getViewName(request);
}</p>
</li>
<li><p>DefaultRequestToViewNameTransaltor.getDefaultViewName</p>
</li>
</ul>
<pre><code>public String getViewName(HttpServletRequest request) {
   String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);
   return (this.prefix + transformPath(lookupPath) + this.suffix);
}
</code></pre><pre><code>- 8) HandlerExecutionChain#applyPostHandle&#xFF08;&#x62E6;&#x622A;&#x5668;postHandle)
</code></pre><ul>
<li><p>void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception {
 HandlerInterceptor[] interceptors = getInterceptors();
 if (!ObjectUtils.isEmpty(interceptors)) {</p>
<pre><code>for (int i = interceptors.length - 1; i &gt;= 0; i--) {
   HandlerInterceptor interceptor = interceptors[i];
   interceptor.postHandle(request, response, this.handler, mv);
}
</code></pre><p> }
}</p>
<ul>
<li>9) processDispatchResult&#xFF08;&#x5904;&#x7406;ModelAndView&#x8BF7;&#x6C42;&#x7ED3;&#x679C;)</li>
</ul>
</li>
<li>&#x5982;&#x679C;&#x8FD4;&#x56DE;&#x7684;&#x662F;&#x7EAF;&#x6570;&#x636E;&#xFF08;@ResponseBody)&#xFF0C;mv&#x5C31;&#x662F;null&#xFF0C;&#x8BE5;&#x65B9;&#x6CD5;&#x57FA;&#x672C;&#x4E0A;&#x662F;&#x7A7A;&#x65B9;&#x6CD5;&#x3002;</li>
</ul>
<pre><code>private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
      HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {

   boolean errorView = false;

   if (exception != null) {
      if (exception instanceof ModelAndViewDefiningException) {
         logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);
         mv = ((ModelAndViewDefiningException) exception).getModelAndView();
      }
      else {
         Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
</code></pre><ul>
<li><p>// &#x5904;&#x7406;&#x5F02;&#x5E38;</p>
<pre><code>   mv = processHandlerException(request, response, handler, exception);
   errorView = (mv != null);
}
</code></pre><p> }</p>
<p> // Did the handler return a view to render?</p>
</li>
<li><p>// &#x5982;&#x679C;handler&#x5904;&#x7406;&#x7ED3;&#x679C;&#x4E2D;&#x8FD4;&#x56DE;&#x4E86;view&#xFF0C;&#x90A3;&#x4E48;&#x9700;&#x8981;&#x5BF9;&#x9875;&#x9762;&#x8FDB;&#x884C;&#x6E32;&#x67D3;
 if (mv != null &amp;&amp; !mv.wasCleared()) {</p>
<pre><code>render(mv, request, response);
if (errorView) {
   WebUtils.clearErrorRequestAttributes(request);
}
</code></pre><p> }
 else {</p>
<pre><code>if (logger.isDebugEnabled()) {
   logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name &apos;&quot; + getServletName() +
         &quot;&apos;: assuming HandlerAdapter completed request handling&quot;);
}
</code></pre><p> }</p>
<p> if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {</p>
<pre><code>// Concurrent handling started during a forward
return;
</code></pre><p> }</p>
<p> if (mappedHandler != null) {</p>
<pre><code>mappedHandler.triggerAfterCompletion(request, response, null);
</code></pre><p> }
}</p>
<ul>
<li>9.1) processHandlerException&#xFF08;&#x5904;&#x7406;&#x5F02;&#x5E38;)</li>
</ul>
</li>
<li><p>protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,</p>
<pre><code>Object handler, Exception ex) throws Exception {
</code></pre><p> // Check registered HandlerExceptionResolvers...
 ModelAndView exMv = null;
 for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {</p>
</li>
<li><p>// &#x4F7F;&#x7528;handlerExceptionResolver&#x6765;&#x5904;&#x7406;&#x5F02;&#x5E38;</p>
<pre><code>exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);
if (exMv != null) {
   break;
}
</code></pre><p> }
 if (exMv != null) {</p>
<pre><code>if (exMv.isEmpty()) {
   request.setAttribute(EXCEPTION_ATTRIBUTE, ex);
   return null;
}
// We might still need view name translation for a plain error model...
if (!exMv.hasView()) {
   exMv.setViewName(getDefaultViewName(request));
}
if (logger.isDebugEnabled()) {
   logger.debug(&quot;Handler execution resulted in exception - forwarding to resolved error view: &quot; + exMv, ex);
}
WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());
return exMv;
</code></pre><p> }</p>
<p> throw ex;
}</p>
<ul>
<li>9.2) render&#xFF08;&#x6E32;&#x67D3;&#x89C6;&#x56FE;)</li>
</ul>
</li>
<li><p>protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {
 // Determine locale for request and apply it to the response.
 Locale locale = this.localeResolver.resolveLocale(request);
 response.setLocale(locale);</p>
<p> View view;
 if (mv.isReference()) {</p>
<pre><code>// We need to resolve the view name.
view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
if (view == null) {
   throw new ServletException(&quot;Could not resolve view with name &apos;&quot; + mv.getViewName() +
         &quot;&apos; in servlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);
}
</code></pre><p> }
 else {</p>
<pre><code>// No need to lookup: the ModelAndView object contains the actual View object.
view = mv.getView();
if (view == null) {
   throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +
         &quot;View object in servlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);
}
</code></pre><p> }</p>
<p> // Delegate to the View object for rendering.
 if (logger.isDebugEnabled()) {</p>
<pre><code>logger.debug(&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);
</code></pre><p> }
 try {</p>
<pre><code>if (mv.getStatus() != null) {
   response.setStatus(mv.getStatus().value());
}
view.render(mv.getModelInternal(), request, response);
</code></pre><p> }
 catch (Exception ex) {</p>
<pre><code>if (logger.isDebugEnabled()) {
   logger.debug(&quot;Error rendering view [&quot; + view + &quot;] in DispatcherServlet with name &apos;&quot; +
         getServletName() + &quot;&apos;&quot;, ex);
}
throw ex;
</code></pre><p> }
}</p>
<ul>
<li>9.2.1) resolveViewName&#xFF08;&#x521B;&#x5EFA;&#x89C6;&#x56FE;)</li>
</ul>
</li>
<li><p>protected View resolveViewName(String viewName, Map<string, object=""> model, Locale locale,</string,></p>
<pre><code>HttpServletRequest request) throws Exception {
</code></pre><p> for (ViewResolver viewResolver : this.viewResolvers) {</p>
</li>
<li>// &#x4F7F;&#x7528;viewResolver&#x89E3;&#x6790;&#x89C6;&#x56FE;&#x540D;&#x79F0;<pre><code>View view = viewResolver.resolveViewName(viewName, locale);
if (view != null) {
   return view;
}
</code></pre> }
 return null;
}<ul>
<li>9.2.1.1) AbstractCachingViewResolver#resolveViewName</li>
</ul>
</li>
</ul>
<pre><code>public View resolveViewName(String viewName, Locale locale) throws Exception {
   if (!isCache()) {
</code></pre><ul>
<li>// &#x4E0D;&#x5B58;&#x5728;&#x7F13;&#x5B58;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x76F4;&#x63A5;&#x521B;&#x5EFA;&#x89C6;&#x56FE;<pre><code>return createView(viewName, locale);
</code></pre> }
 else {</li>
<li><p>// &#x76F4;&#x63A5;&#x4ECE;&#x7F13;&#x5B58;&#x4E2D;&#x83B7;&#x53D6;</p>
<pre><code>Object cacheKey = getCacheKey(viewName, locale);
View view = this.viewAccessCache.get(cacheKey);
if (view == null) {
   synchronized (this.viewCreationCache) {
      view = this.viewCreationCache.get(cacheKey);
      if (view == null) {
         // Ask the subclass to create the View object.
         view = createView(viewName, locale);
         if (view == null &amp;&amp; this.cacheUnresolved) {
            view = UNRESOLVED_VIEW;
         }
         if (view != null) {
            this.viewAccessCache.put(cacheKey, view);
            this.viewCreationCache.put(cacheKey, view);
            if (logger.isTraceEnabled()) {
               logger.trace(&quot;Cached view [&quot; + cacheKey + &quot;]&quot;);
            }
         }
      }
   }
}
return (view != UNRESOLVED_VIEW ? view : null);
</code></pre><p> }
}</p>
<ul>
<li>9.2.1.1.1) UrlBasedViewResolver#createView</li>
</ul>
</li>
<li>protected View createView(String viewName, Locale locale) throws Exception {
 // If this resolver is not supposed to handle the given view,
 // return null to pass on to the next resolver in the chain.</li>
<li>// &#x5982;&#x679C;&#x5F53;&#x524D;&#x89E3;&#x6790;&#x5668;&#x4E0D;&#x652F;&#x6301;&#x5F53;&#x524D;&#x89E3;&#x6790;&#x5668;&#xFF0C;&#x5982;viewName&#x4E3A;&#x7A7A;&#x7B49;&#x60C5;&#x51B5;
 if (!canHandle(viewName, locale)) {<pre><code>return null;
</code></pre> }</li>
<li>// &#x5904;&#x7406;redirect:xx&#x7684;&#x60C5;&#x51B5;
 // Check for special &quot;redirect:&quot; prefix.
 if (viewName.startsWith(REDIRECT_URL_PREFIX)) {<pre><code>String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());
RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible());
view.setHosts(getRedirectHosts());
return applyLifecycleMethods(viewName, view);
</code></pre> }</li>
<li><p>// &#x5904;&#x7406;forward:xx&#x7684;&#x60C5;&#x51B5;
 // Check for special &quot;forward:&quot; prefix.
 if (viewName.startsWith(FORWARD_URL_PREFIX)) {</p>
<pre><code>String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());
return new InternalResourceView(forwardUrl);
</code></pre><p> }
 // Else fall back to superclass implementation: calling loadView.
 return super.createView(viewName, locale);
}</p>
</li>
<li><p>AbstractCachingViewResolver.createView</p>
</li>
<li><p>protected View createView(String viewName, Locale locale) throws Exception {
 return loadView(viewName, locale);
}</p>
</li>
<li><p>UrlBasedViewResolver.loadView</p>
</li>
<li><p>protected View loadView(String viewName, Locale locale) throws Exception {
 AbstractUrlBasedView view = buildView(viewName);
 View result = applyLifecycleMethods(viewName, view);
 return (view.checkResource(locale) ? result : null);
}</p>
</li>
<li><p>UrlBasedViewResolver.buildView</p>
</li>
<li>protected AbstractUrlBasedView buildView(String viewName) throws Exception {
 AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(getViewClass());</li>
<li><p>// &#x6DFB;&#x52A0;&#x524D;&#x7F00;&#x548C;&#x540E;&#x7F00;
 view.setUrl(getPrefix() + viewName + getSuffix());</p>
<p> String contentType = getContentType();
 if (contentType != null) {</p>
</li>
<li><p>// &#x8BBE;&#x7F6E;ContentType</p>
<pre><code>view.setContentType(contentType);
</code></pre><p> }</p>
<p> view.setRequestContextAttribute(getRequestContextAttribute());
 view.setAttributesMap(getAttributesMap());</p>
<p> Boolean exposePathVariables = getExposePathVariables();
 if (exposePathVariables != null) {</p>
<pre><code>view.setExposePathVariables(exposePathVariables);
</code></pre><p> }
 Boolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes();
 if (exposeContextBeansAsAttributes != null) {</p>
<pre><code>view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);
</code></pre><p> }
 String[] exposedContextBeanNames = getExposedContextBeanNames();
 if (exposedContextBeanNames != null) {</p>
<pre><code>view.setExposedContextBeanNames(exposedContextBeanNames);
</code></pre><p> }</p>
<p> return view;
}</p>
<ul>
<li>9.2.2) AbstractView.render&#xFF08;&#x9875;&#x9762;&#x8DF3;&#x8F6C;)</li>
</ul>
</li>
</ul>
<pre><code>public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception {
   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Rendering view with name &apos;&quot; + this.beanName + &quot;&apos; with model &quot; + model +
         &quot; and static attributes &quot; + this.staticAttributes);
   }
   // &#x5904;&#x7406;Model
   Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response);
   prepareResponse(request, response);
</code></pre><ul>
<li><p>// &#x5904;&#x7406;&#x9875;&#x9762;&#x8DF3;&#x8F6C; 
 renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);
}</p>
<ul>
<li>9.2.2.1) AbstractView#createMergedOutputModel&#xFF08;&#x5904;&#x7406;Model)</li>
</ul>
</li>
<li><p>protected Map<string, object=""> createMergedOutputModel(Map<string, ?=""> model, HttpServletRequest request,</string,></string,></p>
<pre><code>HttpServletResponse response) {
</code></pre><p> @SuppressWarnings(&quot;unchecked&quot;)
 Map<string, object=""> pathVars = (this.exposePathVariables ?</string,></p>
<pre><code>   (Map&lt;String, Object&gt;) request.getAttribute(View.PATH_VARIABLES) : null);
</code></pre><p> // Consolidate static and dynamic model attributes.
 int size = this.staticAttributes.size();
 size += (model != null ? model.size() : 0);
 size += (pathVars != null ? pathVars.size() : 0);</p>
<p> Map<string, object=""> mergedModel = new LinkedHashMap<string, object="">(size);
 mergedModel.putAll(this.staticAttributes);
 if (pathVars != null) {</string,></string,></p>
<pre><code>mergedModel.putAll(pathVars);
</code></pre><p> }
 if (model != null) {</p>
<pre><code>mergedModel.putAll(model);
</code></pre><p> }</p>
<p> // Expose RequestContext?
 if (this.requestContextAttribute != null) {</p>
<pre><code>mergedModel.put(this.requestContextAttribute, createRequestContext(request, response, mergedModel));
</code></pre><p> }</p>
<p> return mergedModel;
}</p>
<ul>
<li>9.2.2.2) renderMergedOutputModel#renderMergedOutputModel&#xFF08;&#x5904;&#x7406;&#x9875;&#x9762;&#x8DF3;&#x8F6C;)</li>
</ul>
</li>
<li><p>protected void renderMergedOutputModel(</p>
<pre><code>Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception {
</code></pre><p> // &#x5C06;model&#x4E2D;&#x7684;&#x6570;&#x636E;&#x4EE5;&#x5C5E;&#x6027;&#x65B9;&#x5F0F;&#x8BBE;&#x7F6E;&#x5230;request&#x4E2D;
 // Expose the model object as request attributes.
 exposeModelAsRequestAttributes(model, request);</p>
<p> // Expose helpers as request attributes, if any.
 exposeHelpers(request);</p>
<p> // Determine the path for the request dispatcher.
 String dispatcherPath = prepareForRendering(request, response);</p>
<p> // Obtain a RequestDispatcher for the target resource (typically a JSP).
 RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);
 if (rd == null) {</p>
<pre><code>throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +
      &quot;]: Check that the corresponding file exists within your web application archive!&quot;);
</code></pre><p> }</p>
<p> // If already included or response already committed, perform include, else forward.
 if (useInclude(request, response)) {</p>
<pre><code>response.setContentType(getContentType());
if (logger.isDebugEnabled()) {
   logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;);
}
rd.include(request, response);
</code></pre><p> }</p>
<p> else {</p>
<pre><code>// Note: The forwarded resource is supposed to determine the content type itself.
if (logger.isDebugEnabled()) {
   logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;);
}
rd.forward(request, response);
</code></pre><p> }
}</p>
</li>
<li></li>
<li><p>&#x5B9E;&#x4F8B;-MVC</p>
</li>
</ul>
<pre><code>@Controller
public class IndexController {

    @RequestMapping(&quot;/hello&quot;)
    public ModelAndView index(ModelAndView modelAndView){
        modelAndView.addObject(&quot;user&quot;,new RegisterDTO(&quot;admin&quot;));
        modelAndView.setViewName(&quot;hello&quot;);
        return modelAndView;
    }
}
</code></pre><ul>
<li>hello.jsp</li>
<li><body>
  <h1 id="hello-world"><a name="hello-world" class="plugin-anchor" href="#hello-world"><i class="fa fa-link" aria-hidden="true"></i></a>Hello World!</h1>
  ${requestScope.user.username}
</body>
</li>
<li><p>&#x6267;&#x884C;&#x8DEF;&#x5F84;&#xFF1A;</p>
</li>
<li><p>getHandler&#x4E2D;handlerMappings&#x4E3A;</p>
</li>
<li><p>hm&#x662F;0&#x53F7;&#xFF0C;&#x5B83;&#x8C03;&#x7528;getHandler&#x3002;</p>
</li>
<li>HandlerExecutionChain handler = hm.getHandler(request);</li>
<li>&#x8BE5;&#x65B9;&#x6CD5;&#x4E2D;&#x7684;getHandlerInternal&#x65B9;&#x6CD5;&#x8FD9;&#x91CC;&#x7528;&#x5230;&#x7684;&#x7C7B;&#x662F;AbstractHandlerMethodMapping&#x3002;</li>
<li>&#x6700;&#x7EC8;&#x8FD4;&#x56DE;&#x7684;&#x662F;&#x8BE5;handler&#xFF0C;&#x7C7B;&#x578B;&#x662F;HandlerMethod&#x3002;</li>
</ul>
<ul>
<li><p>getHandlerExecutionChain&#x6267;&#x884C;&#x5B8C;&#x540E;&#x591A;&#x4E86;&#x4E09;&#x4E2A;interceptor&#x3002;</p>
</li>
<li><p>getHandlerAdapter&#x4E2D;&#x7684;handlerAdapters&#x662F;</p>
</li>
<li><p>&#x904D;&#x5386;&#x65F6;&#x5148;&#x7528;&#x5230;&#x7684;&#x662F;RequestMappingHandlerAdapter&#xFF0C;&#x8C03;&#x7528;&#x7684;supports&#x662F;AbstractHandlerMethodAdapter&#x3002;&#x5339;&#x914D;&#x540E;&#xFF0C;&#x8FD4;&#x56DE;&#x7684;adapter&#x662F;RequestMappingHandlerAdapter&#x7C7B;&#x578B;&#x7684;</p>
</li>
<li></li>
<li><p>&#x7136;&#x540E;&#x8C03;&#x7528;&#x8BE5;adapter&#x7684;handle&#x65B9;&#x6CD5;&#x3002;</p>
</li>
<li>handle&#x65B9;&#x6CD5;&#x6700;&#x7EC8;&#x4F1A;&#x8C03;&#x7528;Controller&#x7684;&#x5BF9;&#x5E94;&#x65B9;&#x6CD5;&#xFF0C;&#x7136;&#x540E;&#x83B7;&#x53D6;ModelAndView&#x7C7B;&#x578B;&#x8FD4;&#x56DE;&#x503C;&#x7684;ModelAndViewMethodReturnValueHandler&#xFF0C;&#x5BF9;modelAndView&#x8FDB;&#x884C;&#x5904;&#x7406;&#x3002;</li>
<li>&#x7136;&#x540E;&#x8C03;&#x7528;applyDefaultViewName&#x65B9;&#x6CD5;.</li>
<li><p>&#x5728;&#x8C03;&#x7528;processDispatchResult&#x4E4B;&#x524D;&#xFF0C;modelAndView&#x662F;&#x8FD9;&#x6837;&#x7684;&#x3002;</p>
</li>
<li><p>&#x7136;&#x540E;&#x53BB;&#x8C03;&#x7528;render&#x65B9;&#x6CD5;&#x3002;</p>
</li>
<li>render</li>
<li>-&gt;InternalResourceViewResolver.resolveViewName</li>
<li>-&gt;UriBasedViewResolver.createView</li>
<li>-&gt;UriBasedViewResolver.loadView</li>
<li>-&gt;InternalResourceViewResolver.buildView</li>
<li><p>&#x6B64;&#x65F6;&#x5F97;&#x5230;&#x7684;view&#x5982;&#x4E0B;&#xFF1A;</p>
</li>
<li><p>&#x4E4B;&#x540E;&#x53C8;&#x8C03;&#x7528;&#x4E86;view&#x7684;render&#x65B9;&#x6CD5;&#xFF0C;&#x6700;&#x7EC8;&#x8C03;&#x7528;&#x4E86;requestDispatcher.forward&#x65B9;&#x6CD5;&#x7ED3;&#x675F;&#x6574;&#x4E2A;&#x8FC7;&#x7A0B;&#x3002;</p>
</li>
<li></li>
<li><p>&#x5B9E;&#x4F8B;-REST</p>
</li>
</ul>
<pre><code>@RequestMapping(&quot;/users/{name}&quot;)
@ResponseBody
public RegisterDTO findUserByName(@PathVariable(&quot;name&quot;) String name){
    return new RegisterDTO(name);
}
</code></pre><ul>
<li>&#x524D;&#x9762;&#x90FD;&#x4E00;&#x6837;&#xFF0C;&#x4F46;&#x662F;&#x5904;&#x7406;&#x8BF7;&#x6C42;&#x7ED3;&#x679C;&#x65F6;&#x4F7F;&#x7528;&#x7684;handler&#x4E0D;&#x4E00;&#x6837;&#xFF0C;&#x5B83;&#x4F7F;&#x7528;&#x7684;&#x662F;RequestResponseBodyMethodProcessor&#xFF0C;&#x5C06;&#x8FD4;&#x56DE;&#x503C;&#x5199;&#x5165;&#x8F93;&#x51FA;&#x6D41;&#x3002;</li>
<li></li>
</ul>

<script>console.log("plugin-popup....");document.onclick = function(e){ e.target.tagName === "IMG" && window.open(e.target.src,e.target.src)}</script><style>img{cursor:pointer}</style>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="二、设计模式.html" class="navigation navigation-prev " aria-label="Previous page: 二、设计模式">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="二十一、Tomcat源码解析.html" class="navigation navigation-next " aria-label="Next page: 二十一、Tomcat源码解析">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"二十、Spring源码解析","level":"1.11.8","depth":2,"next":{"title":"二十一、Tomcat源码解析","level":"1.11.9","depth":2,"path":"zother5-Java-Interview/二十一、Tomcat源码解析.md","ref":"zother5-Java-Interview/二十一、Tomcat源码解析.md","articles":[]},"previous":{"title":"二、设计模式","level":"1.11.7","depth":2,"path":"zother5-Java-Interview/二、设计模式.md","ref":"zother5-Java-Interview/二、设计模式.md","articles":[]},"dir":"ltr"},"config":{"plugins":["github","-highlight","baidu","splitter","sitemap","back-to-top-button","code","splitter","-lunr","-search","search-pro","theme-comscore","popup","hide-element","anchors","nocache","page-toc-button"],"ignores":["friends","tags","categories","about"],"root":".deploy/content","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"nocache":{},"github":{"url":"https://github.com/zhaoda/webpack-handbook"},"editlink":{"base":"https://github.com/zhaoda/webpack-handbook/blob/master/content","label":"编辑本页"},"splitter":{},"search-pro":{},"popup":{},"code":{"copyButtons":true},"hide-element":{"elements":[".gitbook-link"]},"fontsettings":{"theme":"white","family":"sans","size":2},"sitemap":{"hostname":"http://zhaoda.net/"},"theme-comscore":{},"page-toc-button":{"maxTocDepth":2,"minTocSize":2},"back-to-top-button":{},"baidu":{"token":"a9787f0ab45d5e237bab522431d0a7ec"},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"anchors":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"SUMMARY.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"java实用笔记","language":"zh-hans","output.name":"site","catalog":["./source/_posts"],"links":{"sidebar":{"Home":"http://blog.liangqingxiang.top/"}},"gitbook":"3.2.3","description":"学习笔记"},"file":{"path":"zother5-Java-Interview/二十、Spring源码解析.md","mtime":"2020-05-26T10:43:01.444Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-06-05T14:48:02.927Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-baidu/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-hide-element/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-nocache/nocache.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
        
    

    </body>
</html>

